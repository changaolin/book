<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>梦北</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="学习笔记">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">README</a></li><li class="chapter-item expanded "><a href="CPP/index.html"><strong aria-hidden="true">1.</strong> CPP学习笔记</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="CPP/Object.html"><strong aria-hidden="true">1.1.</strong> 类</a></li><li class="chapter-item expanded "><a href="CPP/STL.html"><strong aria-hidden="true">1.2.</strong> STL</a></li><li class="chapter-item expanded "><a href="CPP/Thread.html"><strong aria-hidden="true">1.3.</strong> Thread</a></li><li class="chapter-item expanded "><a href="CPP/TCP_socket.html"><strong aria-hidden="true">1.4.</strong> TCP_Socket</a></li><li class="chapter-item expanded "><a href="CPP/C++11.html"><strong aria-hidden="true">1.5.</strong> C++11</a></li><li class="chapter-item expanded "><a href="CPP/EMC++.html"><strong aria-hidden="true">1.6.</strong> Effective Modern C++</a></li></ol></li><li class="chapter-item expanded "><a href="Programmer/index.html"><strong aria-hidden="true">2.</strong> 程序员笔记</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Programmer/pkg_config.html"><strong aria-hidden="true">2.1.</strong> PKG-CONFIG</a></li></ol></li><li class="chapter-item expanded "><a href="Media/index.html"><strong aria-hidden="true">3.</strong> 流媒体笔记</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Media/ffmpeg_cmd.html"><strong aria-hidden="true">3.1.</strong> FFMPEG 命令行学习笔记</a></li><li class="chapter-item expanded "><a href="Media/ffmpeg_install.html"><strong aria-hidden="true">3.2.</strong> FFMPEG 安装 MACOS</a></li><li class="chapter-item expanded "><a href="Media/cmake.html"><strong aria-hidden="true">3.3.</strong> CMAKE 模板</a></li><li class="chapter-item expanded "><a href="Media/yuvplayer.html"><strong aria-hidden="true">3.4.</strong> YUVPLayer Demo(C)</a></li><li class="chapter-item expanded "><a href="Media/pcmplayer.html"><strong aria-hidden="true">3.5.</strong> PCMPLayer Demo(C)</a></li></ol></li><li class="chapter-item expanded "><a href="Redis/index.html"><strong aria-hidden="true">4.</strong> Redis</a></li><li class="chapter-item expanded "><a href="NET/index.html"><strong aria-hidden="true">5.</strong> NET</a></li><li class="chapter-item expanded "><a href="Vim/index.html"><strong aria-hidden="true">6.</strong> VIM</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Vim/ccls.html"><strong aria-hidden="true">6.1.</strong> CCLS</a></li></ol></li><li class="chapter-item expanded "><a href="Romanic/index.html"><strong aria-hidden="true">7.</strong> 四大浪漫</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Romanic/zoo.html"><strong aria-hidden="true">7.1.</strong> 计算机组成原理</a></li><li class="chapter-item expanded "><a href="Romanic/os.html"><strong aria-hidden="true">7.2.</strong> 操作系统实战笔记</a></li></ol></li><li class="chapter-item expanded "><a href="Tools/index.html"><strong aria-hidden="true">8.</strong> 工具</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Tools/Verilog.html"><strong aria-hidden="true">8.1.</strong> Verilog on MAC</a></li><li class="chapter-item expanded "><a href="Tools/Rules.html"><strong aria-hidden="true">8.2.</strong> Verilog语法规则</a></li></ol></li><li class="chapter-item expanded "><a href="WEB/index.html"><strong aria-hidden="true">9.</strong> Web</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="WEB/WebAssembly.html"><strong aria-hidden="true">9.1.</strong> WebAssembly</a></li></ol></li><li class="chapter-item expanded "><a href="Tools/index.html"><strong aria-hidden="true">10.</strong> Tools</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Tools/gparted.html"><strong aria-hidden="true">10.1.</strong> gparted</a></li></ol></li><li class="chapter-item expanded "><a href="ROS2/index.html"><strong aria-hidden="true">11.</strong> ROS2</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ROS2/ros2_qt_demo构建流程.html"><strong aria-hidden="true">11.1.</strong> ros2_qt_demo</a></li></ol></li><li class="chapter-item expanded "><a href="HASS/index.html"><strong aria-hidden="true">12.</strong> HASS</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="HASS/安装流程.html"><strong aria-hidden="true">12.1.</strong> HASS安装</a></li></ol></li><li class="chapter-item expanded "><a href="PostgreSQL/index.html"><strong aria-hidden="true">13.</strong> PostgreSQL</a></li><li class="chapter-item expanded "><a href="Docker/index.html"><strong aria-hidden="true">14.</strong> Docker</a></li><li class="chapter-item expanded "><a href="Rust/index.html"><strong aria-hidden="true">15.</strong> Rust</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">梦北</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="readme"><a class="header" href="#readme">README</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cpp学习笔记"><a class="header" href="#cpp学习笔记">CPP学习笔记</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基于类对象"><a class="header" href="#基于类对象">基于类（对象）</a></h1>
<ul>
<li>
<p>类是<font color='red'><strong>数据</strong></font>和数据的处理函数的一种组织形式。</p>
</li>
<li>
<p>类的设计要点（优先考虑<font color='red'><strong>数据</strong></font>的设计）：</p>
<ul>
<li>
<p>类Header 和 类Body</p>
</li>
<li>
<p>类分为无指针类，和有指针类（拷贝构造，delete []等）</p>
</li>
<li>
<p>构造函数无返回值，尽量使用构造参数列表形式。</p>
<ul>
<li>拷贝构造：String(const String&amp; str)</li>
<li>拷贝赋值：String&amp; operator=(const String&amp; str)  || return *this</li>
<li>委托构造</li>
</ul>
</li>
<li>
<p>函数构造需要考虑（名称-参数（类型，权限）-返回值（类型，权限））：</p>
<ul>
<li>函数分为类内函数和全局函数（const 放在 成员函数上，不放在全局函数上）</li>
<li>参数类型，仅可能的使用引用传递</li>
<li>考虑是否使用const 修饰入参</li>
<li>返回值尽可能使用引用返回</li>
<li>考虑返回值是否使用const</li>
</ul>
</li>
<li>
<p>static</p>
<ul>
<li>静态函数只能处理静态数据</li>
<li>static 数据只有一份：instance</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="面向对象"><a class="header" href="#面向对象">面向对象</a></h1>
<ul>
<li>复合 （内存 has a， Container / Component）
<ul>
<li>构造由内到外</li>
<li>析构由外到内</li>
</ul>
</li>
<li>委托（复合 by reference，Handle / Body）
<ul>
<li>共享，引用计数</li>
</ul>
</li>
<li>继承（is a，子类中有一部分父类的信息，继承数据，继承函数的调用权）
<ul>
<li>构造由内（父类）而外</li>
<li>析构由外而内</li>
<li>虚函数（virtual）
<ul>
<li>非虚函数：override 不希望子类重写</li>
<li>虚函数：希望子类override 重写，已经有默认实现</li>
<li>纯虚函数：子类必须override vitual func = 0;，没有默认实现</li>
<li>虚指针 &amp;&amp; 虚表（静态绑定-- call某个地址 ｜ 动态--绑定看调用方，多态）
<ul>
<li>一定是指针调用触发 虚链路（多态）</li>
<li>三个条件：指针，虚函数，向上转型</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="1-零散"><a class="header" href="#1-零散">1 零散</a></h1>
<h2 id="转换函数"><a class="header" href="#转换函数">转换函数</a></h2>
<h2 id="explict明白的明确的"><a class="header" href="#explict明白的明确的">explict（明白的，明确的）</a></h2>
<ul>
<li>non-explict-one-argument ctor</li>
</ul>
<h2 id="pointer-likeclass智能指针迭代器"><a class="header" href="#pointer-likeclass智能指针迭代器">Pointer-likeClass（智能指针，迭代器）</a></h2>
<h2 id="function-likeclass仿函数"><a class="header" href="#function-likeclass仿函数">Function-likeClass（仿函数）</a></h2>
<h2 id="类模板"><a class="header" href="#类模板">类模板</a></h2>
<ul>
<li>使用时指定类型</li>
</ul>
<h2 id="函数模板"><a class="header" href="#函数模板">函数模板</a></h2>
<h2 id="成员模板"><a class="header" href="#成员模板">成员模板</a></h2>
<h2 id="模板特化全偏特化-范围个数缩小"><a class="header" href="#模板特化全偏特化-范围个数缩小">模板特化（全/偏特化-范围｜个数缩小）</a></h2>
<h2 id="模板模板参数"><a class="header" href="#模板模板参数">模板模板参数</a></h2>
<h2 id="数量不定的模板参数typename-typessizeofargs"><a class="header" href="#数量不定的模板参数typename-typessizeofargs">数量不定的模板参数：typename... Types：sizeof...(args)</a></h2>
<h2 id="auto编译时推理"><a class="header" href="#auto编译时推理">auto（编译时推理）</a></h2>
<ul>
<li>声明时需要定义</li>
</ul>
<h2 id="objectmodel"><a class="header" href="#objectmodel">ObjectModel</a></h2>
<ul>
<li>虚指针（vptr）</li>
<li>虚表（vtbl）</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stl"><a class="header" href="#stl">STL</a></h1>
<p><a href="CPP/../resource/Slide.pdf">参考资料</a></p>
<p><a href="CPP/../resource/sample.cpp">源码</a></p>
<p><img src="CPP/../assets/STL.png" alt="截屏2022-06-22 20.23.54" /></p>
<h1 id="容器container"><a class="header" href="#容器container">容器（Container）</a></h1>
<p>前闭后开</p>
<h2 id="结构与分类"><a class="header" href="#结构与分类">结构与分类</a></h2>
<ul>
<li>序列容器
<ul>
<li>Array(固定空间)</li>
<li>Vector</li>
<li>Deque</li>
<li>List
<ul>
<li>Forward-List（单向链表）</li>
</ul>
</li>
</ul>
</li>
<li>关联容器（key:value）
<ul>
<li>Set/Multiset
<ul>
<li>Unordered Set/Multiset</li>
</ul>
</li>
<li>Map/Multimap
<ul>
<li>Unordered Map/Multimap</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="list"><a class="header" href="#list">List</a></h2>
<ul>
<li>双向链表</li>
<li>迭代器是class，</li>
</ul>
<h2 id="vector"><a class="header" href="#vector">Vector</a></h2>
<ul>
<li>2倍动态增长</li>
<li>不能原地扩充</li>
<li>迭代器是原始指针</li>
</ul>
<h2 id="deque"><a class="header" href="#deque">Deque</a></h2>
<ul>
<li>分段Buffer</li>
<li>双向扩充</li>
<li>begin</li>
<li>end</li>
<li>iterator
<ul>
<li>cur</li>
<li>first</li>
<li>end</li>
<li>node</li>
</ul>
</li>
</ul>
<h1 id="分配器allocators"><a class="header" href="#分配器allocators">分配器（Allocators）</a></h1>
<ul>
<li>VC6 的分配器没有特殊设计，调用的是 malloc和free</li>
<li>BC5 的分配器也没有特殊设计</li>
<li>GCC
<ul>
<li>&lt;stl_alloc.h&gt;</li>
</ul>
</li>
</ul>
<h1 id="算法algorithms"><a class="header" href="#算法algorithms">算法（Algorithms）</a></h1>
<ul>
<li>所有的算法，最终的行为无非就是比大小。</li>
<li>算法问迭代器问题</li>
</ul>
<h2 id="1-算法是一个函数模板"><a class="header" href="#1-算法是一个函数模板">1. 算法是一个函数模板</a></h2>
<pre><code>- 从语言层次来讲，算法是一个函数模板
- 其余部件都是一个类模板
</code></pre>
<h2 id="2-处理迭代器"><a class="header" href="#2-处理迭代器">2. 处理迭代器</a></h2>
<h2 id="3-实例"><a class="header" href="#3-实例">3. 实例</a></h2>
<ul>
<li>accumulate（累计）</li>
<li>for_each</li>
<li>replace
<ul>
<li>replace_if</li>
<li>replace_copy</li>
</ul>
</li>
<li>count
<ul>
<li>count_if</li>
</ul>
</li>
<li>find
<ul>
<li>find_if</li>
</ul>
</li>
<li>sort</li>
<li>binary_search</li>
</ul>
<h1 id="迭代器iterators"><a class="header" href="#迭代器iterators">迭代器（Iterators）</a></h1>
<p><img src="CPP/../assets/%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E5%9E%8B.png" alt="截屏2022-06-22 12.52.02" /></p>
<h2 id="1-五种相关类型"><a class="header" href="#1-五种相关类型">1. 五种相关类型</a></h2>
<ul>
<li>iterator_category （分类）</li>
<li>distance（两个iterator之间的距离的类型）</li>
<li>value_type（数据类型）</li>
<li>reference</li>
<li>pointer</li>
</ul>
<h2 id="2-traits中间层"><a class="header" href="#2-traits中间层">2. traits（中间层）</a></h2>
<ul>
<li>用于封装原生指针，用以实现上述五种类型的数据。</li>
</ul>
<h2 id="3-接口"><a class="header" href="#3-接口">3. 接口</a></h2>
<div class="table-wrapper"><table><thead><tr><th>名称</th><th>初始化</th><th>前</th><th>后</th><th>首元素</th><th>尾元素</th><th>随机</th><th>随机查询</th><th>大小</th><th>容积</th><th>反转</th><th>重设大小</th></tr></thead><tbody>
<tr><td><a href="https://en.cppreference.com/w/cpp/header/array">array</a></td><td></td><td></td><td>[push|pop]_back</td><td>front</td><td>back</td><td>[]/insert/erase</td><td>[].data</td><td>size</td><td>capacity</td><td></td><td></td></tr>
<tr><td>vector</td><td>vector<int>v1</td><td></td><td>[push|pop]_back</td><td></td><td></td><td></td><td></td><td></td><td></td><td>reserve</td><td></td></tr>
<tr><td>stack</td><td></td><td>pop</td><td>push</td><td>top</td><td></td><td></td><td></td><td>size</td><td></td><td></td><td></td></tr>
<tr><td><a href="https://zh.cppreference.com/w/cpp/container/deque">queue</a></td><td></td><td>push</td><td>pop</td><td>front</td><td>back</td><td></td><td></td><td>Size</td><td></td><td></td><td></td></tr>
<tr><td>deque</td><td></td><td>[push|pop]_front</td><td>[push|pop]_back</td><td>front</td><td>back</td><td>insert/erase</td><td></td><td>size</td><td></td><td></td><td>resize</td></tr>
<tr><td>Forward-list</td><td></td><td>[push|pop]_front</td><td></td><td>front</td><td>back</td><td>insert/erase</td><td></td><td></td><td></td><td></td><td>resize</td></tr>
<tr><td>list</td><td></td><td>[push|pop]_front</td><td>[push|pop]_back</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>set/mutiset</td><td></td><td></td><td></td><td></td><td></td><td>insert/erase</td><td></td><td>Size</td><td></td><td></td><td></td></tr>
<tr><td>map/multimap</td><td></td><td></td><td></td><td></td><td></td><td>insert/erase</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>string</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>tuple</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div>
<h1 id="适配器adapters"><a class="header" href="#适配器adapters">适配器（Adapters）</a></h1>
<ul>
<li>容器的适配器
<ul>
<li>stack</li>
<li>queue</li>
</ul>
</li>
<li>函数适配器
<ul>
<li>bind2nd
<ul>
<li>binder2nd</li>
</ul>
</li>
<li>nto1（取反）</li>
</ul>
</li>
<li>新形式的适配器
<ul>
<li>bind</li>
</ul>
</li>
</ul>
<h1 id="仿函数functors"><a class="header" href="#仿函数functors">仿函数（Functors）</a></h1>
<ul>
<li>STL 的仿函数必须public继承binary_function或者unary_function之后才能被适配器适配</li>
</ul>
<h2 id="1-算术类-"><a class="header" href="#1-算术类-">1. 算术类（+/-）</a></h2>
<h2 id="2-逻辑运算类-"><a class="header" href="#2-逻辑运算类-">2. 逻辑运算类（&amp;&amp; ||）</a></h2>
<h2 id="3-相对关系类---"><a class="header" href="#3-相对关系类---">3. 相对关系类( &lt; | &gt;=)</a></h2>
<h2 id="4-binary_function两个操作数"><a class="header" href="#4-binary_function两个操作数">4. binary_function:（两个操作数）</a></h2>
<h2 id="5-unary_function一个操作数"><a class="header" href="#5-unary_function一个操作数">5. unary_function（一个操作数）</a></h2>
<h1 id="标准库其他"><a class="header" href="#标准库其他">标准库其他</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="thread"><a class="header" href="#thread">Thread</a></h1>
<h1 id="一主要函数"><a class="header" href="#一主要函数">一、主要函数</a></h1>
<pre><code class="language-C"> #include &lt;pthread.h&gt;

int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg)
int pthread_join(pthread_t thread, void **value_ptr)
 # ps -Lf pid 
int pthread_cancel(pthread_t thread)
int pthread_detach(pthread_t thread)
void pthread_exit(void *value_ptr)
int pthread_kill(pthread_t thread, int sig)
int pthread_once(pthread_once_t *once_control, void (*init_routine)(void))
pthread_t pthread_self(void)
pthread_equal(tid1, tid2)
</code></pre>
<h1 id="二具体功能"><a class="header" href="#二具体功能">二、具体功能</a></h1>
<h2 id="21-线程的创建"><a class="header" href="#21-线程的创建">2.1 线程的创建</a></h2>
<h2 id="22-线程的中止"><a class="header" href="#22-线程的中止">2.2 线程的中止</a></h2>
<h3 id="221-异常终止"><a class="header" href="#221-异常终止">2.2.1 异常终止</a></h3>
<ul>
<li>主线程退出，子线程被强行终止</li>
<li>子线程中调用 exit()，则整个<strong>进程</strong>全部退出</li>
<li>缺省行为是终止程序的信号，会终止整个<strong>进程</strong></li>
</ul>
<h3 id="222-正常终止"><a class="header" href="#222-正常终止">2.2.2 正常终止</a></h3>
<ul>
<li>线程使用 return 返回，return 0 无需转换，return (void*) 1; 返回值是线程的结束码。</li>
<li>线程可以被同一进程的其他线程调用 pthread_cancel() 结束。</li>
<li>在线程中调用 pthread_exit((void*)1) 退出</li>
</ul>
<h2 id="23-线程的参数传递"><a class="header" href="#23-线程的参数传递">2.3 线程的参数传递</a></h2>
<ul>
<li>线程创建顺序和线程运行顺序并不保证一致。</li>
<li>全局变量不能代替线程的参数传递</li>
<li>参数需要类型类型强制转换</li>
<li>传递整型参数
<ul>
<li>pthread_create(&amp;pid, NULL, func, (void*)(long) number))</li>
<li>printf(&quot;%d&quot;, (int)(long)arg)</li>
</ul>
</li>
<li>传递地址参数(需要给每个线程传递一个单独的地址，不能使用同一个地址：全局变量)
<ul>
<li>int* var1 = new int; *var = 1;</li>
<li>pthread_create(&amp;pid, NULL, func, var1))</li>
<li>printf(&quot;%xx&quot;, *(int*)arg)</li>
<li>var1 需要在线程中释放内存。 delete  (int*)arg;</li>
</ul>
</li>
<li>线程退出状态
<ul>
<li>void* pv = 0;</li>
<li>pthread_join(pid, &amp;pv);</li>
<li>pv 保存线程 返回的值。</li>
</ul>
</li>
</ul>
<h2 id="24-线程资源的回收"><a class="header" href="#24-线程资源的回收">2.4 线程资源的回收</a></h2>
<ul>
<li>线程分离
<ul>
<li>joinable(默认状态)，在线程结束时，之后不会释放全部的资源，而是等待join，join之后资源才会释放（因此只能join一次）
<ul>
<li>pthread_join()</li>
<li>pthread_tryjoin_np()</li>
<li>pthread_timedjoin_np()</li>
</ul>
</li>
<li>unjoinable（不可分离）
<ul>
<li>pthread_detach(tid);
<ul>
<li>可以放在线程函数中 pthread_detach(pthread_self());</li>
</ul>
</li>
<li>创建线程前，调用pthread_attr_setdetachstat()设置线程属性。</li>
</ul>
</li>
</ul>
</li>
<li>线程清理函数释放资源
<ul>
<li>pthread_cleanup_push(func)</li>
<li>pthread_cleanup_pop(1)
<ul>
<li>填 0 标识 只退出不执行清理函数</li>
<li>非 0 则会退出并执行清理函数</li>
</ul>
</li>
<li>可以有多个线程清理函数，但必须push和pop成对在<strong>同一语句块</strong>中出现</li>
<li>在线程退出时 会调用线程清理函数。
<ul>
<li>pthread_exit()</li>
<li>return</li>
<li>Pthread_cancel()</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="25-线程取消"><a class="header" href="#25-线程取消">2.5 线程取消</a></h2>
<ul>
<li>可以被join</li>
<li>返回值 为 PTHREAD_CANCELED ，即 -1</li>
<li>pthread_setcancelstate() 设置线程的取消状态
<ul>
<li>只能放在线程的主函数中</li>
<li>可以被取消</li>
<li>不可以被取消</li>
</ul>
</li>
<li>pthread_setcacheltype() 设置线程的取消类型
<ul>
<li>立即取消</li>
<li>执行到 取消点是进行取消（默认）
<ul>
<li>accept()</li>
<li>close()</li>
<li>pthread_testcancel()； 设置取消点</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="26-线程与信号"><a class="header" href="#26-线程与信号">2.6 线程与信号</a></h2>
<ul>
<li>在多线程程序中，外部向进程发送信号不会中断系统调用</li>
<li>在多线程程序中，信号的处理是所有线程共享的</li>
<li>进程中的信号可以送达单个线程，会中断系统调用
<ul>
<li>pthread_kill(tid, sig)</li>
</ul>
</li>
<li>如果某个线程因为信号被终止，则整个进程都会被终止</li>
</ul>
<h2 id="27-线程安全"><a class="header" href="#27-线程安全">2.7 线程安全</a></h2>
<ul>
<li>原子性，可见行，顺序性
<ul>
<li>volatile
<ul>
<li>不从缓存中读取数据，而是从内存中读取</li>
<li>禁止代码重排序</li>
<li>不是原子的</li>
</ul>
</li>
</ul>
</li>
<li>原子操作
<ul>
<li>原子操作函数</li>
<li>CAS执行</li>
<li>原子类型 std::atomic&lt;int&gt; var;</li>
</ul>
</li>
<li>线程同步锁</li>
</ul>
<h2 id="28-线程同步"><a class="header" href="#28-线程同步">2.8 线程同步</a></h2>
<h3 id="281-互斥锁"><a class="header" href="#281-互斥锁">2.8.1 互斥锁</a></h3>
<ul>
<li>加锁解锁，其他等待</li>
<li>mutex</li>
</ul>
<h3 id="282-自旋锁"><a class="header" href="#282-自旋锁">2.8.2 自旋锁</a></h3>
<ul>
<li>加锁解锁，其他不等待</li>
<li>spin</li>
<li>共享标志</li>
</ul>
<h3 id="283-读写锁"><a class="header" href="#283-读写锁">2.8.3 读写锁</a></h3>
<ul>
<li>读模式加锁（可以多个持有读锁）</li>
<li>写模式加锁（只有不加锁的时候才能申请写锁，只能有一个持有写锁）</li>
<li>不加锁</li>
<li>rw</li>
</ul>
<h3 id="284-条件变量专为生产消费者设计"><a class="header" href="#284-条件变量专为生产消费者设计">2.8.4 条件变量（专为生产消费者设计）</a></h3>
<ul>
<li>
<p>与互斥锁一起使用</p>
</li>
<li>
<p>pthread_cond_wait() 等待被唤醒</p>
<ul>
<li>把互斥锁解锁</li>
<li>阻塞，等待信号唤醒</li>
<li>条件被触发+互斥锁加锁 （原子操作）</li>
</ul>
<pre><code class="language-c">pthread_cond_timedwait();  // 等待被唤醒，带超时机制
pthread_cond_signal();  // 唤醒一个等待中的线程
pthread_cond_broadcast(); // 唤醒全部等待中的线程
</code></pre>
</li>
</ul>
<h3 id="285-匿名信号量"><a class="header" href="#285-匿名信号量">2.8.5 （匿名）信号量</a></h3>
<ul>
<li>
<p>一个整数计数器，数值表示空闲的临界资源的数量</p>
</li>
<li>
<p>申请资源时，信号量减少</p>
</li>
<li>
<p>释放资源后，信号量增加</p>
<pre><code class="language-C">sem_t sem;
int sem_init();
int sem_destroy();
int sem_wait(sem_t* sem); //P操作
int sem_trywait(sem_t* sem); // P操作，不阻塞
int sem_timedwait(sem_t* sem); // P操作，超时
int sem_post(sem_t* sem); //V操作
int sem_getvalue(); // 获取信号想的值
</code></pre>
</li>
</ul>
<h3 id="286-生产消费者模型"><a class="header" href="#286-生产消费者模型">2.8.6 生产消费者模型</a></h3>
<ul>
<li>基本概念</li>
<li>互斥锁 + 条件变量实现生产消费者模型
<ul>
<li>在线程清理函数中需要释放 互斥锁</li>
</ul>
</li>
<li>信号量 实现生产消费者模型
<ul>
<li>需要手动加锁解锁（或者使用信号量代替互斥锁）</li>
</ul>
</li>
</ul>
<h3 id="287-多线程程序"><a class="header" href="#287-多线程程序">2.8.7 多线程程序</a></h3>
<ul>
<li>全局变量的线程安全</li>
<li>是否有不可重入函数</li>
</ul>
<p><img src="CPP/../assets/%E5%AE%89%E5%85%A8%E5%87%BD%E6%95%B0.png" alt="安全函数" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tcp_socket"><a class="header" href="#tcp_socket">TCP_Socket</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c11语言"><a class="header" href="#c11语言">C++11语言</a></h1>
<h2 id="0-关键字"><a class="header" href="#0-关键字">0. 关键字</a></h2>
<p><img src="CPP/../assets/C11%E5%85%B3%E9%94%AE%E5%AD%97.png" alt="截屏2022-06-30 22.15.35" /></p>
<h3 id="01-explcit"><a class="header" href="#01-explcit">0.1 explcit</a></h3>
<h3 id="02-noexcept"><a class="header" href="#02-noexcept">0.2 noexcept</a></h3>
<h3 id="03-const"><a class="header" href="#03-const">0.3 const...</a></h3>
<h3 id="04-const"><a class="header" href="#04-const">0.4 const</a></h3>
<h3 id="05-static"><a class="header" href="#05-static">0.5 static</a></h3>
<h3 id="06-typeplate"><a class="header" href="#06-typeplate">0.6 typeplate</a></h3>
<h3 id="07-tpyename"><a class="header" href="#07-tpyename">0.7 tpyename</a></h3>
<h3 id="08-class"><a class="header" href="#08-class">0.8 class</a></h3>
<h3 id="09-decltype"><a class="header" href="#09-decltype">0.9 decltype</a></h3>
<h3 id="010-auto"><a class="header" href="#010-auto">0.10 auto</a></h3>
<h3 id="011-public"><a class="header" href="#011-public">0.11 public</a></h3>
<h3 id="012-private"><a class="header" href="#012-private">0.12 private</a></h3>
<h3 id="013-proteced"><a class="header" href="#013-proteced">0.13 proteced</a></h3>
<h3 id="014-virtual"><a class="header" href="#014-virtual">0.14 virtual</a></h3>
<h2 id="015"><a class="header" href="#015">0.15</a></h2>
<h2 id="1-lambda"><a class="header" href="#1-lambda">1. lambda</a></h2>
<ul>
<li>格式
<ul>
<li>[=, &amp;](int x, char y) mutable~opt~ throwSpec~opt~ -&gt;retType~opt~ {...}</li>
</ul>
</li>
</ul>
<h2 id="2-variadic-templates"><a class="header" href="#2-variadic-templates">2. Variadic Templates</a></h2>
<ul>
<li>参数类型变化</li>
<li>参数个数变化</li>
<li>函数</li>
<li>class</li>
<li>模版</li>
</ul>
<pre><code class="language-c++">// 不可省略，作为递归的出口
void func()
{
  
}
template &lt;typename T, typename... Types&gt;
void func(const T&amp; firstArg, const Types&amp;... args) // ... 是类型的参数一部分
{
  处理 firstArg;
  // sizeof...(args); 用于得到args参数的个数
	func(args...);
}
//////////////////////////////////////////////////////////////////////////////
template &lt;typename... Args&gt;
ostream&amp; operator&lt;&lt; (ostream&amp; os, const tuple&lt;Args...&gt;&amp; t) {
  os &lt;&lt; &quot;[&quot; &lt;&lt; PRINT_TUPLE&lt;0, sizeof...(Args), Args...&gt;::print(os, t);
  return os &lt;&lt; &quot;]&quot;;
}
template &lt;int IDX, int MAX, typename... Args&gt;
struct PRINT_TUPLE {
  static void print(ostream&amp; os, const tuple&lt;Args...&gt;&amp; t) {
    os &lt;&lt; get&lt;IDX&gt;(t) &lt;&lt; (IDX + 1 == MAX) ? &quot;&quot; : &quot;,&quot;;
    PRINT_TUPLE&lt;IDX+1, MAX, Args...&gt;::print(os, t);
  }
}
template &lt;int MAX, typename... Args&gt;
struct PRINT_TYPLE&lt;MAX, MAX, Args...&gt; {
 static void print(ostream&amp; os, const tuple&lt;Args...&gt;&amp; t) {
 }
}

// cout &lt;&lt; make_tuple(7.5, string(&quot;hello&quot;), 32, 42)
// [7.5,hello,32,42]

/////////////////////////////////////////////////////////////////////////////
// 递归的继承
</code></pre>
<p><img src="CPP/../assets/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF.png" alt="截屏2022-06-30 21.56.25" /></p>
<p><img src="CPP/../assets/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF2.png" alt="截屏2022-06-30 22.04.50" /></p>
<p><img src="CPP/../assets/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF3.png" alt="截屏2022-06-30 22.07.23" /></p>
<p><img src="CPP/../assets/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF4.png" alt="截屏2022-06-30 22.13.34" /></p>
<h2 id="3-initializer_lists"><a class="header" href="#3-initializer_lists">3. initializer_lists</a></h2>
<h1 id="c11标准库"><a class="header" href="#c11标准库">c++11标准库</a></h1>
<h2 id="右值引用move"><a class="header" href="#右值引用move">右值引用｜Move</a></h2>
<ul>
<li>右值通常是临时对象，不能出现在等号左边</li>
<li>拷贝指针（必须有指针）</li>
<li>使用 std::move(left_value) 来将左值引用当作右值引用，来使用move语义</li>
</ul>
<pre><code class="language-c++">M c1(c);
M c2(std::move(c1)); // 必须确保后续不在使用c1
cl.swap(c2);

// move ctor
MyString（MyString	&amp;&amp; str） noexcept: initization list {}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="effective-moderc-c"><a class="header" href="#effective-moderc-c">Effective Moderc C++</a></h1>
<h1 id="零"><a class="header" href="#零">零</a></h1>
<h2 id="类型名称值址权限"><a class="header" href="#类型名称值址权限">类型，名称，值，址，权限</a></h2>
<p>int a = 10;</p>
<p>const char* val; </p>
<p>char* const val;</p>
<h1 id="一类型推导"><a class="header" href="#一类型推导">一、类型推导</a></h1>
<h2 id="11-理解模版类型推导"><a class="header" href="#11-理解模版类型推导">1.1 理解模版类型推导</a></h2>
<pre><code class="language-c++">template&lt;typename T&gt;
void f(ParamType param);
f(expr)
</code></pre>
<h3 id="111-paramtype-是指针或者引用但不是万能引用万能引用对左值和右值的处理方式不一样"><a class="header" href="#111-paramtype-是指针或者引用但不是万能引用万能引用对左值和右值的处理方式不一样">1.1.1 ParamType 是指针或者引用，但不是万能引用（万能引用对左值和右值的处理方式不一样）</a></h3>
<ul>
<li>忽略<em>expt</em>的引用类型</li>
<li>对<em>expr</em>的类型和<em>ParamType</em> 进行模式匹配，确定<em>T</em>的类型</li>
</ul>
<pre><code class="language-c++">template&lt;typename T&gt;
void f(T&amp; param); // param是个引用

int X = 27;  // x的型别是int
const int cx = x;  // cx 的型别是 const int
const int&amp; rx = x; // rx 是 x 的型别为 const int 的引用

f(x); // T 的型别是 int. param 的型别是 int&amp;
f(cx); // T 的型别是 const int, param 的型别是 const int&amp; 
f(rx); // T 的和别是 const int, param 的和别是 const int&amp;
</code></pre>
<h3 id="112-paramtype-是个万能引用"><a class="header" href="#112-paramtype-是个万能引用">1.1.2 ParamType 是个万能引用</a></h3>
<ul>
<li>如果 <em>expr</em> 是个左值，<em>T</em>和<em>ParamType</em>都会被推导为左值引用
<ul>
<li>首先，这是在模板型别推导中， T 被推导为引用型别的唯一情形。 </li>
<li>其次，尽管在声明时使用的是右值引用语法，它的型别推导结果却是左值引用。</li>
</ul>
</li>
<li>如果 <em>expr</em> 是个右值，则使用 1.1.1 的规则</li>
</ul>
<pre><code class="language-c++">template&lt;typename T&gt; 
void f(T&amp;&amp; param); // param现在是个万能引用

int X = 27;
const int ex = x;
const int&amp; rx = x;

f(x);  // X 是个左值，所以 T 的型别是 int&amp;, param 的 型别也是 int&amp;
f(cx); // cx 是个左值，所以 T 的型别是 const int&amp;, param 的型别也是 const int&amp;
f(rx); // rx 是个左值，所以 T 的型别是 const int&amp;, param 的型别也是 const int&amp;
f(27); //27 是个右值，所以 T 的型别是 int, 这么 一来, param的型别就成 int&amp;&amp;
</code></pre>
<h3 id="113-paramtype既不是指针或者引用也不是万能指针"><a class="header" href="#113-paramtype既不是指针或者引用也不是万能指针">1.1.3 ParamType既不是指针或者引用，也不是万能指针</a></h3>
<ul>
<li>若 expr具有引用型别，则忽略其引用部分。</li>
<li>忽略 expr 的引用性之后，若 expr 是个 const 对象，也忽略之。若其是个 volatile 对象，同忽略之</li>
</ul>
<pre><code class="language-c++">template&lt;typename T&gt;
void f(T param); // param现在是按值传递

intX =27;
const int cx = x; 
const int&amp; rx = x;

f(x); // T 和 param 的节别都是 int
f(cx); //T 和 param 的型别还都是 int
f(rx); //T 和 param 的型别仍都是 int
/*
请注意，即使 cx 和 rx 代表 const 值， param 仍然不具有 const 型别。这是合理的 。 
param 是个完全独立千 cx 和 rx 存在的对象 cx 和 rx 的 一 个副本。
从而 cx 和 rx 不可修改这一事实并不能说明 param是否可以修改。
正是由于这一原因， expr 的常址 性以及挥发性 (volatileness, 若有)可以在推导 param 的型别时加以忽略:
仅仅由千 expr 不可修改，并不能断定其副本也不可修改。
*/
</code></pre>
<h2 id="11-auto"><a class="header" href="#11-auto">1.1 auto</a></h2>
<h2 id="12-decltype"><a class="header" href="#12-decltype">1.2 decltype</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="程序员笔记"><a class="header" href="#程序员笔记">程序员笔记</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pkg-config"><a class="header" href="#pkg-config">PKG-CONFIG</a></h1>
<h2 id="地址"><a class="header" href="#地址"><a href="https://www.freedesktop.org/wiki/Software/pkg-config/">地址</a></a></h2>
<h2 id="一般用法"><a class="header" href="#一般用法">一般用法</a></h2>
<pre><code class="language-shell"> gcc -o test test.c `pkg-config --libs --cflags glib-2.0`
</code></pre>
<h2 id="环境变量"><a class="header" href="#环境变量">环境变量</a></h2>
<pre><code class="language-shell">export PKG_CONGIG_PATH=$PKG_CONFIG_PATH
</code></pre>
<h2 id="常用参数"><a class="header" href="#常用参数">常用参数</a></h2>
<pre><code>--cflags # -I/usr/include/***

--libs # -L/usr/lib/***

--list-all # 查看所有模块信息

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="流媒体笔记"><a class="header" href="#流媒体笔记">流媒体笔记</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ffmpeg-命令行学习"><a class="header" href="#ffmpeg-命令行学习">FFMPEG 命令行学习</a></h1>
<h1 id="命令分类"><a class="header" href="#命令分类"><a href="http://ffmpeg.org/ffmpeg.html">命令分类</a></a></h1>
<h2 id="0-基本格式"><a class="header" href="#0-基本格式">0. 基本格式</a></h2>
<pre><code class="language-shell">ffmpeg [global_options] {[input_file_options] -i input_url} ... {[output_file_options] output_url} ...
</code></pre>
<h2 id="input_url--i"><a class="header" href="#input_url--i">Input_url (-i)</a></h2>
<ul>
<li>regular files</li>
<li>pipes</li>
<li>network streams</li>
<li>grabbing devices</li>
<li>Based 0 numbers</li>
<li>...</li>
</ul>
<h2 id="input-or-output-data-types"><a class="header" href="#input-or-output-data-types">Input or output data types</a></h2>
<ul>
<li>video</li>
<li>audios</li>
<li>subtitles</li>
<li>attachment</li>
<li>data</li>
</ul>
<h2 id="stream"><a class="header" href="#stream">Stream</a></h2>
<h3 id="selection"><a class="header" href="#selection">selection</a></h3>
<ul>
<li>-map (attachment streams can only use map)</li>
<li>-vn</li>
<li>-an</li>
<li>-sn</li>
<li>-dn</li>
</ul>
<h3 id="handling"><a class="header" href="#handling">handling</a></h3>
<ul>
<li>-codec</li>
</ul>
<h3 id="example"><a class="header" href="#example">example</a></h3>
<pre><code>input file 'A.avi'
      stream 0: video 640x360
      stream 1: audio 2 channels

input file 'B.mp4'
      stream 0: video 1920x1080
      stream 1: audio 2 channels
      stream 2: subtitles (text)
      stream 3: audio 5.1 channels
      stream 4: subtitles (text)

input file 'C.mkv'
      stream 0: video 1280x720
      stream 1: audio 2 channels
      stream 2: subtitles (image)
      
ffmpeg -i A.avi -i B.mp4 out1.mkv out2.wav -map 1:a -c:a copy out3.mov
MKV: a/v/s from B-0/B-3/B-2
WAV: a B-3
out3.mov/MAP: B-Audio
</code></pre>
<pre><code>ffmpeg -i C.mkv out1.mkv -c:s dvdsub -an out2.mkv
</code></pre>
<pre><code>ffmpeg -i A.avi -i C.mkv -i B.mp4 -filter_complex &quot;overlay&quot; out1.mp4 out2.srt
</code></pre>
<pre><code>ffmpeg -i A.avi -i B.mp4 -i C.mkv -filter_complex &quot;[1:v]hue=s=0[outv];overlay;aresample&quot; \
       -map '[outv]' -an        out1.mp4 \
                                out2.mkv \
       -map '[outv]' -map 1:a:0 out3.mkv
fail
</code></pre>
<pre><code>ffmpeg -i A.avi -i B.mp4 -i C.mkv -filter_complex &quot;[1:v]hue=s=0[outv];overlay;aresample&quot; \
       -an        out1.mp4 \
                  out2.mkv \
       -map 1:a:0 out3.mkv
       
fail
</code></pre>
<pre><code>ffmpeg -i A.avi -i B.mp4 -i C.mkv -filter_complex &quot;[1:v]hue=s=0,split=2[outv1][outv2];overlay;aresample&quot; \
        -map '[outv1]' -an        out1.mp4 \
                                  out2.mkv \
        -map '[outv2]' -map 1:a:0 out3.mkv
success
</code></pre>
<h2 id="基本流程"><a class="header" href="#基本流程">基本流程</a></h2>
<pre><code> _______              ______________
|       |            |              |
| input |  demuxer   | encoded data |   decoder
| file  | ---------&gt; | packets      | -----+
|_______|            |______________|      |
                                           v
                                       _________
                                      |         |
                                      | decoded |
                                      | frames  |
                                      |_________|
 ________             ______________       |
|        |           |              |      |
| output | &lt;-------- | encoded data | &lt;----+
| file   |   muxer   | packets      |   encoder
|________|           |______________|


</code></pre>
<h2 id="filtering-vf-or--af"><a class="header" href="#filtering-vf-or--af">Filtering（-vf or -af）</a></h2>
<h3 id="simple-filtergraphs"><a class="header" href="#simple-filtergraphs">simple filtergraphs</a></h3>
<pre><code> _________                        ______________
|         |                      |              |
| decoded |                      | encoded data |
| frames  |\                   _ | packets      |
|_________| \                  /||______________|
             \   __________   /
  simple     _\||          | /  encoder
  filtergraph   | filtered |/
                | frames   |
                |__________|

</code></pre>
<h3 id="filter-for-video"><a class="header" href="#filter-for-video">filter for video</a></h3>
<pre><code> _______        _____________        _______        ________
|       |      |             |      |       |      |        |
| input | ---&gt; | deinterlace | ---&gt; | scale | ---&gt; | output |
|_______|      |_____________|      |_______|      |________|

</code></pre>
<h2 id="complex-filter-graphs"><a class="header" href="#complex-filter-graphs">Complex filter graphs</a></h2>
<pre><code> _________
|         |
| input 0 |\                    __________
|_________| \                  |          |
             \   _________    /| output 0 |
              \ |         |  / |__________|
 _________     \| complex | /
|         |     |         |/
| input 1 |----&gt;| filter  |\
|_________|     |         | \   __________
               /| graph   |  \ |          |
              / |         |   \| output 1 |
 _________   /  |_________|    |__________|
|         | /
| input 2 |/
|_________|

</code></pre>
<h2 id="stream-copy"><a class="header" href="#stream-copy">Stream Copy</a></h2>
<pre><code> _______              ______________            ________
|       |            |              |          |        |
| input |  demuxer   | encoded data |  muxer   | output |
| file  | ---------&gt; | packets      | -------&gt; | file   |
|_______|            |______________|          |________|

</code></pre>
<h2 id="1-通用查询参数"><a class="header" href="#1-通用查询参数">1. 通用查询参数</a></h2>
<ul>
<li>-formats</li>
</ul>
<p>​	Show available formats (including devices).</p>
<ul>
<li>-demuxers</li>
</ul>
<p>​	Show available demuxers.</p>
<ul>
<li>-muxers</li>
</ul>
<p>​	Show available muxers.</p>
<ul>
<li>-devices</li>
</ul>
<p>​	Show available devices.</p>
<ul>
<li>-codecs</li>
</ul>
<p>​	Show all codecs known to libavcodec.</p>
<ul>
<li>-decoders</li>
</ul>
<p>​	Show available decoders.</p>
<ul>
<li>-encoders</li>
</ul>
<p>​	Show all available encoders.</p>
<ul>
<li>-bsfs</li>
</ul>
<p>​	Show available bitstream filters.</p>
<ul>
<li>-protocols</li>
</ul>
<p>​	Show available protocols.</p>
<ul>
<li>-filters</li>
</ul>
<p>​	Show available libavfilter filters.</p>
<ul>
<li>-pix_fmts</li>
</ul>
<p>​	Show available pixel formats.</p>
<ul>
<li>-sample_fmts</li>
</ul>
<p>​	Show available sample formats.</p>
<ul>
<li>-layouts</li>
</ul>
<p>​	Show channel names and standard channel layouts.</p>
<h2 id="2-av参数"><a class="header" href="#2-av参数">2. AV参数</a></h2>
<ul>
<li>
<p>-f fmt (<em>input/output</em>)</p>
<p>Force input or output file format. The format is normally auto detected for input files and guessed from the file extension for output files, so this option is not needed in most cases.</p>
</li>
<li>
<p>-i url (<em>input</em>)</p>
<p>input file url</p>
</li>
<li>
<p>-c[:stream_specifier] codec (<em>input/output,per-stream</em>)</p>
<p>-codec[:stream_specifier] codec (<em>input/output,per-stream</em>)</p>
<p>Select an encoder (when used before an output file) or a decoder (when used before an input file) for one or more streams. codec is the name of a decoder/encoder or a special value <code>copy</code> (output only) to indicate that the stream is not to be re-encoded.</p>
</li>
<li>
<p>-t duration (<em>input/output</em>)</p>
<p>When used as an input option (before <code>-i</code>), limit the duration of data read from the input file.</p>
<p>When used as an output option (before an output url), stop writing the output after its duration reaches duration.</p>
<p>duration must be a time duration specification, see <a href="http://ffmpeg.org/ffmpeg-utils.html#time-duration-syntax">(ffmpeg-utils)the Time duration section in the ffmpeg-utils(1) manual</a>.</p>
<p>-to and -t are mutually exclusive and -t has priority.</p>
</li>
<li>
<p>-to position (<em>input/output</em>)</p>
<p>Stop writing the output or reading the input at position. position must be a time duration specification, see <a href="http://ffmpeg.org/ffmpeg-utils.html#time-duration-syntax">(ffmpeg-utils)the Time duration section in the ffmpeg-utils(1) manual</a>.</p>
<p>-to and -t are mutually exclusive and -t has priority.</p>
</li>
<li>
<p>-ss position (<em>input/output</em>)</p>
<p>When used as an input option (before <code>-i</code>), seeks in this input file to position. Note that in most formats it is not possible to seek exactly, so <code>ffmpeg</code> will seek to the closest seek point before position. When transcoding and -accurate_seek is enabled (the default), this extra segment between the seek point and position will be decoded and discarded. When doing stream copy or when -noaccurate_seek is used, it will be preserved.</p>
<p>When used as an output option (before an output url), decodes but discards input until the timestamps reach position.</p>
</li>
<li>
<p>-filter[:stream_specifier] filtergraph (<em>output,per-stream</em>)</p>
<p>Create the filtergraph specified by filtergraph and use it to filter the stream.</p>
<p>filtergraph is a description of the filtergraph to apply to the stream, and must have a single input and a single output of the same type of the stream. In the filtergraph, the input is associated to the label <code>in</code>, and the output to the label <code>out</code>. See the ffmpeg-filters manual for more information about the filtergraph syntax.</p>
<p>See the <a href="http://ffmpeg.org/ffmpeg.html#filter_005fcomplex_005foption">-filter_complex option</a> if you want to create filtergraphs with multiple inputs and/or outputs.</p>
</li>
<li>
<p>ffmpeg -f avfoundation -list_devices true -i &quot;&quot;</p>
</li>
</ul>
<h2 id="3-video参数"><a class="header" href="#3-video参数">3. Video参数</a></h2>
<ul>
<li>
<p>-r[:stream_specifier] fps (<em>input/output,per-stream</em>)</p>
<p>Set frame rate (Hz value, fraction or abbreviation).</p>
<p>As an input option, ignore any timestamps stored in the file and instead generate timestamps assuming constant frame rate fps. This is not the same as the -framerate option used for some input formats like image2 or v4l2 (it used to be the same in older versions of FFmpeg). If in doubt use -framerate instead of the input option -r.</p>
<p>As an output option, duplicate or drop input frames to achieve constant output frame rate fps.</p>
</li>
<li>
<p>-fpsmax[:stream_specifier] fps (<em>output,per-stream</em>)</p>
<p>Set maximum frame rate (Hz value, fraction or abbreviation).</p>
<p>Clamps output frame rate when output framerate is auto-set and is higher than this value. Useful in batch processing or when input framerate is wrongly detected as very high. It cannot be set together with <code>-r</code>. It is ignored during streamcopy.</p>
</li>
<li>
<p>-s[:stream_specifier] size (<em>input/output,per-stream</em>)</p>
<p>Set frame size.</p>
<p>As an input option, this is a shortcut for the video_size private option, recognized by some demuxers for which the frame size is either not stored in the file or is configurable – e.g. raw video or video grabbers.</p>
<p>As an output option, this inserts the <code>scale</code> video filter to the <em>end</em> of the corresponding filtergraph. Please use the <code>scale</code> filter directly to insert it at the beginning or some other place.</p>
<p>The format is ‘wxh’ (default - same as source).</p>
</li>
<li>
<p>-vn (<em>input/output</em>)</p>
<p>As an input option, blocks all video streams of a file from being filtered or being automatically selected or mapped for any output. See <code>-discard</code> option to disable streams individually.</p>
<p>As an output option, disables video recording i.e. automatic selection or mapping of any video stream. For full manual control see the <code>-map</code> option.</p>
</li>
<li>
<p>-vcodec codec (<em>output</em>)</p>
<p>Set the video codec. This is an alias for <code>-codec:v</code>.</p>
</li>
<li>
<p>-vf filtergraph (<em>output</em>)</p>
<p>Create the filtergraph specified by filtergraph and use it to filter the stream.</p>
<p>This is an alias for <code>-filter:v</code>, see the <a href="http://ffmpeg.org/ffmpeg.html#filter_005foption">-filter option</a>.</p>
</li>
<li>
<p>-pix_fmt[:stream_specifier] format (<em>input/output,per-stream</em>)</p>
<p>-pixel_format</p>
<p>Set pixel format. Use <code>-pix_fmts</code> to show all the supported pixel formats. If the selected pixel format can not be selected, ffmpeg will print a warning and select the best pixel format supported by the encoder. If pix_fmt is prefixed by a <code>+</code>, ffmpeg will exit with an error if the requested pixel format can not be selected, and automatic conversions inside filtergraphs are disabled. If pix_fmt is a single <code>+</code>, ffmpeg selects the same pixel format as the input (or graph output) and automatic conversions are disabled.</p>
</li>
</ul>
<h2 id="4-audio参数"><a class="header" href="#4-audio参数">4. Audio参数</a></h2>
<ul>
<li>
<p>-aq q (<em>output</em>)</p>
<p>Set the audio quality (codec-specific, VBR). This is an alias for -q:a.</p>
</li>
<li>
<p>-ac[:stream_specifier] channels (<em>input/output,per-stream</em>)</p>
<p>Set the number of audio channels. For output streams it is set by default to the number of input audio channels. For input streams this option only makes sense for audio grabbing devices and raw demuxers and is mapped to the corresponding demuxer options.</p>
</li>
<li>
<p>-an (<em>input/output</em>)</p>
<p>As an input option, blocks all audio streams of a file from being filtered or being automatically selected or mapped for any output. See <code>-discard</code> option to disable streams individually.</p>
<p>As an output option, disables audio recording i.e. automatic selection or mapping of any audio stream. For full manual control see the <code>-map</code> option.</p>
</li>
<li>
<p>-acodec codec (<em>input/output</em>)</p>
<p>Set the audio codec. This is an alias for <code>-codec:a</code>.</p>
</li>
<li>
<p>-sample_fmt[:stream_specifier] sample_fmt (<em>output,per-stream</em>)</p>
<p>Set the audio sample format. Use <code>-sample_fmts</code> to get a list of supported sample formats.</p>
</li>
<li>
<p>-af filtergraph (<em>output</em>)</p>
<p>Create the filtergraph specified by filtergraph and use it to filter the stream.</p>
<p>This is an alias for <code>-filter:a</code>, see the <a href="http://ffmpeg.org/ffmpeg.html#filter_005foption">-filter option</a>.</p>
</li>
<li>
<p>-ar</p>
</li>
<li>
<p>-f sl6le</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ffmpeg-安装-macos"><a class="header" href="#ffmpeg-安装-macos">FFMPEG 安装 MACOS</a></h1>
<pre><code class="language-shell">./configure --prefix=/usr/local/ffmpeg --enable-gpl --enable-nonfree --enable-libfdk-aac --enable-libx264 --enable-libx265 --enable-filter=delogo --enable-debug --disable-optimizations --enable-libspeex --enable-videotoolbox --enable-shared --enable-pthreads --enable-version3 --enable-hardcoded-tables --cc=clang --host-cflags= --host-ldflags= --disable-x86asm

brew install fdk-aac&amp;&amp;brew install x264&amp;&amp;brew install x265&amp;&amp;brew install speex&amp;&amp;brew install pkg-config&amp;&amp;brew  install sdl2



export PATH=$PATH:/usr/local/ffmpeg/bin
export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig:/usr/lib/pkgconfig:/usr/local/Cellar/sdl2/2.0.8/lib/pkgconfig:/usr/local/ffmpeg/lib/pkgconfig

codesign --remove-signature /path/to/*.dylib
codesign -s &quot;Apple Development: Your Name (10-char-ID)&quot;  /path/to/*.dylib
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cmake-模板"><a class="header" href="#cmake-模板">CMAKE 模板</a></h1>
<h2 id="cmakepkg"><a class="header" href="#cmakepkg"><a href="https://cmake.org/cmake/help/v3.19/module/FindPkgConfig.html?highlight=pkg#command:pkg_check_modules">CMake+Pkg</a></a></h2>
<ul>
<li>
<p><code>&lt;XXX&gt;_FOUND</code></p>
<p>set to 1 if module(s) exist</p>
</li>
<li>
<p><code>&lt;XXX&gt;_LIBRARIES</code></p>
<p>only the libraries (without the ‘-l’)</p>
</li>
<li>
<p><code>&lt;XXX&gt;_LINK_LIBRARIES</code></p>
<p>the libraries and their absolute paths</p>
</li>
<li>
<p><code>&lt;XXX&gt;_LIBRARY_DIRS</code></p>
<p>the paths of the libraries (without the ‘-L’)</p>
</li>
<li>
<p><code>&lt;XXX&gt;_LDFLAGS</code></p>
<p>all required linker flags</p>
</li>
<li>
<p><code>&lt;XXX&gt;_LDFLAGS_OTHER</code></p>
<p>all other linker flags</p>
</li>
<li>
<p><code>&lt;XXX&gt;_INCLUDE_DIRS</code></p>
<p>the ‘-I’ preprocessor flags (without the ‘-I’)</p>
</li>
<li>
<p><code>&lt;XXX&gt;_CFLAGS</code></p>
<p>all required cflags</p>
</li>
<li>
<p><code>&lt;XXX&gt;_CFLAGS_OTHER</code></p>
<p>the other compiler flags</p>
</li>
</ul>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.19)
project(player)

set(CMAKE_CXX_STANDARD 11)
list(APPEND SOURCE
	src/main.c)
set(ENV{PKG_CONFIG_PATH} 
	/usr/local/sdl2/lib/pkgconfig:/usr/local/ffmpeg/lib/pkgconfig
)
find_package(PkgConfig)
pkg_check_modules(FFMPEG REQUIRED IMPORTED_TARGET libavcodec libavformat libavutil)
pkg_check_modules(SDL2 REQUIRED IMPORTED_TARGET sdl2)
add_executable(${PROJECT_NAME} ${SOURCE})
target_link_libraries(${PROJECT_NAME} PRIVATE
	PkgConfig::FFMPEG
	PkgConfig::SDL2
	)
</code></pre>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.19)
project(player)

set(CMAKE_CXX_STANDARD 11)
list(APPEND SOURCE
	src/main.c)
set(ENV{PKG_CONFIG_PATH} 
	/usr/local/sdl2/lib/pkgconfig:/usr/local/ffmpeg/lib/pkgconfig
)
find_package(PkgConfig)
pkg_check_modules(FFMPEG REQUIRED IMPORTED_TARGET libavcodec libavformat libavutil)
pkg_check_modules(SDL2 REQUIRED IMPORTED_TARGET sdl2)
add_executable(player ${SOURCE})
include_directories(
	${FFMPEG_INCLUDE_DIRS}
	${SDL2_INCLUDE_DIRS}
	)
target_link_libraries(player PRIVATE
	${FFMPEG_LDFLAGS}
	${SDL2_LDFLAGS}
	)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="yuvplayer-demo"><a class="header" href="#yuvplayer-demo">YUVPLayer Demo</a></h1>
<pre><code class="language-C">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;SDL.h&gt;
#include &lt;pthread.h&gt;
#define REFRESH_EVENT (SDL_USEREVENT + 1)
#define QUIT_EVENT (SDL_USEREVENT + 2)
bool thread_exit = false;
int refresh()
{
	thread_exit = false;
	while (!thread_exit) {
		SDL_Event event;
		event.type = REFRESH_EVENT;
		SDL_PushEvent(&amp;event);
		SDL_Delay(40);
	}
	thread_exit = true;

	SDL_Event event;
	event.type = QUIT_EVENT;
	SDL_PushEvent(&amp;event);
	return 0;
}
int main(int argc, char* argv[])
{
	FILE* video_fd = NULL;

	SDL_Event event = {0};
	SDL_Rect rect = {0};

	unsigned int pixformat = 0;
	
	SDL_Window* window = NULL;
	SDL_Renderer* renderer = NULL;
	SDL_Texture* texture = NULL;
	SDL_Thread* timer_thread = NULL;

	int win_w = 1920;
	int win_h = 1080;
	const int video_w = win_w;
	const int video_h = win_h;
	
	unsigned char* video_pos = NULL;
	unsigned char* video_end = NULL;

	unsigned int remain_len = 0;
	size_t video_buffer_len = 0;
	size_t blank_space_len = 0;
	unsigned char* video_buf = NULL;

	const char* path = &quot;1.yuv&quot;;
	const unsigned int yuv_frame_len = video_w * video_h * 12 / 8;
	unsigned int tmp_yuv_frame_len = yuv_frame_len;

	if (yuv_frame_len &amp; 0xF) {
		tmp_yuv_frame_len = (yuv_frame_len &amp; 0xFFF0) + 0x10;
	}

	if (SDL_Init(SDL_INIT_VIDEO)) {
		printf(&quot;SDL INIT Fail!\n&quot;);
		return -1;
	}
	window = SDL_CreateWindow(
			&quot;YUV Player&quot;,
			SDL_WINDOWPOS_UNDEFINED,
			SDL_WINDOWPOS_UNDEFINED,
			win_w, win_h,
			SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE
	);
	if (window == NULL) {
		printf(&quot;Window create Fail!\n&quot;);
		// TODO 资源释放
		return -1;
	} 
	renderer = SDL_CreateRenderer(window, -1, 0);
	// IYVU: Y + U + V (3 planes)
	// YV12: Y + V + U (3 planes)
	pixformat = SDL_PIXELFORMAT_IYUV;
	texture = SDL_CreateTexture(
							renderer,
							pixformat,
							SDL_TEXTUREACCESS_STREAMING,
							video_w, video_h
							);

	video_buf = (unsigned char*) malloc(tmp_yuv_frame_len);
	if (video_buf == NULL) {
		// TODO 资源释放
		return -1;
	}
	video_fd = fopen(path, &quot;r&quot;);
	video_buffer_len = fread(video_buf, 1, yuv_frame_len, video_fd);
	if (video_buffer_len &lt;= 0) {
		return -1;
	}
	video_pos = video_buf;
	timer_thread = SDL_CreateThread(
		refresh,
		&quot;thread&quot;,
		NULL
	);
	do {
		SDL_WaitEvent(&amp;event);
		if (event.type == REFRESH_EVENT) {
			SDL_UpdateTexture(texture, NULL, video_pos, video_w);
			rect.x = 0;
			rect.y = 0;
			rect.w = win_w;
			rect.h = win_h;
			SDL_RenderCopy(renderer, texture, NULL, &amp;rect);
			SDL_RenderPresent(renderer);

			video_buffer_len = fread(video_buf, 1, yuv_frame_len, video_fd);
			if (video_buffer_len &lt;= 0) {
				thread_exit = true;
				continue;
			}
		} else if (event.type == SDL_WINDOWEVENT) {
			SDL_GetWindowSize(window, &amp;win_w, &amp;win_h);
		} else if (event.type == SDL_QUIT) {
			thread_exit = true;
		} else if (event.type == QUIT_EVENT) {
			break;
		}
	} while(1);
	return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pcmplayer-democ"><a class="header" href="#pcmplayer-democ">PCMPLayer Demo(C)</a></h1>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;SDL.h&gt;
#include &lt;pthread.h&gt;
#define BLOCK_SIZE 4096000
unsigned char* audio_buf = NULL;
unsigned char* audio_pos = NULL;
size_t buffer_len = 0;
void read_audio_data(void* userdatai, Uint8* stream, int len)
{
	if (buffer_len == 0) {
		return;
	}
	SDL_memset(stream, 0, len);
	len = (len &lt; buffer_len) ? len : buffer_len;
	SDL_MixAudio(stream, audio_pos, len, SDL_MIX_MAXVOLUME);
	audio_pos += len;
	buffer_len -= len;
}
int main(int argc, char* argv[])
{
	if (SDL_Init(SDL_INIT_AUDIO) != 0) {
		SDL_Log(&quot;init fail!\n&quot;);
		return -1;
	}
	const char* path = &quot;1.pcm&quot;;
	FILE* audio_fd = fopen(path, &quot;r&quot;);
	if (audio_fd == NULL) {
		SDL_Log(&quot;open fail!\n&quot;);
		SDL_Quit();
		return -1;
	}
	audio_buf = malloc(BLOCK_SIZE);
	if (audio_buf == NULL) {
		SDL_Log(&quot;malloc fail!\n&quot;);
		fclose(audio_fd);
		SDL_Quit();
	}
	SDL_AudioSpec spec;
	spec.freq = 48000;
	spec.channels = 2;
	spec.format = AUDIO_S16SYS;
	spec.callback = read_audio_data;
	spec.userdata = NULL;
	if (SDL_OpenAudio(&amp;spec, NULL) != 0) {
		SDL_Log(&quot;open audio fail!\n&quot;);
		fclose(audio_fd);
		free(audio_buf);
		SDL_Quit();
		return -1;
	}
	SDL_PauseAudio(0);
	do {
		buffer_len = fread(audio_buf, 1, BLOCK_SIZE, audio_fd);
		audio_pos = audio_buf;
		while (audio_pos &lt; (audio_buf + buffer_len)) {
			SDL_Delay(1);
		}
	} while(buffer_len != 0);

	SDL_CloseAudio();
	fclose(audio_fd);
	free(audio_buf);
	SDL_Quit();
	return 0;
}	
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="redis"><a class="header" href="#redis">Redis</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="net"><a class="header" href="#net">NET</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vim"><a class="header" href="#vim">VIM</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ccls"><a class="header" href="#ccls">CCLS</a></h1>
<h1 id="1-依赖"><a class="header" href="#1-依赖">1. 依赖</a></h1>
<ul>
<li>vim8+ ｜ <a href="https://github.com/neovim/neovim/wiki/Installing-Neovim#install-from-download">neovim</a></li>
<li><a href="https://github.com/llvm/llvm-project/releases">clang+llvm</a></li>
<li><a href="https://github.com/MaskRay/ccls">ccls</a></li>
<li><a href="https://github.com/nvm-sh/nvm">nvm</a></li>
<li>Node</li>
<li><a href="https://github.com/junegunn/vim-plug">vim-plug</a></li>
<li><a href="https://github.com/neoclide/coc.nvim">coc.nvim</a></li>
</ul>
<h1 id="2-neovim可选"><a class="header" href="#2-neovim可选">2. neovim(可选)</a></h1>
<h1 id="3-clangllvm"><a class="header" href="#3-clangllvm">3. <a href="https://github.com/llvm/llvm-project/releases">clang+llvm</a></a></h1>
<pre><code class="language-shell">wget https://github.com/llvm/llvm-project/releases/download/llvmorg-13.0.0/clang+llvm-13.0.0-x86_64-linux-gnu-ubuntu-20.04.tar.xz

tar -xvf *.tar.zx
cd clang+llvm-13.0.0-x86_64-linux-gnu-ubuntu-20.04
# &gt; bashrc
############clang+llvm
export LLVM_HOME=***/clang+llvm-13.0.0-x86_64-linux-gnu-ubuntu-20.04
export PATH=$LLVM_HOME/bin:$PATH
export C_IONCLUDE_PATH=$LLVM_HOME/include:$C_INCLUDE_PATH
export LD_LIBRARY_PATH=$LLVM_HOME/lib:$LD_LIBRARY_PATH

</code></pre>
<h1 id="4-ccls"><a class="header" href="#4-ccls">4. <a href="https://github.com/MaskRay/ccls">ccls</a></a></h1>
<pre><code class="language-shell">git clone --depth=1 --recursive https://github.com/MaskRay/ccls
cd ccls
# sudo apt install zlib1g zlib1g-dev
cmake -H. -BRelease -DCMAKE_BUILD_TYPE=Release
cmake --build Release
</code></pre>
<h1 id="5-nvm"><a class="header" href="#5-nvm">5. <a href="https://github.com/nvm-sh/nvm#troubleshooting-on-linux">nvm</a></a></h1>
<pre><code class="language-bash">export NVM_DIR=&quot;$HOME/.nvm&quot; &amp;&amp; (
  git clone https://github.com/nvm-sh/nvm.git &quot;$NVM_DIR&quot;
  cd &quot;$NVM_DIR&quot;
  git checkout `git describe --abbrev=0 --tags --match &quot;v[0-9]*&quot; $(git rev-list --tags --max-count=1)`
) &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot;

# &gt;&gt; ~/.bashrc
export NVM_DIR=&quot;$HOME/.nvm&quot;
[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm
[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \. &quot;$NVM_DIR/bash_completion&quot;  # This loads nvm bash_completion

</code></pre>
<h1 id="6-node"><a class="header" href="#6-node">6. node</a></h1>
<pre><code class="language-shell">nvm ls-remote
nvm install * 
nvm use *
</code></pre>
<h1 id="7-cocnvm"><a class="header" href="#7-cocnvm">7. <a href="https://github.com/neoclide/coc.nvim">coc.nvm</a></a></h1>
<pre><code>Plug 'neoclide/coc.nvim', {'branch': 'master', 'do': 'yarn install --frozen-lockfile'}
</code></pre>
<h1 id="8-cmake-生成-compile_commandsjson"><a class="header" href="#8-cmake-生成-compile_commandsjson">8. CMake 生成 compile_commands.json</a></h1>
<pre><code class="language-cmake">set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
# -DCMAKE_EXPORT_COMPILE_COMMANDS=ON 
cmake -H. -Bbuild -DCMAKE_BUILD_TYPE=Release -DCMAKE_EXPORT_COMPILE_COMMANDS=ON &amp;&amp; ln build/compile_commands.json ./
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="base"><a class="header" href="#base">Base</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="计算机组成原理"><a class="header" href="#计算机组成原理">计算机组成原理</a></h1>
<h1 id="1-冯诺依曼系统三大组成"><a class="header" href="#1-冯诺依曼系统三大组成">1. 冯诺依曼系统三大组成</a></h1>
<h2 id="11-控制器"><a class="header" href="#11-控制器">1.1 控制器</a></h2>
<h3 id="111-性能"><a class="header" href="#111-性能">1.1.1 性能</a></h3>
<ul>
<li>空间</li>
<li>时间
<ul>
<li>指令周期</li>
<li>CPU周期</li>
<li>时钟周期</li>
<li>指令数 * 指令运行的平均周期 * 时钟周期 </li>
</ul>
</li>
<li>能耗
<ul>
<li>能耗= 1 / 2 * 负载电容 * 电压的平方 * 开关频率 * 晶体管数量</li>
</ul>
</li>
</ul>
<h3 id="112-控制流程"><a class="header" href="#112-控制流程">1.1.2 控制流程</a></h3>
<ul>
<li>取码</li>
<li>译码</li>
<li>执行（处理器执行）</li>
</ul>
<h2 id="12-处理器"><a class="header" href="#12-处理器">1.2 处理器</a></h2>
<ul>
<li>CPU（ALU）</li>
<li>GPU</li>
<li>DPU</li>
</ul>
<h2 id="13-存储器"><a class="header" href="#13-存储器">1.3 存储器</a></h2>
<ul>
<li>
<p>寄存器</p>
<ul>
<li>状态寄存器</li>
<li>命令（指令）寄存器</li>
<li>数据寄存器</li>
</ul>
</li>
<li>
<p>内存</p>
</li>
<li>
<p>外存</p>
</li>
<li>
<p>网络存储</p>
</li>
</ul>
<h1 id="2-指令和运算"><a class="header" href="#2-指令和运算">2. 指令和运算</a></h1>
<h2 id="21-指令分类"><a class="header" href="#21-指令分类">2.1 指令分类</a></h2>
<ul>
<li>运算类</li>
<li>数据传输类</li>
<li>逻辑类
<ul>
<li>与或非异或</li>
<li>有条件跳转</li>
<li>无条件跳转</li>
</ul>
</li>
</ul>
<h2 id="22-性能优化"><a class="header" href="#22-性能优化">2.2 性能优化</a></h2>
<h3 id="221-指令流水线"><a class="header" href="#221-指令流水线">2.2.1 指令流水线</a></h3>
<ul>
<li>取码</li>
<li>译码</li>
<li>执行
<ul>
<li>ALU计算（执行）</li>
<li>访寸</li>
<li>写回</li>
</ul>
</li>
</ul>
<h3 id="222-结构冒险增加资源"><a class="header" href="#222-结构冒险增加资源">2.2.2 结构冒险（增加资源）</a></h3>
<ul>
<li>分为指令内存和数据内存（哈佛结构）</li>
<li>NOP再分配</li>
</ul>
<h3 id="223-数据冒险流水线冒泡"><a class="header" href="#223-数据冒险流水线冒泡">2.2.3 数据冒险（流水线冒泡）</a></h3>
<p>增加空指令NOP</p>
<ul>
<li>写后读（数据依赖）</li>
<li>读后写（反依赖）</li>
<li>写后写（输出依赖）</li>
</ul>
<p>指令分发和结果重排序（乱序）</p>
<h3 id="224-控制冒险"><a class="header" href="#224-控制冒险">2.2.4 控制冒险</a></h3>
<ul>
<li>分支预测</li>
<li>局部性原理</li>
</ul>
<h1 id="3-处理器"><a class="header" href="#3-处理器">3. 处理器</a></h1>
<ul>
<li>CPU
<ul>
<li>CISC</li>
<li>RISC</li>
<li>RISC-V</li>
</ul>
</li>
<li>GPU</li>
</ul>
<h1 id="4-存储与io"><a class="header" href="#4-存储与io">4. 存储与I/O</a></h1>
<h2 id="41-普通存储"><a class="header" href="#41-普通存储">4.1 普通存储</a></h2>
<ul>
<li>寄存器</li>
<li>内存
<ul>
<li>SRAM</li>
<li>DRAM</li>
</ul>
</li>
<li>外存
<ul>
<li>SSD</li>
<li>HHD</li>
</ul>
</li>
</ul>
<h2 id="42-存储信息同步"><a class="header" href="#42-存储信息同步">4.2 存储信息同步</a></h2>
<ul>
<li>写直达</li>
<li>写回</li>
<li>MESI 协议（广播）</li>
</ul>
<h2 id="43-虚拟内存"><a class="header" href="#43-虚拟内存">4.3 虚拟内存</a></h2>
<ul>
<li>TLB-MMU-CPU</li>
</ul>
<h2 id="44-bus"><a class="header" href="#44-bus">4.4 BUS</a></h2>
<h3 id="441-双独立总线"><a class="header" href="#441-双独立总线">4.4.1 双独立总线</a></h3>
<ul>
<li>CPU - 本地总线（快） - Cache</li>
<li>CPU - 系统总线（前段总线、慢） - 内存｜I/O
<ul>
<li>IO总线</li>
<li>内存总线</li>
</ul>
</li>
</ul>
<pre><code class="language-html">CPU&lt;-系统总线-&gt;北桥芯片(IO桥接器)&lt;-内存总线-&gt;内存
  						     ⬆️
 &lt;------------------IO总线------------------------&gt;
 		⬇️             ⬇️                  ⬇️
 USB控制器         显卡适配器          硬盘控制器
   ⬇️               ⬇️                 ⬇️
  键盘/鼠标         显示器               硬盘
</code></pre>
<ul>
<li>
<p>从功能区分</p>
<ul>
<li>
<p>数据总线</p>
</li>
<li>
<p>地址总线</p>
</li>
<li>
<p>控制总线</p>
</li>
</ul>
</li>
</ul>
<h2 id="45-io设备"><a class="header" href="#45-io设备">4.5 IO设备</a></h2>
<ul>
<li>接口 + 设备</li>
<li>驱动</li>
<li>IOPS
<ul>
<li>top</li>
<li>iostat</li>
<li>iotop</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="操作系统实战笔记"><a class="header" href="#操作系统实战笔记">操作系统实战笔记</a></h1>
<h1 id="1-构建基础景象"><a class="header" href="#1-构建基础景象">1. 构建基础景象</a></h1>
<h2 id="11-grubcfg"><a class="header" href="#11-grubcfg">1.1 grub.cfg</a></h2>
<pre><code>menuentry 'HelloOS' {
insmod part_msdos
insmod ext2
set root='hd0,msdos1' #我们的硬盘只有一个分区所以是'hd0,msdos1'
multiboot2 /boot/HelloOS.eki #加载boot目录下的HelloOS.eki文件
boot #引导启动
}
set timeout_style=menu
if [ &quot;${timeout}&quot; = 0 ]; then
  set timeout=10 #等待10秒钟自动启动
fi
</code></pre>
<h2 id="12-一键脚本-makefile"><a class="header" href="#12-一键脚本-makefile">1.2 一键脚本 Makefile</a></h2>
<pre><code class="language-makefile">PHONY:all
OSNAME=HelloOS
IMGNAME=hd
LOOP=loop11
REMOTE=vm
REMOTE_DIR=/home/cal/code/os/cosmos/cal/cal2
all:
	make clean
	make create_os
	make build_os
build_os:
	scp ${REMOTE}:${REMOTE_DIR}/${IMGNAME}.img ./
	VBoxManage convertfromraw ./hd.img --format VDI ./${IMGNAME}.vdi
	VBoxManage storagectl ${OSNAME} --name &quot;SATA&quot; --add sata --controller IntelAhci --portcount 1
	VBoxManage closemedium disk ./${IMGNAME}.vdi
	VBoxManage storageattach ${OSNAME} --storagectl &quot;SATA&quot; --port 1 --device 0 --type hdd --medium ./${IMGNAME}.vdi
create_os:
	VBoxManage createvm --name ${OSNAME} --register
start:
	VBoxManage startvm ${OSNAME}
close:
	VBoxManage controlvm ${OSNAME} poweroff
clean:
	rm -rf ./hd.vdi
	rm -rf ./hd.img
	VBoxManage unregistervm --delete ${OSNAME}
doc:
	echo &quot;https://cloud.tencent.com/developer/article/2030930&quot;
	echo &quot;https://blog.csdn.net/HandsomeHong/article/details/115418206&quot;
build_remote:
	scp Makefile ${REMOTE}:${REMOTE_DIR}/ 
	scp grub.cfg ${REMOTE}:${REMOTE_DIR}
	ssh ${REMOTE} &quot;make --file=${REMOTE_DIR}/Makefile remote&quot;
remote:
	dd bs=512 if=/dev/zero of=${IMGNAME}.img count=204800
	sudo losetup /dev/${LOOP} ${IMGNAME}.img
	sudo mkfs.ext4 -q /dev/${LOOP}
	sudo mkdir ./hdisk
	sudo mount -o loop ./${IMGNAME}.img ./hdisk/
	sudo mkdir ./hdisk/boot/
	sudo grub-install --boot-directory=./hdisk/boot/ --force --allow-floppy /dev/${LOOP}
	sudo cp grub.cfg ./hdist/boot/grub/
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="工具"><a class="header" href="#工具">工具</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="verilog-on-mac"><a class="header" href="#verilog-on-mac"><a href="https://zhuanlan.zhihu.com/p/291571592">Verilog on MAC</a></a></h1>
<h1 id="1-安装"><a class="header" href="#1-安装">1. 安装</a></h1>
<h2 id="11-安装-verilog-和-gtkware"><a class="header" href="#11-安装-verilog-和-gtkware">1.1 安装 Verilog 和 gtkware</a></h2>
<pre><code class="language-bash">brew install icarus-verilog
brew install verilator
brew install xquartz # --cask
brew install gtkwave # --cask
</code></pre>
<h2 id="12-安装-graphviz"><a class="header" href="#12-安装-graphviz">1.2 安装 graphviz</a></h2>
<pre><code class="language-bash">brew install graphviz # 可以打印png格式的电路结构图
brew install xdot
</code></pre>
<h2 id="13-安装yosys"><a class="header" href="#13-安装yosys">1.3 安装yosys</a></h2>
<pre><code class="language-shell">git clone https://github.com/YosysHQ/yosys.git
cd yosys
brew tap Homebrew/bundle &amp;&amp; brew bundle
make
sudo make install
# 输入 yosys 进入工作模式
</code></pre>
<h1 id="2-验证安装"><a class="header" href="#2-验证安装">2. 验证安装</a></h1>
<h2 id="21-编写counterv"><a class="header" href="#21-编写counterv">2.1 编写counter.v</a></h2>
<pre><code class="language-verilog">module counter (clk, rst, en, count);
   input clk, rst, en;
   output reg [1:0] count;
   always @(posedge clk)
      if (rst)      //复位信号
         count &lt;= 2'd0;
      else if (en)  //使能信号
         count &lt;= count + 2'd1;
endmodule
</code></pre>
<h2 id="22-test-bench-counter_tbv"><a class="header" href="#22-test-bench-counter_tbv">2.2 test bench: counter_tb.v</a></h2>
<pre><code class="language-verilog">`timescale 1ns / 1ps
module counter_tb;

reg clk;
reg reset;
reg enable;
wire [1:0] counter_out;

counter c1(clk,reset,enable,counter_out);

/*iverilog */
initial
begin            
    $dumpfile(&quot;wave.vcd&quot;);        //生成的vcd文件名称
    $dumpvars(0, counter_tb);     //tb模块名称
end
/*iverilog */

initial
begin
  clk=0;
  reset=1;
  enable=1;
  clk=1;
  #10
  reset=0;
end
always
#5 clk=~clk;

initial
  #2000 $finish;

endmodule
</code></pre>
<h2 id="23-编写仿真执行脚本-simu_runsh"><a class="header" href="#23-编写仿真执行脚本-simu_runsh">2.3 编写仿真执行脚本: simu_run.sh</a></h2>
<p>执行脚本查看波形图</p>
<pre><code class="language-shell">echo &quot;开始编译&quot;
iverilog -o wave ./counter.v counter_tb.v
echo &quot;编译完成&quot;

echo &quot;生成波形文件&quot;
vvp -n wave -lxt2 
cp wave.vcd wave.lxt

echo &quot;打开波形文件&quot;
gtkwave wave.vcd
</code></pre>
<h2 id="24-编写综合文件-counterys-下载"><a class="header" href="#24-编写综合文件-counterys-下载">2.4 编写综合文件: counter.ys <a href="https://pan.baidu.com/s/1ngzdwX9KkDVTJVOoGkx3dg">下载</a></a></h2>
<p>执行</p>
<pre><code class="language-bash">yosys counter.ys
</code></pre>
<pre><code class="language-verilog"># read design
read_verilog counter.v
hierarchy -check -top counter

# the high-level stuff
proc; opt; memory; opt; fsm; opt

# mapping to internal cell library
techmap; opt

# mapping flip-flops to mycells.lib
dfflibmap -liberty mycells.lib

# mapping logic to mycells.lib
abc -liberty mycells.lib

# cleanup
clean

write_verilog counter_gate.v

# 其中的mycells.lib和mycells.v是自定义的库文件 需要从标题链接下载 提取码 5076
</code></pre>
<p>mycells.v</p>
<pre><code class="language-verilog">module NOT(A, Y);
input A;
output Y = ~A;
endmodule

module NAND(A, B, Y);
input A, B;
output Y = ~(A &amp; B);
endmodule

module NOR(A, B, Y);
input A, B;
output Y = ~(A | B);
endmodule

module DFF(C, D, Q);
input C, D;
output reg Q;
always @(posedge C)
	Q &lt;= D;
endmodule
</code></pre>
<p>mycells.lib</p>
<pre><code class="language-verilog">library(demo) {
  cell(BUF) {
    area: 6;
    pin(A) { direction: input; }
    pin(Y) { direction: output;
              function: &quot;A&quot;; }
  }
  cell(NOT) {
    area: 3;
    pin(A) { direction: input; }
    pin(Y) { direction: output;
              function: &quot;A'&quot;; }
  }
  cell(NAND) {
    area: 4;
    pin(A) { direction: input; }
    pin(B) { direction: input; }
    pin(Y) { direction: output;
             function: &quot;(A*B)'&quot;; }
  }
  cell(NOR) {
    area: 4;
    pin(A) { direction: input; }
    pin(B) { direction: input; }
    pin(Y) { direction: output;
             function: &quot;(A+B)'&quot;; }
  }
  cell(DFF) {
    area: 18;
    ff(IQ, IQN) { clocked_on: C;
                  next_state: D; }
    pin(C) { direction: input;
                 clock: true; }
    pin(D) { direction: input; }
    pin(Q) { direction: output;
              function: &quot;IQ&quot;; }
  }
}
</code></pre>
<h2 id="25-打印电路图-counter_show_pdfys"><a class="header" href="#25-打印电路图-counter_show_pdfys">2.5 打印电路图: counter_show_pdf.ys</a></h2>
<p>执行</p>
<pre><code class="language-bash">yosys counter_show_pdf.ys # 该过程共输出4个dot文件和4个pdf文件，分别对应了counter网表的四种详细等级的输出
# dot counter_03.dot -T png -o counter_03.png # 输出png
</code></pre>
<pre><code class="language-verilog"># read design
read_verilog counter.v
hierarchy -check -top counter

# show0: print counter without high-level stuff
show -notitle -stretch -format pdf -prefix counter_00

# the high-level stuff
proc; opt; memory; opt; fsm; opt

# show1: print counter with high-level stuff
show -notitle -stretch -format pdf -prefix counter_01

# mapping to internal cell library
techmap; opt
splitnets -ports;;

# show3: print counter mappped with internal cell library
show -notitle -stretch -format pdf -prefix counter_02

# mapping flip-flops to mycells.lib
dfflibmap -liberty mycells.lib

# mapping logic to mycells.lib
abc -liberty mycells.lib

# cleanup
clean

# show4: print counter with internal cell lib and mycell lib
show -notitle -stretch -lib mycells.v -format pdf -prefix counter_03

shell
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="verilog语法规则"><a class="header" href="#verilog语法规则"><a href="https://www.runoob.com/w3cnote/verilog-timing-control.html">Verilog语法规则</a></a></h1>
<h1 id="1-关键字"><a class="header" href="#1-关键字">1. 关键字</a></h1>
<ul>
<li>
<p>wire (wire 型变量只能被赋值一次)</p>
</li>
<li>
<p>assign (任何已经声明 wire 变量的连续赋值语句都是以 assign 开头)</p>
</li>
<li>
<p>//</p>
</li>
<li>
<p>/**/</p>
</li>
<li>
<p>reg[31:0]</p>
</li>
<li>
<p>input</p>
</li>
<li>
<p>output</p>
</li>
<li>
<p>module</p>
</li>
<li>
<p>endmodule</p>
</li>
<li>
<p>always</p>
</li>
<li>
<p>postedge</p>
</li>
<li>
<p>beigin</p>
</li>
<li>
<p>end</p>
</li>
<li>
<p>$time</p>
</li>
<li>
<p>$finish</p>
</li>
<li>
<p>or （or 也可以用逗号 <strong>,</strong> 来代替）</p>
<ul>
<li>更为简洁的写法是 <strong>@*</strong> 或 <strong>@(*)</strong>，表示对语句块中的所有输入变量的变化都是敏感的</li>
</ul>
</li>
<li>
<p>event (事件)</p>
<pre><code class="language-verilog">event     start_receiving ;
always @( posedge clk_samp) begin
        -&gt; start_receiving ;       //采样时钟上升沿作为时间触发时刻
end
 
always @(start_receiving) begin
    data_buf = {data_if[0], data_if[1]} ; //触发时刻，对多维数据整合
end
</code></pre>
</li>
<li>
<p>fork （并行， begin）</p>
</li>
<li>
<p>join （并行, end）</p>
</li>
<li>
<p>disable</p>
</li>
<li>
<p>case</p>
</li>
<li>
<p>casez(casez 用问号 &quot;?&quot; 来表示无关值。)</p>
</li>
<li>
<p>casex(casex 用 &quot;x&quot; 来表示无关值)</p>
<pre><code class="language-verilog">module mux4to1(
    input [3:0]     sel ,
    input [1:0]     p0 ,
    input [1:0]     p1 ,
    input [1:0]     p2 ,
    input [1:0]     p3 ,
    output [1:0]    sout);
 
    reg [1:0]     sout_t ;
    always @(*)
        casez(sel)
            4'b???1:     sout_t = p0 ;
            4'b??1?:     sout_t = p1 ;
            4'b?1??:     sout_t = p2 ;
            4'b1???:     sout_t = p3 ;  
        default:         sout_t = 2'b0 ;
    endcase
    assign      sout = sout_t ;
 
endmodule
</code></pre>
</li>
<li>
<p>default</p>
</li>
<li>
<p>while</p>
</li>
<li>
<p>for</p>
</li>
<li>
<p>repeat</p>
</li>
<li>
<p>forever</p>
</li>
<li>
<p>deassign</p>
</li>
<li>
<p>force</p>
</li>
<li>
<p>release</p>
</li>
</ul>
<h1 id="2-数值"><a class="header" href="#2-数值">2. 数值</a></h1>
<ul>
<li>0</li>
<li>1</li>
<li>X 或者 x (未知)</li>
<li>Z 或者 z (高组态)</li>
<li>b|B|d|D|h|H|o|O</li>
<li>4'b1011</li>
<li>b1011 自动匹配位宽</li>
<li>字符串
<ul>
<li>reg [0: 14*8 -1] str;</li>
<li>str = &quot;www.runoob.com&quot;;</li>
</ul>
</li>
</ul>
<h1 id="3-数据类型"><a class="header" href="#3-数据类型">3. 数据类型</a></h1>
<ul>
<li>wire</li>
<li>reg</li>
<li>integer （整数）</li>
<li>real （实数）</li>
<li>time</li>
<li>数组
<ul>
<li>integer     flag [7:0] ; <em>//8个整数组成的数组</em>
reg [3:0]    counter [3:0] ; <em>//由4个4bit计数器组成的数组</em>
wire [7:0]    addr_bus [3:0] ; <em>//由4个8bit wire型变量组成的数组</em>
wire       data_bit[7:0][5:0] ; <em>//声明1bit wire型变量的二维数组</em>
reg [31:0]    data_4d[11:0][3:0][3:0][255:0] ; <em>//声明4维的32bit数据变量数组</em></li>
</ul>
</li>
<li>parameter（只能赋值一次）
<ul>
<li>parameter    data_width = 10'd32 ;</li>
</ul>
</li>
<li>RAM 或者 ROM
<ul>
<li>用寄存器数组表示</li>
<li>reg [7:0]     mem[0:1023] ;   <em>//1Kbyte存储器，位宽8bit</em></li>
</ul>
</li>
</ul>
<h1 id="4-表达式"><a class="header" href="#4-表达式">4. 表达式</a></h1>
<h2 id="41-操作符"><a class="header" href="#41-操作符">4.1 操作符</a></h2>
<ul>
<li>
<p>算术、关系、等价、逻辑、按位、归约、移位、拼接、条件操作符</p>
</li>
<li>
<p>归约</p>
<ul>
<li>归约操作符只有一个操作数，它对这个向量操作数逐位进行操作，最终产生一个 1bit 结果。</li>
</ul>
</li>
<li>
<p>拼接操作符(拼接符操作数必须指定位宽，常数的话也需要指定位宽)</p>
<p>{,}</p>
<pre><code class="language-verilog">A = 4'b1010 ;
B = 1'b1 ;
Y1 = {B, A[3:2], A[0], 4'h3 };  //结果为Y1='b1100_0011
Y2 = {4{B}, 3'd4};  //结果为 Y2=7'b111_1100
Y3 = {32{1'b0}};  //结果为 Y3=32h0，常用作寄存器初始化时匹配位宽的赋初值
</code></pre>
</li>
<li>
<p>条件操作符(可以多路)</p>
<pre><code class="language-verilog">assign   hsel = (addr[9:8] == 2'b00) ? hsel_p1 : 
                (addr[9:8] == 2'b01) ? hsel_p2 :
                (addr[9:8] == 2'b10) ? hsel_p3 :
                (addr[9:8] == 2'b11) ? hsel_p4 ;
</code></pre>
</li>
</ul>
<h1 id="5-编译指令"><a class="header" href="#5-编译指令">5. <a href="https://www.runoob.com/w3cnote/verilog-compile-instruction.html">编译指令</a></a></h1>
<p>以反引号 <strong>`</strong> 开始的某些标识符是 Verilog 系统编译指令。</p>
<h2 id="51-define-undef"><a class="header" href="#51-define-undef">5.1 `define, `undef</a></h2>
<p>在编译阶段，<strong>`define</strong> 用于文本替换，类似于 C 语言中的 <strong>#define</strong>。</p>
<p>一旦 <strong>`define</strong> 指令被编译，其在整个编译过程中都会有效。例如，在一个文件中定义</p>
<pre><code class="language-verilog">`ifdef, `ifndef, `elsif, `else, `endif
</code></pre>
<h2 id="52-include"><a class="header" href="#52-include">5.2 `include</a></h2>
<p>使用 <strong>`include</strong> 可以在编译时将一个 Verilog 文件内嵌到另一个 Verilog 文件中，作用类似于 C 语言中的 #include 结构。该指令通常用于将全局或公用的头文件包含在设计文件里。</p>
<p>文件路径既可以使用相对路径，也可以使用绝对路径。</p>
<pre><code class="language-verilog">`include         &quot;../../param.v&quot;
`include         &quot;header.v&quot;
</code></pre>
<h2 id="53-timescale"><a class="header" href="#53-timescale">5.3 `timescale</a></h2>
<p>在 Verilog 模型中，时延有具体的单位时间表述，并用 <strong>`timescale</strong> 编译指令将时间单位与实际时间相关联。</p>
<p>在编译过程中，<strong><code>timescale 指令会影响后面所有模块中的时延值，直至遇到另一个 **</code>timescale</strong> 指令或 <strong>`resetall</strong> 指令。</p>
<p>该指令用于定义时延、仿真的单位和精度，格式为：</p>
<pre><code class="language-verilog">`timescale      time_unit / time_precision
# time_unit 表示时间单位，time_precision 表示时间精度，它们均是由数字以及单位 s（秒），ms（毫秒），us（微妙），ns（纳秒），ps（皮秒）和 fs（飞秒）组成。时间精度可以和时间单位一样，但是时间精度大小不能超过时间单位大小

`timescale 1ns/100ps    //时间单位为1ns，精度为100ps，合法
</code></pre>
<h2 id="53-default_nettype"><a class="header" href="#53-default_nettype">5.3 `default_nettype</a></h2>
<p>该指令用于为隐式的线网变量指定为线网类型，即将没有被声明的连线定义为线网类型。</p>
<pre><code class="language-verilog">`default_nettype wand 
`default_nettype none
</code></pre>
<h1 id="6-时延"><a class="header" href="#6-时延">6. 时延</a></h1>
<h1 id="7-过程结构"><a class="header" href="#7-过程结构">7. 过程结构</a></h1>
<p>这些语句在模块间并行执行，与其在模块的前后顺序没有关系。</p>
<h2 id="71-initil"><a class="header" href="#71-initil">7.1 initil</a></h2>
<h2 id="72-always"><a class="header" href="#72-always">7.2 always</a></h2>
<h1 id="8-过程赋值"><a class="header" href="#8-过程赋值">8. 过程赋值</a></h1>
<p>在设计电路时，always 时序逻辑块中多用非阻塞赋值，always 组合逻辑块中多用阻塞赋值；在仿真电路时，initial 块中一般多用阻塞赋值</p>
<h2 id="81-阻塞赋值-"><a class="header" href="#81-阻塞赋值-">8.1 阻塞赋值 (=)</a></h2>
<h2 id="82-非阻塞赋值-"><a class="header" href="#82-非阻塞赋值-">8.2 非阻塞赋值 (&lt;=)</a></h2>
<h2 id="83-并行"><a class="header" href="#83-并行">8.3 并行</a></h2>
<h1 id="9-时序控制"><a class="header" href="#9-时序控制">9. 时序控制</a></h1>
<ul>
<li>事件控制用符号 <strong>@</strong> 表示。</li>
<li>posedge 指信号发生边沿正向跳变</li>
<li>negedge 指信号发生负向边沿跳变</li>
<li>未指明跳变方向时，则 2 种情况的边沿变化都会触发相关事件</li>
</ul>
<pre><code class="language-verilog">//信号clk只要发生变化，就执行q&lt;=d，双边沿D触发器模型
always @(clk) q &lt;= d ;                
//在信号clk上升沿时刻，执行q&lt;=d，正边沿D触发器模型
always @(posedge clk) q &lt;= d ;  
//在信号clk下降沿时刻，执行q&lt;=d，负边沿D触发器模型
always @(negedge clk) q &lt;= d ; 
//立刻计算d的值，并在clk上升沿时刻赋值给q，不推荐这种写法
q = @(posedge clk) d ;  
</code></pre>
<pre><code class="language-verilog">// Verilog 中还支持使用电平作为敏感信号来控制时序，即后面语句的执行需要等待某个条件为真。Verilog 中使用关键字 wait 来表示这种电平敏感情况
initial begin
    wait (start_enable) ;      //等待 start 信号
    forever begin
        //start信号使能后，在clk_samp上升沿，对数据进行整合
        @(posedge clk_samp)  ;
        data_buf = {data_if[0], data_if[1]} ;      
    end
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="web"><a class="header" href="#web">Web</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webassembly"><a class="header" href="#webassembly"><a href="https://juejin.cn/post/7038540255510659109">WebAssembly</a></a></h1>
<h1 id="1-安装cc转换工具"><a class="header" href="#1-安装cc转换工具">1. 安装C/C++转换工具</a></h1>
<pre><code class="language-shell"># https://emscripten.org/docs/getting_started/downloads.html
git clone https://github.com/emscripten-core/emsdk.git
cd emsdk
# Fetch the latest version of the emsdk (not needed the first time you clone)
git pull

# Download and install the latest SDK tools.
./emsdk install latest
# Make the &quot;latest&quot; SDK &quot;active&quot; for the current user. (writes .emscripten file)
./emsdk activate latest
# Activate PATH and other environment variables in the current terminal
source ./emsdk_env.sh
</code></pre>
<h1 id="2--测试"><a class="header" href="#2--测试">2.  测试</a></h1>
<pre><code class="language-shell">mkdir hello
cd hello
touch hello.c
</code></pre>
<pre><code class="language-c++">#include &lt;stdio.h&gt;
int main(int argc, char ** argv) {
    printf(&quot;Hello, world!&quot;);
}
</code></pre>
<pre><code class="language-shell"># 编译
emcc ./hello.c -s WASM=1 -s EXIT_RUNTIME=1 -o hello.html

# WASM=1 :表示生成wasm格式文件而不是asm格式文件，目前新版本默认就是wasm
# EXIT_RUNTIME=1:编译出的wasm默认情况下不会退出运行的，这是web情况下期待的方式，主程序main虽然运行结束了，但模块没有退出，静态变量可以保持在内存中，不释放。同时标准 I/O 缓冲区没有被flush，加此参数则能让模块结束，才能看到I/O输出，否则无法看到printf的输出
# o:输出文件格式
# O:是用来指定优化级别，优化级别有 -O0, -O1, -O2, -O3 -Os这五种级别。不指定是为 -O0, 即没有优化，开发时一般指定为 -O0 或 -O1， 这样编译速度快，调试方便。 正式发布时可以是 -O2 或 -O3，这时代码会优化，执行更快。-Os 不光是执行快，同时优化大小，可生成更小的执行文件。
# 执行后目录下会生成hello.html hello.js 和hello.wasm三个文件。
</code></pre>
<pre><code class="language-shell"># 运行
emrun --no_browser --port 8080 .

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="工具-1"><a class="header" href="#工具-1">工具</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gparted"><a class="header" href="#gparted">gparted</a></h1>
<h1 id="1-安装-1"><a class="header" href="#1-安装-1">1. 安装</a></h1>
<pre><code class="language-shell">apt install gparted
</code></pre>
<h1 id="2-系统盘扩容"><a class="header" href="#2-系统盘扩容">2. 系统盘扩容</a></h1>
<h2 id="21-提示系统盘只读"><a class="header" href="#21-提示系统盘只读">2.1 提示系统盘只读</a></h2>
<pre><code class="language-shell">sudo -i
mount -o remount -rw /
mount -o remount -rw /var/snap/firefox/common/host-hunspell # 挂载点 ,可以在info中查看
# 刷新后可以扩容
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ros2"><a class="header" href="#ros2">ROS2</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ros2_qt_demo"><a class="header" href="#ros2_qt_demo">ros2_qt_demo</a></h1>
<h1 id="1-生成qt5和ros2同名项目"><a class="header" href="#1-生成qt5和ros2同名项目">1. 生成qt5和ros2同名项目</a></h1>
<pre><code class="language-shell"># qtcreator 创建 名称为 ros2_qt_demo
# ros2 创建
mkdir ros2_ws
cd ros2_ws
mkdir src
ros2 pkg create --build-type ament_cmake ros2_qt_demo
mkdir ui # mainwindow.ui
mkdir resource # NULL
mkdir src  # main.cpp mainwindow.cpp
rm include/* # mainwindow.h
</code></pre>
<h1 id="2-合并cmakelisttxt"><a class="header" href="#2-合并cmakelisttxt">2. 合并CMakeList.txt</a></h1>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.8)
project(ros2_qt_demo)

if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES &quot;Clang&quot;)
  add_compile_options(-Wall -Wextra -Wpedantic)
endif()
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# find dependencies
find_package(ament_cmake REQUIRED)
find_package(QT NAMES Qt6 Qt5 REQUIRED COMPONENTS Widgets)
find_package(Qt${QT_VERSION_MAJOR} REQUIRED COMPONENTS Widgets)

# uncomment the following section in order to fill in
# further dependencies manually.
# find_package(&lt;dependency&gt; REQUIRED)

file(GLOB PRO_SRC_DIR RELATIVE ${CMAKE_SOURCE_DIR} FOLLOW_SYMLINKS src/*.cpp)
file(GLOB PRO_INCLUDE_DIR RELATIVE ${CMAKE_SOURCE_DIR} FOLLOW_SYMLINKS include/*.h *.hpp)
file(GLOB PRO_UI_DIR RELATIVE ${CMAKE_SOURCE_DIR} FOLLOW_SYMLINKS ui/*.ui)
file(GLOB PRO_RES_DIR RELATIVE ${CMAKE_SOURCE_DIR} FOLLOW_SYMLINKS resource/*.qrc)
qt5_wrap_ui(QT_UI_HPP ${PRO_UI_DIR})
qt5_wrap_cpp(QT_MOC_HPP ${PRO_INCLUDE_DIR})
qt5_add_resources(QT_RES_HPP ${PRO_RES_DIR})
include_directories(
	include/
	${CMAKE_CURRENT_BINARY_DIR}
)
add_executable(${PROJECT_NAME}
            ${PRO_SRC_DIR}
            ${PRO_INCLUDE_DIR}
            ${PRO_UI_DIR}
            # ${PRO_RES_DIR}
            ${QT_UI_HPP}
            ${QT_MOC_HPP}
            ${QT_RES_HPP}
        )

target_link_libraries(${PROJECT_NAME} PRIVATE Qt${QT_VERSION_MAJOR}::Widgets)
install(TARGETS ${PROJECT_NAME} DESTINATION lib/${PROJECT_NAME})
 
if(BUILD_TESTING)
  find_package(ament_lint_auto REQUIRED)
  # the following line skips the linter which checks for copyrights
  # comment the line when a copyright and license is added to all source files
  set(ament_cmake_copyright_FOUND TRUE)
  # the following line skips cpplint (only works in a git repo)
  # comment the line when this package is in a git repo and when
  # a copyright and license is added to all source files
  set(ament_cmake_cpplint_FOUND TRUE)
  ament_lint_auto_find_test_dependencies()
endif()
if(QT_VERSION_MAJOR EQUAL 6)
    qt_finalize_executable(ros2_qt_demo)
endif()
ament_package()

</code></pre>
<h1 id="3-qtcreator-使用"><a class="header" href="#3-qtcreator-使用">3. qtcreator 使用</a></h1>
<pre><code class="language-shell"># 需要进入到qtcreator的安装目录 使用终端打开
# 原因是 需要加载ros2的环境 # ~/.bashrc里面的
</code></pre>
<h1 id="4-coclon-使用"><a class="header" href="#4-coclon-使用">4. coclon 使用</a></h1>
<pre><code class="language-shell"># 安装
sudo apt install python3-colcon-common-extensions
# ros2_ws 目录
coclon build
source install/setup.sh
coclon run ros2_qt_demo ros2_qt_demo
# 也可以使用qtcreator打开,方法同3
</code></pre>
<h1 id="5-新建文件"><a class="header" href="#5-新建文件">5. 新建文件</a></h1>
<h2 id="51-通过qtcreator创建文件后需要将对应的hcppui-文件放入到具体的includesrcresource-文件夹中"><a class="header" href="#51-通过qtcreator创建文件后需要将对应的hcppui-文件放入到具体的includesrcresource-文件夹中">5.1 通过qtcreator创建文件后需要将对应的.h,.cpp,.ui 文件放入到具体的include,src,resource 文件夹中</a></h2>
<h2 id="52-新增之后需要到build目录手动执行cmake--之后qtcreator中才会刷新文件目录"><a class="header" href="#52-新增之后需要到build目录手动执行cmake--之后qtcreator中才会刷新文件目录">5.2 新增之后需要到build目录手动执行cmake .. ，之后qtcreator中才会刷新文件目录</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hass"><a class="header" href="#hass">HASS</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hass安装"><a class="header" href="#hass安装">HASS安装</a></h1>
<div style="break-before: page; page-break-before: always;"></div><p>PostgreSQL数据库的设计架构是高度复杂且灵活的，它支持广泛的数据类型和高级功能，包括事务完整性、并发控制、故障恢复和高度的可扩展性。PostgreSQL的设计架构可以分为几个关键组件：</p>
<h3 id="1-server-process-architecture"><a class="header" href="#1-server-process-architecture">1. Server Process Architecture</a></h3>
<ul>
<li><strong>Postmaster and Worker Processes</strong>: PostgreSQL采用一种客户端/服务器模型，其中主控进程(postmaster)负责接受连接请求，并为每个客户端连接创建一个新的工作进程(backend process)。这些工作进程独立处理客户端请求，从而提高了系统的并发能力和稳定性。</li>
</ul>
<h3 id="2-数据存储"><a class="header" href="#2-数据存储">2. 数据存储</a></h3>
<ul>
<li><strong>数据库文件</strong>：PostgreSQL将数据存储在文件系统中的文件里。每个数据库都有自己的目录，而每个表、索引等都存储在这些目录中的一个或多个文件中。</li>
<li><strong>表空间</strong>：允许数据库管理员定义数据文件的物理存储位置。这对于大型数据库系统的性能调优非常重要。</li>
</ul>
<h3 id="3-mvcc-多版本并发控制"><a class="header" href="#3-mvcc-多版本并发控制">3. MVCC (多版本并发控制)</a></h3>
<ul>
<li>PostgreSQL使用MVCC机制来支持高并发，允许多个事务同时读写数据库而不互相干扰。每个事务看到的是数据库在特定时间点的“快照”，这减少了锁的需要，提高了性能。</li>
</ul>
<h3 id="4-write-ahead-logging-wal"><a class="header" href="#4-write-ahead-logging-wal">4. Write-Ahead Logging (WAL)</a></h3>
<ul>
<li>WAL是PostgreSQL中实现故障恢复的关键技术。每次数据变更都会先写入WAL文件。在发生故障时，可以使用WAL文件恢复数据库，确保数据的完整性不受影响。</li>
</ul>
<h3 id="5-索引和搜索"><a class="header" href="#5-索引和搜索">5. 索引和搜索</a></h3>
<ul>
<li>PostgreSQL支持多种索引类型，包括B-树、GiST、GIN和BRIN等。这些索引支持快速数据检索和复杂查询，提高了数据库的查询性能。</li>
</ul>
<h3 id="6-插件和扩展"><a class="header" href="#6-插件和扩展">6. 插件和扩展</a></h3>
<ul>
<li>PostgreSQL支持通过插件和扩展来增强其功能。这包括额外的数据类型、索引类型、函数等。这种架构的灵活性使PostgreSQL能够适应各种不同的应用场景。</li>
</ul>
<h3 id="7-客户端服务器通信"><a class="header" href="#7-客户端服务器通信">7. 客户端/服务器通信</a></h3>
<ul>
<li>PostgreSQL使用SQL作为查询语言，并通过TCP/IP协议与客户端通信。它支持多种客户端连接选项，包括命令行工具、图形界面和编程语言接口。</li>
</ul>
<h3 id="8-安全性"><a class="header" href="#8-安全性">8. 安全性</a></h3>
<ul>
<li>PostgreSQL提供了强大的安全特性，包括角色和权限管理、SSL加密连接和行级安全等。</li>
</ul>
<h3 id="9-并行查询执行"><a class="header" href="#9-并行查询执行">9. 并行查询执行</a></h3>
<ul>
<li>为了进一步提高查询性能，PostgreSQL支持并行查询执行，能够在多个CPU核心上并行处理数据。</li>
</ul>
<p>这些组件和特性共同构成了PostgreSQL强大、灵活且可靠的数据库系统。设计时需要考虑数据的组织、索引策略、事务处理、备份和恢复策略以及安全性等因素，以满足应用的需求和性能目标。<img src="PostgreSQL//Users/cal/self/lmt%E6%B5%81%E5%AA%92%E4%BD%93/code/rust/book/src/PostgreSQL/PostgreSQL.png" alt="DALL·E 2024-03-02 14.17.22 - Create a detailed architectural diagram for PostgreSQL, showcasing its main components and their interactions. The diagram should include the Postmast" /></p>
<h1 id="详细介绍下-mvcc-多版本并发控制是如何工作的"><a class="header" href="#详细介绍下-mvcc-多版本并发控制是如何工作的">详细介绍下 MVCC (多版本并发控制)是如何工作的</a></h1>
<p>多版本并发控制（MVCC, Multi-Version Concurrency Control）是一种数据库管理技术，用于在不锁定数据库资源的情况下提供数据一致性和事务隔离。PostgreSQL等数据库系统使用MVCC来允许多个事务同时对数据库进行读写，而不会相互干扰，从而提高并发性能。以下是MVCC的工作原理的详细介绍：</p>
<h3 id="1-数据版本"><a class="header" href="#1-数据版本">1. 数据版本</a></h3>
<ul>
<li><strong>版本创建</strong>：每当数据行被更新时，系统不会直接覆盖旧数据，而是创建该行的一个新版本（即新的数据行）。因此，每个数据行都可以有多个版本，每个版本都对应于不同的事务更新。</li>
<li><strong>事务ID</strong>：系统给每个事务分配一个唯一的事务ID。当事务创建数据行的新版本时，这个新版本会被标记为由该事务创建。</li>
</ul>
<h3 id="2-隔离级别与可见性"><a class="header" href="#2-隔离级别与可见性">2. 隔离级别与可见性</a></h3>
<ul>
<li><strong>事务的可见性规则</strong>：数据库根据事务的隔离级别和版本信息来确定一个事务是否可以看到数据的某个版本。基本规则是，一个事务可以看到由早于该事务开始的事务创建的数据行版本，但看不到由晚于该事务开始的事务创建的版本。</li>
<li><strong>隔离级别</strong>：不同的隔离级别（读未提交、读已提交、可重复读、串行化）影响可见性判断的细节。例如，在“读已提交”隔离级别下，一个事务可以看到其他已提交事务所做的更改。</li>
</ul>
<h3 id="3-并发操作"><a class="header" href="#3-并发操作">3. 并发操作</a></h3>
<ul>
<li><strong>读操作</strong>：读操作总是查找对当前事务可见的最新版本的数据行。这意味着事务可以读取数据而不阻塞其他事务的写操作。</li>
<li><strong>写操作</strong>：当事务更新数据时，它创建新的数据版本而不是直接修改现有数据。这样，其他事务仍然可以访问旧版本的数据，直到它们准备好看到新版本为止。</li>
</ul>
<h3 id="4-垃圾回收vacuuming"><a class="header" href="#4-垃圾回收vacuuming">4. 垃圾回收（Vacuuming）</a></h3>
<ul>
<li><strong>版本清理</strong>：随着时间的推移，数据库中会积累很多旧版本的数据行，这些数据行对当前和未来的事务不再可见。PostgreSQL通过一个称为“垃圾回收”的过程清理这些旧版本，释放空间并优化性能。</li>
<li><strong>冻结旧版本</strong>：在某些情况下，为了避免事务ID的回绕，系统会“冻结”旧数据版本，使其对所有事务永久可见。</li>
</ul>
<p>通过以上机制，MVCC支持高度的并发操作，同时保持事务的隔离性和数据库的一致性。MVCC使得读操作无需等待写操作完成，大大提高了数据库系统的性能和可用性。</p>
<h1 id="详细介绍下-write-ahead-logging-wal是如何工作的"><a class="header" href="#详细介绍下-write-ahead-logging-wal是如何工作的">详细介绍下 Write-Ahead Logging (WAL)是如何工作的</a></h1>
<p>Write-Ahead Logging（WAL）是一种用于确保数据库在发生故障时能够恢复到最后一致状态的技术。这是通过先写日志，后更新实际数据来实现的，因此得名“预写日志”。WAL是许多数据库系统，包括PostgreSQL，用于实现事务持久性和崩溃恢复的关键组成部分。以下是WAL工作原理的详细介绍：</p>
<h3 id="1-日志记录"><a class="header" href="#1-日志记录">1. 日志记录</a></h3>
<ul>
<li><strong>日志条目</strong>：在对数据库进行任何修改之前，系统首先在WAL文件中记录下这些修改的详细内容。这些记录被称为日志条目，包括足够的信息来重做（redo）或撤销（undo）这些修改。</li>
<li><strong>顺序写入</strong>：日志条目以顺序的方式写入到WAL文件中。由于磁盘的顺序写入比随机写入速度快很多，这种方式提高了系统的写入性能。</li>
</ul>
<h3 id="2-数据写入"><a class="header" href="#2-数据写入">2. 数据写入</a></h3>
<ul>
<li><strong>脏页写回</strong>：在日志条目成功记录到WAL后，数据库才开始将修改应用到实际的数据文件中。这些还未写入磁盘的修改后数据页被称为“脏页”。</li>
<li><strong>检查点</strong>：定期地，数据库会创建一个“检查点”，此时，它会将所有脏页写入磁盘，并记录当前的检查点信息到WAL中。检查点帮助减少恢复时间，因为在恢复时只需要处理最后一个检查点之后的日志记录。</li>
</ul>
<h3 id="3-崩溃恢复"><a class="header" href="#3-崩溃恢复">3. 崩溃恢复</a></h3>
<ul>
<li><strong>重做（Redo）操作</strong>：当数据库系统启动时，如果检测到之前发生了崩溃，它会使用WAL文件中的日志条目来重做那些已经被记录但可能还没有被写入到数据文件中的修改。</li>
<li><strong>撤销（Undo）操作</strong>：如果在崩溃时有未完成的事务，系统还会使用WAL中的信息来撤销这些事务的影响，确保数据库的一致性。</li>
</ul>
<h3 id="4-wal的优势"><a class="header" href="#4-wal的优势">4. WAL的优势</a></h3>
<ul>
<li><strong>数据完整性</strong>：通过确保在实际修改数据之前先记录日志，WAL提高了数据库在系统崩溃情况下的数据完整性和可恢复性。</li>
<li><strong>性能提升</strong>：由于WAL允许数据库延迟脏页的写回操作，而且利用了磁盘的顺序写入性能优势，因此可以在不牺牲数据安全的前提下提升写入性能。</li>
<li><strong>并发控制</strong>：WAL还支持高效的并发控制，因为读取操作不会被写入操作所阻塞，从而提高了数据库的整体并发性能。</li>
</ul>
<p>WAL是现代数据库管理系统中保证数据安全、提高性能的关键技术之一，特别是在处理大量事务和需要保证高可用性的环境中显示出其重要价值。</p>
<h1 id="基础知识"><a class="header" href="#基础知识">基础知识</a></h1>
<h1 id="什么是postgresql它与其他数据库管理系统有何不同"><a class="header" href="#什么是postgresql它与其他数据库管理系统有何不同">什么是PostgreSQL？它与其他数据库管理系统有何不同？</a></h1>
<ul>
<li>
<p>探讨PostgreSQL的特点，如开源性、遵循SQL标准、支持高级数据类型和函数等。</p>
</li>
<li>
<p>PostgreSQL是一款高度先进的开源对象关系型数据库管理系统（ORDBMS）。它是以健壯、稳定和性能为目标，支持SQL语言（结构化查询语言）和丰富的SQL集合。PostgreSQL以其可扩展性、高度的并发性能、以及对复杂查询、事务、和安全特性的支持而闻名。以下是PostgreSQL与其他数据库管理系统相比的几个关键区别：</p>
<h3 id="1-开源与社区支持"><a class="header" href="#1-开源与社区支持">1. 开源与社区支持</a></h3>
<ul>
<li><strong>开源</strong>：PostgreSQL是完全开源的，允许用户自由使用、修改和分发。它有一个活跃的社区，不断地改进和添加新功能。</li>
<li><strong>社区驱动</strong>：与一些商业数据库如Oracle、SQL Server相比，PostgreSQL的发展更依赖于其社区，而不是单一的商业实体。</li>
</ul>
<h3 id="2-高级特性和标准的遵循"><a class="header" href="#2-高级特性和标准的遵循">2. 高级特性和标准的遵循</a></h3>
<ul>
<li><strong>SQL标准遵循</strong>：PostgreSQL严格遵循SQL标准，并支持许多先进的SQL特性，包括窗口函数、公用表表达式（CTEs）、外键、子查询等。</li>
<li><strong>高级数据类型</strong>：它支持多种高级数据类型，如JSON/JSONB、数组、hstore（键值对存储）和自定义类型，为用户提供了高度的灵活性来设计数据库。</li>
</ul>
<h3 id="3-扩展性和可定制性"><a class="header" href="#3-扩展性和可定制性">3. 扩展性和可定制性</a></h3>
<ul>
<li><strong>扩展插件</strong>：PostgreSQL可以通过插件和扩展来增加新的功能，如PostGIS扩展添加了对地理空间数据的支持。</li>
<li><strong>自定义函数</strong>：它允许使用多种编程语言（如PL/pgSQL、C、Python、Perl等）编写存储过程和函数，提供了极大的灵活性。</li>
</ul>
<h3 id="4-并发控制和可靠性"><a class="header" href="#4-并发控制和可靠性">4. 并发控制和可靠性</a></h3>
<ul>
<li><strong>MVCC（多版本并发控制）</strong>：PostgreSQL通过MVCC提高了并发性，允许多个事务同时进行，而不互相干扰，减少了锁的需要。</li>
<li><strong>Write-Ahead Logging（WAL）</strong>：使用WAL技术确保数据的持久性和恢复能力，即使在系统崩溃的情况下也能保护数据不丢失。</li>
</ul>
<h3 id="5-复制和分区"><a class="header" href="#5-复制和分区">5. 复制和分区</a></h3>
<ul>
<li><strong>复制功能</strong>：PostgreSQL支持同步和异步复制，以提高数据的可用性和灾难恢复能力。</li>
<li><strong>表分区</strong>：支持表分区，帮助管理大量数据，提高查询性能和维护的便利性。</li>
</ul>
<h3 id="6-安全性"><a class="header" href="#6-安全性">6. 安全性</a></h3>
<ul>
<li><strong>细粒度的访问控制</strong>：提供了强大的安全机制，包括角色基础的权限系统、行级安全策略和强制的SSL连接，以保护数据安全。</li>
</ul>
<p>相比其他数据库系统，PostgreSQL特别适合需要高度可靠性、强大数据处理能力和灵活性的应用场景。无论是在金融服务、地理信息系统（GIS）、数据仓库还是其他需要复杂数据分析的领域，PostgreSQL都是一个非常受欢迎的选择。</p>
</li>
</ul>
<h1 id="postgresql中的事务是如何工作的"><a class="header" href="#postgresql中的事务是如何工作的">PostgreSQL中的事务是如何工作的？</a></h1>
<ul>
<li>
<p>解释事务的概念、ACID属性、以及PostgreSQL如何实现这些属性。</p>
<p>在PostgreSQL中，事务是一组操作序列，这些操作作为一个单一的工作单元执行，要么全部成功要么全部失败，保证了数据库的完整性和一致性。PostgreSQL的事务遵循ACID原则，即原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。下面是PostgreSQL中事务工作的详细说明：</p>
<h3 id="原子性atomicity"><a class="header" href="#原子性atomicity">原子性（Atomicity）</a></h3>
<ul>
<li><strong>原子性</strong>保证了事务中的操作要么全部完成，要么全部不完成。如果事务中的一个操作失败，整个事务会被回滚，数据库状态回到事务开始之前的状态。</li>
</ul>
<h3 id="一致性consistency"><a class="header" href="#一致性consistency">一致性（Consistency）</a></h3>
<ul>
<li><strong>一致性</strong>确保事务从一个一致的状态转换到另一个一致的状态。即使在并发环境下，事务执行后，数据库的完整性约束仍然得到满足。</li>
</ul>
<h3 id="隔离性isolation"><a class="header" href="#隔离性isolation">隔离性（Isolation）</a></h3>
<ul>
<li><strong>隔离性</strong>指的是在并发环境中，事务的执行互不干扰，每个事务都是在独立的环境中执行。PostgreSQL通过多版本并发控制（MVCC）来实现事务的隔离性，它允许事务看到数据库在特定时间点的“快照”，而不是实时的、正在被其他事务修改的数据。</li>
<li>PostgreSQL提供了几种隔离级别：读未提交（Read Uncommitted）、读已提交（Read Committed）、可重复读（Repeatable Read）和串行化（Serializable）。这些隔离级别提供了不同级别的隔离，以满足不同应用场景的需求。</li>
</ul>
<h3 id="持久性durability"><a class="header" href="#持久性durability">持久性（Durability）</a></h3>
<ul>
<li><strong>持久性</strong>确保一旦事务提交，它对数据库的修改就是永久的，即使发生系统崩溃或电源故障。PostgreSQL通过Write-Ahead Logging（WAL）机制实现事务的持久性。在修改数据之前，事务的所有变更都会先写入到WAL日志中。只有在WAL日志成功记录后，这些修改才会应用到数据库中。在系统重启后，WAL日志可以用来恢复未完成的事务，确保数据的一致性和完整性。</li>
</ul>
<h3 id="事务的操作"><a class="header" href="#事务的操作">事务的操作</a></h3>
<ul>
<li>
<p>在PostgreSQL中，可以使用<code>BEGIN</code>命令开始一个事务，使用<code>COMMIT</code>命令提交事务，或使用<code>ROLLBACK</code>命令回滚事务。</p>
</li>
<li>
<p>例如：</p>
<pre><code class="language-sql">BEGIN;
-- 事务中的SQL操作...
COMMIT; -- 或 ROLLBACK;
</code></pre>
</li>
</ul>
<p>通过这种方式，PostgreSQL中的事务支持复杂的业务逻辑，确保数据的安全性和一致性，即使在高并发的环境下也能保持高性能和稳定性。</p>
</li>
</ul>
<h1 id="解释postgresql中的mvcc多版本并发控制机制"><a class="header" href="#解释postgresql中的mvcc多版本并发控制机制">解释PostgreSQL中的MVCC（多版本并发控制）机制。</a></h1>
<ul>
<li>
<p>讨论MVCC如何允许数据库进行高效的并发控制，以及它是如何工作的。</p>
<p>多版本并发控制（MVCC, Multi-Version Concurrency Control）是PostgreSQL中用来实现高并发和事务隔离的核心机制。MVCC允许数据库在保持事务隔离性的同时，提高并发访问的性能。这是通过为数据对象创建版本（即数据的不同状态）来实现的，每个事务看到的是数据库在特定时间点的快照，而不是实时的、正在被其他事务修改的数据。这样，读操作不会阻塞写操作，写操作也不会阻塞读操作，大大提高了数据库系统的并发能力。下面是MVCC在PostgreSQL中工作原理的详细解释：</p>
<h3 id="数据版本"><a class="header" href="#数据版本">数据版本</a></h3>
<p>每当数据行被修改（如通过INSERT、UPDATE或DELETE操作）时，PostgreSQL并不是直接在原始数据上进行修改。相反，它会创建数据的一个新版本：</p>
<ul>
<li><strong>INSERT</strong>：插入一条新记录时，PostgreSQL会创建这条记录的一个版本，这个版本从事务开始直到事务提交都只对该事务可见。</li>
<li><strong>UPDATE</strong>：更新操作会创建一条记录的新版本，同时保留旧版本的数据。新版本对写入数据的事务可见，而其他事务根据它们的开始时间和隔离级别，可能看到旧版本。</li>
<li><strong>DELETE</strong>：删除操作标记一条记录的当前版本为不可见，而实际上并不从物理存储中立即移除这条记录。</li>
</ul>
<h3 id="事务id和时间戳"><a class="header" href="#事务id和时间戳">事务ID和时间戳</a></h3>
<p>PostgreSQL给每个事务分配一个唯一的事务ID。这个ID不仅标识了事务，还用来记录数据版本是在哪个事务中创建的。每个数据版本都有两个关键的时间戳或事务ID属性：</p>
<ul>
<li><strong>xmin</strong>：创建当前版本的事务ID。</li>
<li><strong>xmax</strong>：使当前版本变为不可见的事务ID（例如，被删除或被更新）。</li>
</ul>
<h3 id="隔离级别和可见性规则"><a class="header" href="#隔离级别和可见性规则">隔离级别和可见性规则</a></h3>
<p>MVCC使得PostgreSQL可以提供多种事务隔离级别，包括读未提交（Read Uncommitted）、读已提交（Read Committed）、可重复读（Repeatable Read）和串行化（Serializable）。这些隔离级别通过控制事务可以看到哪些数据版本来实现：</p>
<ul>
<li><strong>读已提交</strong>：事务只能看到在它开始之前已经被提交的事务所做的更改。</li>
<li><strong>可重复读和串行化</strong>：在这些隔离级别下，事务可以看到在它开始时数据库的一致性视图，即使在事务执行期间其他事务提交了更新。</li>
</ul>
<h3 id="垃圾收集vacuum"><a class="header" href="#垃圾收集vacuum">垃圾收集（Vacuum）</a></h3>
<p>由于MVCC会创建大量的数据版本，PostgreSQL需要定期清理那些不再被任何事务需要的旧数据版本。这通过一个称为Vacuum的过程完成，它有两个主要目的：</p>
<ul>
<li><strong>回收空间</strong>：删除不再可达的数据版本，释放存储空间。</li>
<li><strong>防止事务ID回绕</strong>：更新数据版本的系统列，以防止事务ID耗尽。</li>
</ul>
<p>MVCC是PostgreSQL实现高效并发控制的基石，它通过允许事务在不同时间点看到数据库的不同“快照”，从而实现了对读写操作的非阻塞并发。</p>
</li>
</ul>
<h1 id="高级特性"><a class="header" href="#高级特性">高级特性</a></h1>
<h1 id="postgresql的索引类型有哪些举例说明它们各自的用途"><a class="header" href="#postgresql的索引类型有哪些举例说明它们各自的用途">PostgreSQL的索引类型有哪些？举例说明它们各自的用途。</a></h1>
<ul>
<li>
<p>描述B-Tree、GiST、GIN、BRIN等索引类型及其适用场景。</p>
<p>PostgreSQL提供了多种索引类型，以支持不同的数据检索需求和优化查询性能。每种索引类型都有其特定的用途和适用场景。以下是PostgreSQL中常见的几种索引类型及其用途：</p>
<h3 id="1-b-tree-索引"><a class="header" href="#1-b-tree-索引">1. B-Tree 索引</a></h3>
<ul>
<li><strong>用途</strong>：B-Tree（平衡树）索引是最常用的索引类型，适用于等值查询和范围查询。它们能够高效地处理<code>=</code>、<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code>操作符。</li>
<li><strong>示例</strong>：如果经常需要检索特定客户的订单或查找在特定日期范围内的订单，B-Tree索引将非常适用。</li>
</ul>
<h3 id="2-hash-索引"><a class="header" href="#2-hash-索引">2. Hash 索引</a></h3>
<ul>
<li><strong>用途</strong>：Hash索引基于哈希表实现，适用于等值比较查询。它的优势在于快速查找，但不支持范围查询。</li>
<li><strong>示例</strong>：适用于查找特定的值，如检索具有特定状态代码的记录。</li>
</ul>
<h3 id="3-gistgeneralized-search-tree索引"><a class="header" href="#3-gistgeneralized-search-tree索引">3. GiST（Generalized Search Tree）索引</a></h3>
<ul>
<li><strong>用途</strong>：GiST是一种可扩展的索引类型，支持多种数据类型的搜索，包括地理空间数据、数组和全文搜索等。它是一种通用的搜索树框架，支持各种复杂查询。</li>
<li><strong>示例</strong>：在地理信息系统（GIS）应用中，GiST索引可以用来快速查找特定区域内的地理位置。</li>
</ul>
<h3 id="4-gingeneralized-inverted-index索引"><a class="header" href="#4-gingeneralized-inverted-index索引">4. GIN（Generalized Inverted Index）索引</a></h3>
<ul>
<li><strong>用途</strong>：GIN索引适用于包含多个组成元素的值，如数组、JSONB和全文搜索。它是为处理多值匹配查询而优化的，特别适合全文搜索和包含操作。</li>
<li><strong>示例</strong>：对JSONB字段进行索引以快速查询满足特定条件的文档，或对文本数据应用全文搜索。</li>
</ul>
<h3 id="5-brinblock-range-index索引"><a class="header" href="#5-brinblock-range-index索引">5. BRIN（Block Range INdex）索引</a></h3>
<ul>
<li><strong>用途</strong>：BRIN索引适用于大量数据且数据有序的情况，通过索引数据块（而不是单个行）来提高查询性能，适合范围查询。BRIN索引在存储空间和索引创建时间上更加高效，但它依赖于数据的物理排序。</li>
<li><strong>示例</strong>：对按日期排序存储的大量日志数据进行索引，以快速找到特定日期范围的日志。</li>
</ul>
<h3 id="6-sp-gistspace-partitioned-generalized-search-tree索引"><a class="header" href="#6-sp-gistspace-partitioned-generalized-search-tree索引">6. SP-GiST（Space-Partitioned Generalized Search Tree）索引</a></h3>
<ul>
<li><strong>用途</strong>：SP-GiST支持空间划分的数据结构，适合那些可以分割成不相交区域的数据类型。它为某些类型的空间和树状结构数据提供了高效的搜索算法。</li>
<li><strong>示例</strong>：用于对具有层次结构的数据进行索引，如地理空间数据的k近邻搜索。</li>
</ul>
<p>每种索引类型都针对特定的查询类型或数据模式提供了优化，选择合适的索引类型可以显著提高查询性能和数据检索效率。在实践中，了解和选择最适合应用需求的索引类型是优化PostgreSQL数据库性能的关键步骤。</p>
</li>
</ul>
<h1 id="解释write-ahead-loggingwal在postgresql中的作用"><a class="header" href="#解释write-ahead-loggingwal在postgresql中的作用">解释Write-Ahead Logging（WAL）在PostgreSQL中的作用。</a></h1>
<ul>
<li>
<p>讨论WAL如何保证数据库的持久性和崩溃后的恢复。</p>
<p>Write-Ahead Logging（WAL）是PostgreSQL中用于确保数据库完整性和恢复能力的关键技术。WAL的主要目的是在数据实际写入数据库文件之前，先将所有的修改记录到日志中。这种机制使得PostgreSQL能够在发生系统崩溃或电源故障等异常情况后，恢复到最后一致的状态，保证了数据的完整性和持久性。以下是WAL在PostgreSQL中的作用详解：</p>
<h3 id="1-数据的持久性保证"><a class="header" href="#1-数据的持久性保证">1. 数据的持久性保证</a></h3>
<p>在对数据库进行任何修改（如插入、更新或删除操作）之前，这些修改会先被写入到WAL文件中。只有当这些修改记录成功写入WAL后，这些操作才会被应用到数据库文件中。这保证了即使在操作过程中发生崩溃，所有已经记录到WAL的修改都不会丢失，可以在数据库重启后通过重放WAL日志来恢复。</p>
<h3 id="2-支持数据库的故障恢复"><a class="header" href="#2-支持数据库的故障恢复">2. 支持数据库的故障恢复</a></h3>
<p>在数据库启动过程中，如果检测到之前发生了崩溃，PostgreSQL会自动执行恢复过程。它通过读取WAL日志中的记录，重做（redo）所有已经提交但未写入数据库文件的事务，同时撤销（undo）所有在崩溃时未完成的事务。这样确保了数据库能够恢复到最后一致的状态。</p>
<h3 id="3-实现事务的原子性和持久性"><a class="header" href="#3-实现事务的原子性和持久性">3. 实现事务的原子性和持久性</a></h3>
<p>WAL是实现ACID事务特性中的原子性（Atomicity）和持久性（Durability）的机制。通过先记录日志确保了即使在事务执行过程中发生故障，事务的所有修改要么完全应用，要么完全不应用（原子性），并且一旦事务提交，它的修改就会被永久保存（持久性）。</p>
<h3 id="4-支持高效的并发和恢复"><a class="header" href="#4-支持高效的并发和恢复">4. 支持高效的并发和恢复</a></h3>
<p>使用WAL允许PostgreSQL在不直接锁定数据库文件的情况下，进行高效的数据写入和并发控制。同时，由于WAL记录了所有的数据变更，这使得数据库的恢复过程变得高效，尤其是在处理大量数据时。</p>
<h3 id="5-基础支持数据库复制"><a class="header" href="#5-基础支持数据库复制">5. 基础支持数据库复制</a></h3>
<p>WAL还是实现数据库复制的基础。通过流式传输或定期同步WAL日志到备份服务器，可以实现主从复制、读写分离等高可用性和灾难恢复方案。备份服务器可以实时地或者根据调度重放WAL日志，确保与主数据库的数据一致性。</p>
<p>WAL机制是PostgreSQL高可靠性和强大恢复能力的基石，通过确保事务日志的先行写入，它为数据库提供了强大的数据保护、故障恢复和高可用性支持。</p>
</li>
</ul>
<h1 id="如何在postgresql中实现数据备份与恢复"><a class="header" href="#如何在postgresql中实现数据备份与恢复">如何在PostgreSQL中实现数据备份与恢复？</a></h1>
<ul>
<li>
<p>描述物理备份（如基于文件的备份、WAL日志备份）和逻辑备份的方法。</p>
<p>在PostgreSQL中，数据备份和恢复是保证数据安全性和可靠性的关键操作。PostgreSQL提供了多种备份和恢复方法，以满足不同的需求和场景。以下是主要的备份与恢复策略：</p>
<h3 id="1-sql转储pg_dump和pg_dumpall"><a class="header" href="#1-sql转储pg_dump和pg_dumpall">1. SQL转储（pg_dump和pg_dumpall）</a></h3>
<h4 id="备份"><a class="header" href="#备份">备份</a></h4>
<ul>
<li><strong>pg_dump</strong>：用于备份单个数据库。它生成一个包含数据库数据的SQL脚本文件，可用于数据库的完全恢复。</li>
<li><strong>pg_dumpall</strong>：用于备份整个PostgreSQL服务器，包括所有数据库和全局对象（如角色和表空间）。它同样生成一个SQL脚本文件。</li>
</ul>
<h4 id="恢复"><a class="header" href="#恢复">恢复</a></h4>
<ul>
<li>将pg_dump或pg_dumpall生成的SQL脚本文件使用psql命令或其他SQL接口执行，来恢复数据库或服务器状态。</li>
</ul>
<h3 id="2-文件系统级备份"><a class="header" href="#2-文件系统级备份">2. 文件系统级备份</a></h3>
<h4 id="备份-1"><a class="header" href="#备份-1">备份</a></h4>
<ul>
<li>直接复制数据库文件系统上的数据文件。这通常需要在数据库停机或者以一致的状态运行（如使用文件系统快照）时进行，以确保数据的一致性。</li>
</ul>
<h4 id="恢复-1"><a class="header" href="#恢复-1">恢复</a></h4>
<ul>
<li>将备份的文件直接复制回原位置，或者在新的服务器上部署这些文件。</li>
</ul>
<h3 id="3-持续归档和点对点恢复pitr"><a class="header" href="#3-持续归档和点对点恢复pitr">3. 持续归档和点对点恢复（PITR）</a></h3>
<h4 id="备份-2"><a class="header" href="#备份-2">备份</a></h4>
<ul>
<li><strong>配置WAL归档</strong>：通过配置PostgreSQL来记录WAL日志，并定期将WAL文件转移到安全的备份位置。</li>
<li><strong>基础备份</strong>：使用pg_basebackup工具或文件系统级备份来创建数据库的基础状态备份。</li>
</ul>
<h4 id="恢复-2"><a class="header" href="#恢复-2">恢复</a></h4>
<ul>
<li>使用基础备份恢复数据库的初始状态，然后应用WAL归档文件直到恢复到所需的时间点。</li>
</ul>
<h3 id="4-逻辑复制"><a class="header" href="#4-逻辑复制">4. 逻辑复制</a></h3>
<h4 id="备份-3"><a class="header" href="#备份-3">备份</a></h4>
<ul>
<li><strong>逻辑复制</strong>不直接用于备份，但它可以用来在不同的系统间复制数据，实现实时的数据同步。</li>
</ul>
<h4 id="恢复-3"><a class="header" href="#恢复-3">恢复</a></h4>
<ul>
<li>通过设置逻辑复制订阅，可以从一个或多个发布服务器同步数据，以达到数据恢复或实时备份的目的。</li>
</ul>
<h3 id="备份和恢复的最佳实践"><a class="header" href="#备份和恢复的最佳实践">备份和恢复的最佳实践</a></h3>
<ul>
<li><strong>定期备份</strong>：根据数据的重要性和变更频率，制定定期备份的计划。</li>
<li><strong>验证备份</strong>：定期验证备份的完整性和恢复能力。</li>
<li><strong>离线存储</strong>：将重要备份存储在离线或远程位置，以防止数据丢失或损坏。</li>
<li><strong>使用WAL归档</strong>：对于需要最小化数据丢失风险的环境，配置WAL归档和qw点对点恢复（PITR）是非常重要的。</li>
</ul>
<p>通过上述方法，PostgreSQL数据库管理员可以根据具体需求选择合适的备份和恢复策略，确保数据的安全和业务的连续性。</p>
</li>
</ul>
<h1 id="性能优化"><a class="header" href="#性能优化">性能优化</a></h1>
<h1 id="如何优化postgresql的查询性能"><a class="header" href="#如何优化postgresql的查询性能">如何优化PostgreSQL的查询性能？</a></h1>
<ul>
<li>
<p>探讨索引的使用、查询计划的分析与调整、配置参数优化等策略。</p>
<p>优化PostgreSQL的查询性能是确保数据库响应迅速和资源使用高效的关键。以下是一些常用的优化策略：</p>
<h3 id="1-使用合适的索引"><a class="header" href="#1-使用合适的索引">1. 使用合适的索引</a></h3>
<ul>
<li><strong>创建索引</strong>：对经常作为查询条件的列创建索引可以显著提高查询速度。了解不同类型的索引（如B-Tree、GiST、GIN等）和它们的适用场景。</li>
<li><strong>索引维护</strong>：定期重新构建（REINDEX）或分析（ANALYZE）索引以保持其性能。</li>
</ul>
<h3 id="2-优化查询语句"><a class="header" href="#2-优化查询语句">2. 优化查询语句</a></h3>
<ul>
<li><strong>简化查询</strong>：避免复杂的子查询和多表连接，尽可能使用简单的查询语句。</li>
<li><strong>减少返回数据量</strong>：只返回需要的列和行，使用LIMIT语句限制返回结果的数量。</li>
<li><strong>使用适当的JOIN类型</strong>：了解不同JOIN类型（如INNER JOIN、LEFT JOIN等）的性能影响，并选择最合适的。</li>
</ul>
<h3 id="3-使用explain分析查询"><a class="header" href="#3-使用explain分析查询">3. 使用EXPLAIN分析查询</a></h3>
<ul>
<li><strong>查询计划分析</strong>：使用EXPLAIN命令查看查询的执行计划，分析可能的性能瓶颈。</li>
<li><strong>优化执行计划</strong>：根据EXPLAIN提供的信息调整查询语句或索引策略，以优化执行计划。</li>
</ul>
<h3 id="4-调整数据库配置"><a class="header" href="#4-调整数据库配置">4. 调整数据库配置</a></h3>
<ul>
<li><strong>内存分配</strong>：调整<code>shared_buffers</code>、<code>work_mem</code>、<code>maintenance_work_mem</code>等参数，以合理分配内存资源。</li>
<li><strong>并发控制</strong>：调整<code>max_connections</code>和<code>max_worker_processes</code>等参数，管理数据库的并发能力。</li>
<li><strong>WAL配置</strong>：调整WAL相关参数（如<code>wal_buffers</code>、<code>checkpoint_segments</code>等）以优化事务处理性能和恢复速度。</li>
</ul>
<h3 id="5-利用分区表"><a class="header" href="#5-利用分区表">5. 利用分区表</a></h3>
<ul>
<li><strong>数据分区</strong>：对大型表进行分区，将数据分布到不同的子表中。这可以提高查询性能和数据维护效率。</li>
</ul>
<h3 id="6-使用连接池"><a class="header" href="#6-使用连接池">6. 使用连接池</a></h3>
<ul>
<li><strong>减少连接开销</strong>：使用连接池技术可以减少频繁打开和关闭数据库连接的开销，提高系统的并发处理能力。</li>
</ul>
<h3 id="7-定期维护数据库"><a class="header" href="#7-定期维护数据库">7. 定期维护数据库</a></h3>
<ul>
<li><strong>VACUUM和ANALYZE</strong>：定期执行VACUUM（清理未使用的数据空间）和ANALYZE（更新表的统计信息）操作，以保持数据库的健康状态和优化查询性能。</li>
</ul>
<h3 id="8-使用适当的数据类型"><a class="header" href="#8-使用适当的数据类型">8. 使用适当的数据类型</a></h3>
<ul>
<li><strong>选择最优数据类型</strong>：使用最合适的数据类型可以减少存储空间的占用，加快数据访问速度。</li>
</ul>
<p>通过综合运用这些策略，可以有效地优化PostgreSQL数据库的查询性能，确保应用的高效稳定运行。</p>
</li>
</ul>
<h1 id="在postgresql中如何监控和识别性能瓶颈"><a class="header" href="#在postgresql中如何监控和识别性能瓶颈">在PostgreSQL中，如何监控和识别性能瓶颈</a></h1>
<ul>
<li>
<p>讨论使用EXPLAIN命令分析查询计划、监控工具（如pg_stat_statements）等方法。</p>
<p>在PostgreSQL中监控和识别性能瓶颈是一项重要的任务，它帮助数据库管理员理解数据库的运行状态，发现并解决潜在的性能问题。以下是一些关键的监控和诊断方法：</p>
<h3 id="1-使用explain和explain-analyze"><a class="header" href="#1-使用explain和explain-analyze">1. 使用<code>EXPLAIN</code>和<code>EXPLAIN ANALYZE</code></a></h3>
<ul>
<li><strong>查询计划分析</strong>：<code>EXPLAIN</code>命令显示SQL语句的执行计划，而<code>EXPLAIN ANALYZE</code>命令实际执行SQL语句并显示执行计划和执行时间。这可以帮助识别查询中的性能瓶颈，如低效的索引使用或不必要的全表扫描。</li>
</ul>
<h3 id="2-查看系统和对象级别的统计信息"><a class="header" href="#2-查看系统和对象级别的统计信息">2. 查看系统和对象级别的统计信息</a></h3>
<ul>
<li><strong>pg_stat_all_tables</strong>：提供所有表的访问统计信息，包括顺序扫描次数、索引扫描次数、插入/更新/删除操作次数等。</li>
<li><strong>pg_stat_user_indexes</strong>：显示用户定义索引的使用情况和效率，帮助识别未使用或效率低下的索引。</li>
<li><strong>pg_stat_activity</strong>：显示当前数据库活动情况，包括运行的查询和锁等待情况，有助于发现长时间运行的查询和潜在的锁争用问题。</li>
</ul>
<h3 id="3-监控锁等待和死锁"><a class="header" href="#3-监控锁等待和死锁">3. 监控锁等待和死锁</a></h3>
<ul>
<li>PostgreSQL提供了多种锁，用于控制对数据库资源的并发访问。通过查询<code>pg_locks</code>视图和<code>pg_stat_activity</code>视图，可以监控锁等待和识别死锁情况。</li>
</ul>
<h3 id="4-使用日志文件"><a class="header" href="#4-使用日志文件">4. 使用日志文件</a></h3>
<ul>
<li><strong>配置日志记录</strong>：通过调整PostgreSQL的日志配置参数（如<code>log_min_duration_statement</code>），可以记录执行时间超过指定阈值的所有语句，以及死锁和锁等待信息。这些日志对于识别和分析性能问题非常有用。</li>
</ul>
<h3 id="5-使用性能监控工具"><a class="header" href="#5-使用性能监控工具">5. 使用性能监控工具</a></h3>
<ul>
<li><strong>pgBadger</strong>：一款强大的PostgreSQL日志分析器，可以分析查询执行时间、锁等待、错误和其他关键指标。</li>
<li><strong>pg_stat_statements</strong>：一个PostgreSQL扩展，提供了一个高级视图，汇总了执行过的所有SQL语句的统计信息，包括调用次数、总执行时间、行影响数等。</li>
<li><strong>外部监控工具</strong>：如Prometheus配合Grafana、Zabbix等，可以收集和展示PostgreSQL及其宿主机的性能指标。</li>
</ul>
<h3 id="6-分析操作系统和硬件资源使用"><a class="header" href="#6-分析操作系统和硬件资源使用">6. 分析操作系统和硬件资源使用</a></h3>
<ul>
<li>监控CPU、内存、磁盘I/O和网络I/O等资源使用情况，以确定是否存在硬件层面的瓶颈。</li>
</ul>
<p>通过综合运用这些方法和工具，数据库管理员可以有效地监控PostgreSQL的性能，及时发现并解决性能瓶颈，确保数据库系统的稳定和高效运行。</p>
</li>
</ul>
<h1 id="应用和维护"><a class="header" href="#应用和维护">应用和维护</a></h1>
<h1 id="postgresql支持哪些数据类型且如何选择适合的数据类型"><a class="header" href="#postgresql支持哪些数据类型且如何选择适合的数据类型">PostgreSQL支持哪些数据类型，且如何选择适合的数据类型？</a></h1>
<ul>
<li>
<p>介绍PostgreSQL支持的各种数据类型，包括几何类型、JSON类型等，并讨论它们的应用场景。</p>
<p>PostgreSQL提供了丰富的数据类型，支持多种数据表示，包括传统的数值、字符类型，以及更高级的地理空间数据、JSON数据等。选择合适的数据类型不仅可以提高数据存储的效率，还能加快查询性能，并确保数据的准确性。以下是PostgreSQL中一些常见的数据类型及其选择指南：</p>
<h3 id="数值类型"><a class="header" href="#数值类型">数值类型</a></h3>
<ul>
<li><strong>整数类型</strong>：包括<code>smallint</code>（2字节）、<code>integer</code>（4字节）、<code>bigint</code>（8字节）。选择时应根据数据的大小范围选择最合适的类型，以节省存储空间。</li>
<li><strong>浮点类型</strong>：包括<code>real</code>（4字节，单精度浮点数）和<code>double precision</code>（8字节，双精度浮点数）。用于存储需要小数的数值，选择时考虑所需的精度。</li>
<li><strong>数值类型</strong>：<code>numeric</code>或<code>decimal</code>，用于存储精确的数值，可以指定精度和小数位数。适合财务计算等需要高精度的场景。</li>
</ul>
<h3 id="字符类型"><a class="header" href="#字符类型">字符类型</a></h3>
<ul>
<li><strong>固定长度</strong>：<code>char(n)</code>，适用于存储长度固定的字符数据，如性别、状态码等。</li>
<li><strong>可变长度</strong>：<code>varchar(n)</code>，适用于长度可变的文本，<code>n</code>定义了最大长度。没有长度限制时也可以使用<code>text</code>类型。</li>
<li><strong>文本类型</strong>：<code>text</code>，适用于存储长文本，如文章、描述等。</li>
</ul>
<h3 id="日期和时间类型"><a class="header" href="#日期和时间类型">日期和时间类型</a></h3>
<ul>
<li>包括<code>date</code>、<code>time</code>、<code>timestamp</code>、<code>timestamptz</code>（带时区的timestamp）等。选择这些类型时要考虑是否需要时间部分，以及是否需要时区支持。</li>
</ul>
<h3 id="布尔类型"><a class="header" href="#布尔类型">布尔类型</a></h3>
<ul>
<li><code>boolean</code>，表示逻辑真（<code>true</code>）或假（<code>false</code>）。适用于任何需要表示是/否、开/关等状态的场景。</li>
</ul>
<h3 id="json类型"><a class="header" href="#json类型">JSON类型</a></h3>
<ul>
<li><strong><code>json</code></strong>：存储JSON数据，保留原始格式。</li>
<li><strong><code>jsonb</code></strong>：存储JSON数据的二进制表示，支持索引。适用于需要频繁查询和修改内部元素的场景。</li>
</ul>
<h3 id="数组类型"><a class="header" href="#数组类型">数组类型</a></h3>
<ul>
<li>PostgreSQL支持定义上述任何类型的数组。适用于存储多个值的场景，如标签、电话号码列表等。</li>
</ul>
<h3 id="地理空间类型"><a class="header" href="#地理空间类型">地理空间类型</a></h3>
<ul>
<li>通过PostGIS扩展，提供了<code>geometry</code>和<code>geography</code>类型，用于存储地理位置数据和执行空间查询。</li>
</ul>
<h3 id="选择数据类型的原则"><a class="header" href="#选择数据类型的原则">选择数据类型的原则</a></h3>
<ul>
<li><strong>准确性</strong>：选择能准确表示数据的类型，例如使用<code>date</code>而不是<code>varchar</code>存储日期。</li>
<li><strong>效率</strong>：考虑存储空间和查询性能，选择尽可能紧凑的类型，如根据数值范围选择合适大小的整数类型。</li>
<li><strong>功能需求</strong>：某些类型提供特殊功能，如<code>jsonb</code>支持索引，<code>geometry</code>支持地理空间查询。</li>
</ul>
<p>正确选择数据类型是优化数据库性能和保障数据准确性的重要步骤。了解和选择最适合应用需求的数据类型，可以提升PostgreSQL数据库的整体效率和可用性。</p>
</li>
</ul>
<h1 id="如何在postgresql中管理大量数据的分区"><a class="header" href="#如何在postgresql中管理大量数据的分区">如何在PostgreSQL中管理大量数据的分区？</a></h1>
<ul>
<li>
<p>解释分区的概念、分区类型（如范围分区、列表分区）及其如何帮助管理大型数据集。</p>
<p>在PostgreSQL中，表分区是管理大量数据的有效方法。它允许将一个大表分解成多个物理上更小、更易于管理的部分，这些部分称为分区。每个分区都是原始表的一个子集，可以根据特定的规则（如日期范围、ID范围或其他键值）进行定义。使用表分区可以提高查询性能、优化数据维护任务（如备份和删除）并提高数据加载的速度。以下是在PostgreSQL中实现表分区的基本步骤：</p>
<h3 id="1-定义分区策略"><a class="header" href="#1-定义分区策略">1. 定义分区策略</a></h3>
<p>首先，确定分区的依据，常见的分区策略包括：</p>
<ul>
<li><strong>范围分区（RANGE）</strong>：基于键值的范围，如日期或数字。</li>
<li><strong>列表分区（LIST）</strong>：基于键值的枚举。</li>
<li><strong>哈希分区（HASH）</strong>：基于键值的哈希。</li>
</ul>
<h3 id="2-创建分区表"><a class="header" href="#2-创建分区表">2. 创建分区表</a></h3>
<p>创建分区表涉及定义一个主表（父表），然后创建具体的分区（子表）。从PostgreSQL 10开始，支持声明式分区，简化了分区表的创建和管理。</p>
<h4 id="创建主表"><a class="header" href="#创建主表">创建主表</a></h4>
<pre><code class="language-sql">CREATE TABLE measurements (
    city_id         int not null,
    logdate         date not null,
    peaktemp        int,
    unitsales       int
) PARTITION BY RANGE (logdate);
</code></pre>
<p>这里，<code>measurements</code>表按<code>logdate</code>的范围进行分区。</p>
<h4 id="创建分区"><a class="header" href="#创建分区">创建分区</a></h4>
<p>然后，为每个分区范围或列表创建具体的分区表：</p>
<pre><code class="language-sql">CREATE TABLE measurements_y2020m01 PARTITION OF measurements
    FOR VALUES FROM ('2020-01-01') TO ('2020-02-01');
</code></pre>
<p>这条语句创建了一个分区，用于存储2020年1月份的数据。</p>
<h3 id="3-管理分区数据"><a class="header" href="#3-管理分区数据">3. 管理分区数据</a></h3>
<ul>
<li><strong>插入数据</strong>：当插入数据到主表时，PostgreSQL会根据定义的分区键和规则自动将数据路由到正确的分区。</li>
<li><strong>查询数据</strong>：查询分区表时，PostgreSQL能够利用分区键在查询计划中进行优化，仅扫描包含相关数据的分区，从而提高查询性能。</li>
</ul>
<h3 id="4-维护分区表"><a class="header" href="#4-维护分区表">4. 维护分区表</a></h3>
<ul>
<li>
<p><strong>定期添加和删除分区</strong>：随着时间的推移，你可能需要添加新的分区来存储新数据，或删除旧的分区以释放空间。这可以通过<code>CREATE TABLE</code>和<code>DROP TABLE</code>命令实现。</p>
</li>
<li>
<p>使用分区表的注意事项</p>
<p>：</p>
<ul>
<li>确保所有分区的定义覆盖了所有可能的键值，以避免插入数据时出现无法找到合适分区的错误。</li>
<li>考虑定期使用<code>VACUUM</code>和<code>ANALYZE</code>命令来维护分区表的性能。</li>
</ul>
</li>
</ul>
<p>通过有效地使用分区，PostgreSQL可以更高效地管理大规模数据集，提升数据的查询、维护和管理效率。</p>
</li>
</ul>
<h1 id="安全性"><a class="header" href="#安全性">安全性</a></h1>
<h1 id="postgresql如何管理用户和权限"><a class="header" href="#postgresql如何管理用户和权限">PostgreSQL如何管理用户和权限？</a></h1>
<ul>
<li>
<p>讨论角色（Role）的概念、权限的分配（GRANT/REVOKE）以及行级安全策略。</p>
<p>在PostgreSQL中，用户（在PostgreSQL中也称作角色）和权限管理是通过一系列的SQL命令和概念来实现的，以确保数据库的安全性和数据的访问控制。以下是管理用户和权限的基本步骤和概念：</p>
<h3 id="用户角色的创建和管理"><a class="header" href="#用户角色的创建和管理">用户（角色）的创建和管理</a></h3>
<ul>
<li>
<p><strong>创建用户</strong>：使用<code>CREATE ROLE</code>命令创建新用户。例如，创建一个名为<code>new_user</code>的用户，可以使用如下命令：</p>
<pre><code class="language-sql">CREATE ROLE new_user WITH LOGIN PASSWORD 'password';
</code></pre>
<p>这里<code>LOGIN</code>允许角色登录，<code>PASSWORD</code>设置了登录密码。</p>
</li>
<li>
<p><strong>修改用户属性</strong>：使用<code>ALTER ROLE</code>命令修改用户属性。例如，赋予用户创建数据库的权限：</p>
<pre><code class="language-sql">ALTER ROLE new_user CREATEDB;
</code></pre>
</li>
<li>
<p><strong>删除用户</strong>：使用<code>DROP ROLE</code>命令删除用户。例如，删除<code>new_user</code>：</p>
<pre><code class="language-sql">DROP ROLE new_user;
</code></pre>
</li>
</ul>
<h3 id="权限权限授予和撤销"><a class="header" href="#权限权限授予和撤销">权限（权限授予和撤销）</a></h3>
<p>在PostgreSQL中，权限通常指的是对数据库对象（如表、视图、序列等）的访问权限。使用<code>GRANT</code>和<code>REVOKE</code>命令来授予和撤销权限。</p>
<ul>
<li>
<p><strong>授予权限</strong>：使用<code>GRANT</code>命令授予用户对数据库对象的权限。例如，授予<code>new_user</code>对<code>employees</code>表的选择（SELECT）权限：</p>
<pre><code class="language-sql">GRANT SELECT ON employees TO new_user;
</code></pre>
</li>
<li>
<p><strong>撤销权限</strong>：使用<code>REVOKE</code>命令撤销已授予的权限。例如，撤销<code>new_user</code>对<code>employees</code>表的选择权限：</p>
<pre><code class="language-sql">REVOKE SELECT ON employees FROM new_user;
</code></pre>
</li>
</ul>
<h3 id="角色的概念和使用"><a class="header" href="#角色的概念和使用">角色的概念和使用</a></h3>
<p>PostgreSQL中的角色可以是一个用户，也可以是一组用户的集合（有时被称为组）。角色可以拥有权限，也可以将权限授予其他角色。</p>
<ul>
<li>
<p><strong>创建角色组</strong>：可以创建一个角色作为用户组，然后将用户添加到该组中。例如，创建一个名为<code>staff</code>的角色组：</p>
<pre><code class="language-sql">CREATE ROLE staff;
</code></pre>
<p>然后将<code>new_user</code>添加到<code>staff</code>组中：</p>
<pre><code class="language-sql">GRANT staff TO new_user;
</code></pre>
</li>
<li>
<p><strong>利用角色组管理权限</strong>：可以将权限直接授予角色组，组内的所有用户自动继承这些权限。这简化了权限管理，特别是对于有许多用户和复杂权限设置的情况。</p>
</li>
</ul>
<h3 id="默认权限和策略"><a class="header" href="#默认权限和策略">默认权限和策略</a></h3>
<ul>
<li><strong>默认权限</strong>：可以为特定类型的数据库对象设置默认权限，这样新创建的对象会自动继承这些权限。</li>
<li><strong>行级安全策略</strong>：PostgreSQL支持行级安全策略（Row-Level Security, RLS），允许定义策略来控制基于行的访问控制，进一步细化数据访问权限。</li>
</ul>
<p>通过这些机制，PostgreSQL提供了强大灵活的用户和权限管理功能，帮助管理员有效地控制对数据库资源的访问，保障数据安全。</p>
</li>
</ul>
<h1 id="如何在postgresql中配置ssl加密"><a class="header" href="#如何在postgresql中配置ssl加密">如何在PostgreSQL中配置SSL加密？</a></h1>
<ul>
<li>
<p>描述SSL加密的设置步骤和为什么它对保护数据传输很重要。</p>
<p>在PostgreSQL中配置SSL加密可以增强数据库连接的安全性，防止数据在传输过程中被窃听或篡改。以下是配置SSL加密的基本步骤：</p>
<h3 id="1-获取ssl证书"><a class="header" href="#1-获取ssl证书">1. 获取SSL证书</a></h3>
<p>首先，你需要一个SSL证书和私钥。你可以从证书颁发机构（CA）获取证书，或者为测试目的自己生成一个自签名证书。使用<code>openssl</code>可以生成一个自签名的证书和私钥：</p>
<pre><code class="language-shell">openssl req -new -text -passout pass:abcd -subj /CN=localhost -out server.req
openssl rsa -in privkey.pem -passin pass:abcd -out server.key
openssl req -x509 -in server.req -text -key server.key -out server.crt
chmod 600 server.key
</code></pre>
<p>这会生成<code>server.crt</code>（证书文件）和<code>server.key</code>（私钥文件），并确保私钥文件只能被服务器用户读取。</p>
<h3 id="2-配置postgresql使用ssl"><a class="header" href="#2-配置postgresql使用ssl">2. 配置PostgreSQL使用SSL</a></h3>
<p>将证书和私钥文件放置到PostgreSQL的数据目录中（通常是<code>/var/lib/postgresql/版本号/main</code>），然后在PostgreSQL的配置文件<code>postgresql.conf</code>中启用SSL：</p>
<pre><code class="language-shell">ssl = on
ssl_cert_file = 'server.crt'
ssl_key_file = 'server.key'
</code></pre>
<p>确保指定的文件路径正确，如果证书和密钥文件位于PostgreSQL数据目录，则可以使用相对路径。</p>
<h3 id="3-配置客户端验证可选"><a class="header" href="#3-配置客户端验证可选">3. 配置客户端验证（可选）</a></h3>
<p>如果你还想要服务器验证客户端的身份，需要创建一个CA证书，并使用它签发客户端证书。然后，将CA证书复制到PostgreSQL服务器，并在<code>postgresql.conf</code>文件中指定：</p>
<pre><code class="language-shell">ssl_ca_file = 'root.crt'
</code></pre>
<p>此外，需要在<code>pg_hba.conf</code>文件中为使用SSL的连接指定认证方式，例如，要求所有使用SSL的连接必须进行客户端证书验证：</p>
<pre><code class="language-shell"># TYPE  DATABASE        USER            ADDRESS                 METHOD
hostssl all             all             0.0.0.0/0               cert
</code></pre>
<h3 id="4-重启postgresql服务"><a class="header" href="#4-重启postgresql服务">4. 重启PostgreSQL服务</a></h3>
<p>配置完成后，需要重启PostgreSQL服务以使更改生效：</p>
<pre><code class="language-shell">sudo systemctl restart postgresql
</code></pre>
<p>或者，如果你使用的是不同的系统启动管理器，使用相应的命令重启服务。</p>
<h3 id="5-验证ssl连接"><a class="header" href="#5-验证ssl连接">5. 验证SSL连接</a></h3>
<p>使用<code>psql</code>或其他PostgreSQL客户端工具，通过SSL连接到数据库以验证配置：</p>
<pre><code class="language-shell">psql &quot;sslmode=require host=localhost dbname=yourdbname user=youruser&quot;
</code></pre>
<p><code>sslmode=require</code>强制客户端使用SSL进行连接。如果连接成功，这意味着你的SSL配置正确。</p>
<p>通过以上步骤，你可以在PostgreSQL中配置SSL加密，增强数据库连接的安全性。</p>
</li>
</ul>
<h1 id="架构和设计"><a class="header" href="#架构和设计">架构和设计</a></h1>
<h1 id="postgresql的逻辑架构包括哪些组成部分"><a class="header" href="#postgresql的逻辑架构包括哪些组成部分">PostgreSQL的逻辑架构包括哪些组成部分？</a></h1>
<ul>
<li>
<p>概述数据库、模式、表、视图等逻辑组件的组织和关系。</p>
<p>在关系型数据库系统中，数据组织遵循一定的层次结构，包括数据库、模式、表、视图等逻辑组件。这些组件协同工作，提供数据存储、查询、管理的功能。以下是这些逻辑组件的组织和关系的概述：</p>
<h3 id="数据库database"><a class="header" href="#数据库database">数据库（Database）</a></h3>
<p>数据库是存储数据的容器，是最高层次的逻辑分组。一个数据库服务器可以包含多个数据库，每个数据库都是独立的，拥有自己的数据和结构。数据库是管理和访问数据的基本单位，不同的数据库间数据互不干扰。</p>
<h3 id="模式schema"><a class="header" href="#模式schema">模式（Schema）</a></h3>
<ul>
<li><strong>定义</strong>：模式是数据库内部的一个逻辑分组，用于组织和隔离数据。一个数据库可以包含多个模式，每个模式可以包含表、视图、索引、数据类型等对象。</li>
<li><strong>用途</strong>：模式主要用于管理数据的权限和组织结构，便于数据管理和访问控制。在同一数据库中，不同模式下可以有同名的表或视图。</li>
</ul>
<h3 id="表table"><a class="header" href="#表table">表（Table）</a></h3>
<ul>
<li><strong>定义</strong>：表是存储数据的基本结构，由行（记录）和列（字段）组成。每列有固定的数据类型，每行是一个数据项。</li>
<li><strong>关系</strong>：表属于特定的模式，表中的数据可以通过主键、外键等约束与其他表建立关系，形成复杂的数据结构。</li>
</ul>
<h3 id="视图view"><a class="header" href="#视图view">视图（View）</a></h3>
<ul>
<li><strong>定义</strong>：视图是基于表（或其他视图）的查询结果的虚拟表。它是一种逻辑上的表现，包含了一个预定义的查询。</li>
<li><strong>用途</strong>：视图可以用来简化复杂的查询，限制对数据的访问，以及提供数据的特定视角。视图不存储数据，数据的变更反映在基础表上。</li>
</ul>
<h3 id="索引index"><a class="header" href="#索引index">索引（Index）</a></h3>
<ul>
<li><strong>定义</strong>：索引是数据库表的一个附加结构，用于加速对表中数据的检索。索引存储了指向表中数据的快速访问路径。</li>
<li><strong>关系</strong>：索引与表紧密相关，通过在一个或多个列上创建索引，可以提高查询性能。索引增加了额外的维护成本，因为在对表数据进行修改时，索引也需要更新。</li>
</ul>
<h3 id="逻辑组件的关系"><a class="header" href="#逻辑组件的关系">逻辑组件的关系</a></h3>
<ul>
<li>数据库 -&gt; 包含 -&gt; 模式</li>
<li>模式 -&gt; 包含 -&gt; 表、视图、索引等</li>
<li>表 -&gt; 存储 -&gt; 数据（行和列）</li>
<li>视图 -&gt; 基于 -&gt; 表（或其他视图）的查询</li>
<li>索引 -&gt; 加速 -&gt; 表中数据的检索</li>
</ul>
<p>这种层次结构和组织方式提供了数据管理的灵活性和效率，同时支持数据的安全性、可维护性和扩展性。</p>
</li>
</ul>
<p>在设计PostgreSQL数据库时，应如何考虑表的规范化与反规范化？</p>
<h1 id="讨论规范化的级别它们对性能的影响以及何时考虑反规范化"><a class="header" href="#讨论规范化的级别它们对性能的影响以及何时考虑反规范化">讨论规范化的级别、它们对性能的影响，以及何时考虑反规范化。</a></h1>
<p>这些问题覆盖了PostgreSQL的多个方面，从基础到高级使用，从性能优化到安全性配置。准备这些问题有助于应聘者全面展示他们对PostgreSQL数据库管理和维护的知识和技能。</p>
<p>数据库规范化是设计关系型数据库结构的过程，旨在减少数据冗余、避免数据异常、提高数据完整性。规范化通过一系列规范化级别（或范式）来实现，每个级别都在前一个级别的基础上增加更严格的约束。以下是常见的规范化级别及其对性能的影响，以及何时考虑反规范化。</p>
<h3 id="规范化级别"><a class="header" href="#规范化级别">规范化级别</a></h3>
<ol>
<li><strong>第一范式（1NF）</strong>：确保表的每列都是不可分割的基本数据项，实现属性的原子性。</li>
<li><strong>第二范式（2NF）</strong>：在1NF的基础上，移除部分依赖，即确保表中的所有非键属性都完全依赖于主键。</li>
<li><strong>第三范式（3NF）</strong>：在2NF的基础上，移除传递依赖，确保表中的每列都直接依赖于主键。</li>
<li><strong>BCNF（Boyce-Codd范式）</strong>：更严格的3NF，处理了一些特殊情况，确保主键的每个决定因素都是候选键。</li>
<li><strong>第四范式（4NF）</strong>：在BCNF的基础上，移除多值依赖。</li>
<li><strong>第五范式（5NF）</strong>：在4NF的基础上，移除连接依赖。</li>
</ol>
<h3 id="规范化对性能的影响"><a class="header" href="#规范化对性能的影响">规范化对性能的影响</a></h3>
<ul>
<li><strong>优点</strong>：
<ul>
<li><strong>减少数据冗余</strong>：避免了数据的不必要复制，节省存储空间。</li>
<li><strong>提高数据一致性</strong>：更新操作更简单，减少了数据不一致的风险。</li>
<li><strong>便于维护</strong>：数据库结构更清晰，维护和修改更容易。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li><strong>可能降低查询性能</strong>：高度规范化的数据库可能需要更多的表连接操作，这在某些情况下会降低查询性能。</li>
<li><strong>增加设计和实现的复杂性</strong>：更多的表和关系可能使数据库设计和查询编写更为复杂。</li>
</ul>
</li>
</ul>
<h3 id="考虑反规范化的情况"><a class="header" href="#考虑反规范化的情况">考虑反规范化的情况</a></h3>
<p>尽管规范化有其优点，但在某些情况下，为了优化性能和简化查询，可能需要考虑反规范化：</p>
<ul>
<li><strong>查询性能优先</strong>：当读操作远多于写操作，且查询性能是关键考虑因素时，适当的反规范化（如增加冗余字段或汇总表）可以减少表连接，加快查询速度。</li>
<li><strong>简化查询</strong>：反规范化可以减少查询的复杂性，使得编写和理解查询变得更简单。</li>
<li><strong>提高写操作性能</strong>：在一些场景下，更新操作可能因规范化而变得复杂和缓慢，适当的反规范化可以简化更新操作。</li>
</ul>
<h3 id="结论"><a class="header" href="#结论">结论</a></h3>
<p>规范化和反规范化都是数据库设计中的重要考虑因素。选择合适的级别需要根据具体的应用场景、性能要求和数据操作模式来决定。通常，一个好的实践是先进行充分的规范化以确保数据的一致性和完整性，然后根据性能测试和实际需求适当进行反规范化。</p>
<h1 id="mvcc-策略中是如何处理对一行数据的修改冲突的"><a class="header" href="#mvcc-策略中是如何处理对一行数据的修改冲突的">MVCC 策略中是如何处理对一行数据的修改冲突的？</a></h1>
<p>在多版本并发控制（MVCC）策略中，当对一行数据进行修改操作（如更新或删除）时，为了保持数据的一致性和隔离性，并允许并发事务的执行，MVCC采用了以下方法处理这些操作：</p>
<h3 id="更新操作"><a class="header" href="#更新操作">更新操作</a></h3>
<ol>
<li><strong>创建行的新版本</strong>：当一行数据需要被更新时，MVCC不会直接修改原始数据。相反，它创建这行数据的新版本（即新的数据行），同时保留旧版本的数据。这样，不同的事务可以根据它们的隔离级别和开始时间看到数据的不同版本。</li>
<li><strong>版本控制</strong>：新创建的行版本会被标记为由执行更新操作的事务创建。这涉及到对行数据增加或更新系统列，如<code>xmin</code>（事务ID）来标识创建这个版本的事务，以及可能的<code>xmax</code>来标识使这个版本失效的事务ID。</li>
<li><strong>事务提交</strong>：如果执行更新的事务成功提交，则这个新版本的行数据将对后续事务可见。如果事务回滚，新版本的行数据将被废弃，旧版本保持不变。</li>
</ol>
<h3 id="删除操作"><a class="header" href="#删除操作">删除操作</a></h3>
<ol>
<li><strong>标记删除</strong>：当一行数据被删除时，MVCC并不立即从物理存储中移除这行数据。而是将这行数据标记为已删除，通常是通过设置<code>xmax</code>为执行删除操作的事务ID，表示这个版本的数据行在此事务或之后不再可见。</li>
<li><strong>事务提交</strong>：如果执行删除的事务成功提交，这行数据对后续事务不再可见。如果事务回滚，删除标记将被撤销，数据行对所有事务保持可见。</li>
</ol>
<h3 id="垃圾回收vacuuming"><a class="header" href="#垃圾回收vacuuming">垃圾回收（Vacuuming）</a></h3>
<ul>
<li><strong>清理旧版本</strong>：由于更新和删除操作会产生大量的旧版本数据，PostgreSQL需要定期清理这些不再被任何事务访问的旧版本。这通过<code>VACUUM</code>操作实现，它会回收旧版本占用的空间，使其可用于新的数据。自动<code>VACUUM</code>过程在后台运行，帮助管理这些空间。</li>
</ul>
<h3 id="处理修改冲突"><a class="header" href="#处理修改冲突">处理修改冲突</a></h3>
<ul>
<li><strong>隔离级别</strong>：不同的事务隔离级别会以不同的方式处理对同一行数据的并发修改。例如，在可重复读（Repeatable Read）隔离级别下，事务将看到数据的一致性视图，不会看到其他事务对这些数据所做的修改。在串行化（Serializable）隔离级别下，可能会检测到修改冲突并导致事务回滚，以保持数据的一致性。</li>
</ul>
<p>通过这种方式，MVCC允许PostgreSQL在不锁定读取操作的情况下处理并发的数据修改，同时保证了数据的一致性和隔离性。</p>
<h1 id="mvcc对于不同的隔离级别是如何处理修改冲突的"><a class="header" href="#mvcc对于不同的隔离级别是如何处理修改冲突的">MVCC对于不同的隔离级别是如何处理修改冲突的？</a></h1>
<p>在多版本并发控制（MVCC）中，不同的事务隔离级别决定了事务可以看到哪些数据版本，以及如何处理并发事务中的修改冲突。PostgreSQL支持四种标准的SQL事务隔离级别：读未提交（Read Uncommitted）、读已提交（Read Committed）、可重复读（Repeatable Read）和串行化（Serializable）。每个隔离级别对修改冲突的处理方式如下：</p>
<h3 id="读未提交read-uncommitted"><a class="header" href="#读未提交read-uncommitted">读未提交（Read Uncommitted）</a></h3>
<ul>
<li>实际上，PostgreSQL不实现真正的读未提交隔离级别，因为即使在最低的隔离级别下，读操作也不会看到其他未提交事务的修改。这意味着在PostgreSQL中，“读未提交”行为等同于“读已提交”。</li>
</ul>
<h3 id="读已提交read-committed"><a class="header" href="#读已提交read-committed">读已提交（Read Committed）</a></h3>
<ul>
<li><strong>动态快照</strong>：在这个隔离级别下，事务看到的是执行每个SQL语句时点的数据快照。这意味着在同一个事务内，后续的查询可能会看到在事务开始后其他事务所做的修改。</li>
<li><strong>修改冲突处理</strong>：如果两个事务同时尝试修改同一行，第一个提交的事务会成功，而第二个事务在尝试提交时如果检测到冲突（即数据已被修改），将会失败并回滚。</li>
</ul>
<h3 id="可重复读repeatable-read"><a class="header" href="#可重复读repeatable-read">可重复读（Repeatable Read）</a></h3>
<ul>
<li><strong>事务范围的快照</strong>：在可重复读隔离级别下，事务看到的是事务开始时的数据快照。这意味着在整个事务期间，无论其他事务如何修改数据，当前事务看到的数据不变。</li>
<li><strong>修改冲突处理</strong>：如果一个事务尝试修改另一个并发事务已经读取（在其快照中）的行，PostgreSQL通过使用“可序列化快照隔离”（SSI）策略来处理这种冲突，可能导致其中一个事务在提交时因为序列化错误而失败。</li>
</ul>
<h3 id="串行化serializable"><a class="header" href="#串行化serializable">串行化（Serializable）</a></h3>
<ul>
<li><strong>强制事务序列化</strong>：串行化是最严格的隔离级别，它尝试通过使事务彼此独立运行来模拟事务的顺序执行，从而防止幻读、不可重复读和脏读。</li>
<li><strong>冲突检测与解决</strong>：PostgreSQL在这个隔离级别使用可序列化快照隔离（SSI）策略，动态检测事务间的潜在冲突。如果检测到违反串行化顺序的操作，事务将在提交时因为序列化异常而被迫回滚，以保证数据库的一致性。</li>
</ul>
<p>通过这种方式，MVCC和事务隔离级别共同工作，允许PostgreSQL在保持数据一致性和隔离性的同时，提供高度的并发性。管理员和开发者需要根据应用的具体需求选择合适的隔离级别，以平衡一致性、性能和并发控制的需求。</p>
<h1 id="如何理解mvcc的一致性"><a class="header" href="#如何理解mvcc的一致性">如何理解MVCC的一致性</a></h1>
<p>在多版本并发控制（MVCC）中，一致性是指数据库事务操作的结果必须保证数据库从一个一致的状态转换到另一个一致的状态，不论并发事务如何执行。MVCC通过以下机制来保证一致性：</p>
<h3 id="事务隔离和数据版本"><a class="header" href="#事务隔离和数据版本">事务隔离和数据版本</a></h3>
<ul>
<li><strong>数据版本</strong>：MVCC通过为每个事务操作的数据创建版本（或快照）来实现。每个事务根据其隔离级别看到一致的数据视图，无论其他事务如何并发修改数据。这意味着每个事务都在一个隔离的环境中执行，看到的是数据的一致性快照。</li>
<li><strong>隔离级别</strong>：不同的事务隔离级别定义了事务可以看到的数据版本。例如，在“可重复读”隔离级别下，一个事务看到的是它开始时数据库的一致性快照，即使其他事务提交了更新，这些更新也不会影响当前事务的数据视图。这有助于防止不可重复读和幻读问题，从而保证了数据的一致性。</li>
</ul>
<h3 id="提交和回滚"><a class="header" href="#提交和回滚">提交和回滚</a></h3>
<ul>
<li><strong>提交</strong>：当事务成功提交时，它所做的修改会永久保存到数据库中，这些修改对应的数据版本将对后续事务可见（取决于隔离级别）。提交操作是将数据库从一个一致状态转移到另一个一致状态的关键步骤。</li>
<li><strong>回滚</strong>：如果事务遇到错误或主动回滚，所有未提交的修改都将被撤销，数据库回到事务开始前的一致状态。MVCC通过维护数据的旧版本来实现回滚操作，确保数据的一致性不被破坏。</li>
</ul>
<h3 id="并发冲突的处理"><a class="header" href="#并发冲突的处理">并发冲突的处理</a></h3>
<ul>
<li><strong>写冲突</strong>：当两个事务尝试同时修改同一行数据时，MVCC通过锁机制和版本检查来避免冲突。通常，第一个提交的事务会成功，而第二个事务则可能因为数据已被修改而回滚，保证了数据的一致性。</li>
<li><strong>序列化异常</strong>：在最高的隔离级别（如串行化），MVCC通过检测事务间的潜在冲突并在必要时回滚事务，来避免可能破坏一致性的操作。</li>
</ul>
<h3 id="垃圾回收和空间重用"><a class="header" href="#垃圾回收和空间重用">垃圾回收和空间重用</a></h3>
<ul>
<li><strong>版本清理</strong>：MVCC需要定期清理不再需要的旧数据版本，这通过<code>VACUUM</code>操作在PostgreSQL中实现。清理过程确保数据库不会因为积累的旧版本而变慢，同时保持了数据的一致性和高效存储。</li>
</ul>
<p>通过上述机制，MVCC在提供高并发和低锁开销的同时，保证了数据库操作的一致性，确保每个事务都在一致的数据状态上执行，而不会被其他并发事务的修改所影响。这是MVCC对于现代数据库系统重要性的关键所在。</p>
<h1 id="wal-写入的数据记录是什么样的"><a class="header" href="#wal-写入的数据记录是什么样的">WAL 写入的数据记录是什么样的</a></h1>
<p>在PostgreSQL中，Write-Ahead Logging（WAL）是一种保证数据库事务日志先行写入的技术，用于实现事务的持久性和可靠的崩溃恢复机制。WAL日志记录了对数据库进行修改的所有操作，这些操作在实际修改数据库文件之前被写入到WAL文件中。WAL日志包含的数据记录主要包括：</p>
<h3 id="1-事务信息"><a class="header" href="#1-事务信息">1. 事务信息</a></h3>
<ul>
<li><strong>开始事务</strong>：标记一个事务的开始，包括事务ID等信息。</li>
<li><strong>提交事务</strong>：标记事务的成功结束，包括事务ID和提交时间。</li>
<li><strong>回滚事务</strong>：在事务失败或显式回滚时记录，包括事务ID。</li>
</ul>
<h3 id="2-数据修改操作"><a class="header" href="#2-数据修改操作">2. 数据修改操作</a></h3>
<p>对于数据库中数据的每个修改操作，WAL日志记录具体的操作细节，这些操作包括：</p>
<ul>
<li><strong>插入</strong>：记录被插入行的数据及其在表中的位置。</li>
<li><strong>更新</strong>：记录更新操作的旧值和新值，以及被更新行的位置。在某些情况下，可能只记录变更的部分，以节省空间。</li>
<li><strong>删除</strong>：记录被删除行的标识和位置。</li>
</ul>
<h3 id="3-ddl操作"><a class="header" href="#3-ddl操作">3. DDL操作</a></h3>
<p>虽然数据定义语言（DDL）操作（如创建或删除表、索引）不直接修改表中的数据，但这些操作的执行也会影响数据库的结构，因此它们也会被记录在WAL日志中，以确保数据库结构的一致性。</p>
<h3 id="4-检查点checkpoints"><a class="header" href="#4-检查点checkpoints">4. 检查点（Checkpoints）</a></h3>
<ul>
<li><strong>检查点</strong>是WAL日志中的特殊记录，指示了数据库在某一时刻的一致状态。检查点记录包含了此时刻所有已提交事务的信息，使得在数据库恢复时，只需要从最近的检查点开始应用WAL日志，而不是从头开始，从而加快恢复速度。</li>
</ul>
<h3 id="5-其他控制信息"><a class="header" href="#5-其他控制信息">5. 其他控制信息</a></h3>
<ul>
<li>包括为了维护WAL日志的完整性和顺序性所必需的各种元数据和控制信息，例如WAL序列号（LSN, Log Sequence Number），它是每条WAL记录的唯一标识，用于确保日志的顺序性和一致性。</li>
</ul>
<p>WAL日志的这些记录允许PostgreSQL在发生故障时，通过重放WAL日志来重建事务提交前的状态，保证数据的完整性和一致性。WAL机制是PostgreSQL高可靠性和事务安全性的关键所在。</p>
<h1 id="介绍下vacuum过程"><a class="header" href="#介绍下vacuum过程">介绍下Vacuum过程</a></h1>
<p>在PostgreSQL中，<code>VACUUM</code>是一种维护数据库健康的重要过程，主要用于回收由于事务操作（如更新和删除）留下的旧数据版本所占用的空间，并优化数据库性能。由于PostgreSQL使用多版本并发控制（MVCC）来处理并发事务，每次数据被修改时，旧的数据版本会被保留以供旧事务访问，这就导致了大量的“死”行（不再被任何事务访问的行）的累积。<code>VACUUM</code>过程负责清理这些不再需要的行。以下是<code>VACUUM</code>的主要功能和类型：</p>
<h3 id="功能"><a class="header" href="#功能">功能</a></h3>
<ol>
<li><strong>回收空间</strong>：<code>VACUUM</code>清理死行并释放占用的空间，使其能够被数据库中的其他部分重用。虽然标准的<code>VACUUM</code>操作不会将空间返还给操作系统，但它确保了这些空间在表内部可重用。</li>
<li><strong>更新统计信息</strong>：<code>VACUUM</code>更新数据库的统计信息，这对查询优化器（Planner）选择最佳查询路径非常重要。</li>
<li><strong>防止事务ID耗尽</strong>：PostgreSQL使用有限大小的事务ID，<code>VACUUM</code>可以标记旧版本的行为“冻结”，这意味着它们不再参与事务ID的计算，从而避免了事务ID耗尽的问题。</li>
</ol>
<h3 id="类型"><a class="header" href="#类型">类型</a></h3>
<ul>
<li><strong>普通VACUUM</strong>：不带任何参数的<code>VACUUM</code>命令。它回收死行占用的空间供表内部重用，并更新统计信息，但不会将空间返还给操作系统。普通<code>VACUUM</code>可以在数据库运行时执行，不会锁定表。</li>
<li><strong>FULL VACUUM</strong>：<code>VACUUM FULL</code>命令会重写表到一个新的磁盘文件中，只包含有效行。这个过程可以更彻底地回收空间，并将其返还给操作系统，但是它会对表加排他锁，阻止对表的访问，因此可能会影响数据库的可用性。</li>
<li><strong>自动VACUUM</strong>：PostgreSQL具有自动VACUUM守护进程（autovacuum），它在后台运行，自动监测并清理数据库表，以避免手动运行<code>VACUUM</code>。自动VACUUM的行为可以通过配置参数进行调整。</li>
</ul>
<h3 id="运行vacuum"><a class="header" href="#运行vacuum">运行VACUUM</a></h3>
<ul>
<li>
<p><strong>手动执行</strong>：可以通过执行SQL命令来手动启动VACUUM过程，例如：</p>
<pre><code>sqlCopy code
VACUUM; -- 普通VACUUM
VACUUM FULL; -- FULL VACUUM
</code></pre>
</li>
<li>
<p><strong>自动执行</strong>：通过配置PostgreSQL的自动VACUUM参数，例如<code>autovacuum</code>开启自动VACUUM，以及相关的阈值和限制，来自动化这一过程。</p>
</li>
</ul>
<h3 id="注意事项"><a class="header" href="#注意事项">注意事项</a></h3>
<ul>
<li>在执行大量数据修改操作后及时运行<code>VACUUM</code>，特别是在大批量删除或更新操作之后，可以帮助释放空间，保持数据库性能。</li>
<li>在高负载系统中，合理配置自动VACUUM的参数至关重要，以避免性能下降。</li>
<li><code>VACUUM FULL</code>可能会占用较长时间和资源，应在低负载时段进行。</li>
</ul>
<p>通过定期的<code>VACUUM</code>操作，PostgreSQL能够高效管理存储空间，保持查询性能，并确保数据库的长期稳定运行。</p>
<h1 id="b-tree-索引是如何实现的"><a class="header" href="#b-tree-索引是如何实现的">B-Tree 索引是如何实现的</a></h1>
<p>B-Tree索引是数据库中最常见的索引类型之一，它通过一个平衡的树结构来存储数据，以实现快速的数据检索、插入、删除和更新操作。B-Tree（平衡树）的“B”不代表一个具体的单词，而是指的是平衡（Balanced）的意思，确保树的高度最小化，以维持操作的效率。下面是B-Tree索引的实现原理和特点：</p>
<h3 id="b-tree索引的结构"><a class="header" href="#b-tree索引的结构">B-Tree索引的结构</a></h3>
<ul>
<li><strong>节点</strong>：B-Tree由多个节点组成，每个节点可以存储多个键值（entries）和指向子节点的指针。节点分为内部节点和叶子节点，其中叶子节点包含了指向实际数据记录的指针。</li>
<li><strong>键值和指针</strong>：每个节点内的键值按照一定的顺序排列。内部节点的键值用于导航，指针指向子节点；叶子节点的键值对应实际的数据记录，或包含指向数据记录的指针。</li>
<li><strong>分支因子</strong>：B-Tree的特性之一是每个节点可以有多个子节点。一个节点的最大和最小子节点数称为该B-Tree的分支因子。这个因子决定了树的宽度和高度。</li>
</ul>
<h3 id="b-tree索引的操作"><a class="header" href="#b-tree索引的操作">B-Tree索引的操作</a></h3>
<ul>
<li><strong>查找</strong>：从根节点开始，根据键值的大小逐级向下查找，直到找到对应的叶子节点。这个过程类似于二分查找，效率很高。</li>
<li><strong>插入</strong>：插入新的键值时，同样从根节点开始查找适当的插入位置。如果目标节点已满，则先进行分裂操作，保持树的平衡，然后插入新键值。</li>
<li><strong>删除</strong>：删除键值时，如果删除后节点的键值数量低于最小限制，则进行合并或借用操作，以维持节点的最小键值数，保证树的平衡。</li>
<li><strong>更新</strong>：更新操作通常是先删除旧键值，再插入新键值的组合操作。</li>
</ul>
<h3 id="b-tree索引的特点"><a class="header" href="#b-tree索引的特点">B-Tree索引的特点</a></h3>
<ul>
<li><strong>平衡性</strong>：B-Tree的所有叶子节点都处于同一层，保证了查找、插入、删除操作的最坏情况下的时间复杂度均为O(log n)。</li>
<li><strong>高效的读写性能</strong>：由于B-Tree的平衡性和分支因子的设计，它能够在保持较低树高的同时存储大量键值，这使得磁盘I/O操作更加高效。</li>
<li><strong>适用性广</strong>：B-Tree索引适用于范围查询和顺序访问，除了精确匹配查询之外，还可以高效地处理大于、小于、介于等范围查询操作。</li>
</ul>
<p>B-Tree索引是关系型数据库系统中实现索引的核心技术之一，它的设计兼顾了性能和通用性，适用于多种数据访问场景。</p>
<h1 id="gingeneralized-inverted-index索引-是如何工作的"><a class="header" href="#gingeneralized-inverted-index索引-是如何工作的">GIN（Generalized Inverted Index）索引 是如何工作的</a></h1>
<p>GIN（Generalized Inverted Index）索引是PostgreSQL中一种特殊类型的索引，专为处理包含多个组件值的数据类型设计，如数组、JSONB、全文搜索中的文档等。GIN索引通过反转数据结构来加速对这类数据的查询操作，特别是在执行包含、相交等查询时效率非常高。以下是GIN索引的工作原理和特点：</p>
<h3 id="工作原理"><a class="header" href="#工作原理">工作原理</a></h3>
<ul>
<li><strong>反向索引结构</strong>：GIN索引存储了数据中每个组件值（如数组中的元素、文档中的词汇）及其对应的记录位置（通常是行指针）。这种结构被称为“反向索引”，因为它从数据值映射回包含这些值的记录。</li>
<li><strong>索引条目</strong>：在GIN索引中，每个唯一的组件值都是一个索引条目。对于给定的组件值，索引会存储一个列表，包含所有包含该值的记录的位置。这允许快速查找包含特定值或值集的所有记录。</li>
<li><strong>构建和维护</strong>：构建GIN索引时，数据库会扫描目标列的所有记录，提取每条记录中的组件值，并更新索引结构。随着数据的插入、更新和删除，GIN索引会相应地进行调整以保持最新状态。</li>
</ul>
<h3 id="特点"><a class="header" href="#特点">特点</a></h3>
<ul>
<li><strong>适用于多值数据类型</strong>：GIN索引非常适合索引数组、范围类型、JSONB等包含多值的数据类型，因为它可以高效地处理这些数据类型的包含和重叠查询。</li>
<li><strong>查询优化</strong>：GIN索引优化了多值包含查询，如查找包含特定元素的数组或包含特定词汇的文档。这在全文搜索和复杂数据结构查询中尤其有用。</li>
<li><strong>写入成本较高</strong>：与B-Tree等其他索引类型相比，GIN索引的构建和更新成本相对较高，因为需要处理多个组件值和复杂的数据结构。因此，GIN索引更适合读操作远多于写操作的场景。</li>
<li><strong>快速搜索</strong>：尽管GIN索引的写入成本较高，但它能显著提高包含、相交等查询的性能，使得对于大量复杂数据的搜索变得非常快速。</li>
</ul>
<h3 id="应用场景"><a class="header" href="#应用场景">应用场景</a></h3>
<ul>
<li><strong>全文搜索</strong>：GIN索引常用于全文搜索，可快速找到包含特定词汇或短语的文档。</li>
<li><strong>JSONB数据查询</strong>：在包含复杂JSONB数据的列上使用GIN索引，可以加速对特定键或值的查询。</li>
<li><strong>数组查询</strong>：对于包含数组数据的列，GIN索引可以快速查找包含特定元素的行。</li>
</ul>
<p>总的来说，GIN索引是一种强大的索引类型，适用于特定的查询优化场景，尤其是在需要快速搜索包含多个值的复杂数据类型时。然而，考虑到其维护成本，应根据实际的数据访问模式谨慎使用。</p>
<h1 id="sp-gistspace-partitioned-generalized-search-tree索引-是如何工作的"><a class="header" href="#sp-gistspace-partitioned-generalized-search-tree索引-是如何工作的">SP-GiST（Space-Partitioned Generalized Search Tree）索引 是如何工作的</a></h1>
<p>SP-GiST（Space-Partitioned Generalized Search Tree）索引是PostgreSQL中支持的一种高级索引类型，它提供了对空间分区数据结构的支持，例如四叉树、k-d树和径向树等。与B-Tree和GIN等索引相比，SP-GiST允许更灵活的分区策略，特别适用于非均匀分布的数据和多维数据，能有效加速点查询、范围查询和最近邻查询等操作。下面是SP-GiST索引的工作原理和特点：</p>
<h3 id="工作原理-1"><a class="header" href="#工作原理-1">工作原理</a></h3>
<p>SP-GiST索引通过将数据空间划分成非重叠的区域（分区）来组织数据，每个区域内的数据项根据某种分区逻辑被组织起来。这种分区逻辑取决于实际应用的需求和数据的特性。SP-GiST索引的关键特性包括：</p>
<ul>
<li><strong>分区策略</strong>：SP-GiST支持多种空间分区策略，如四叉树（对二维空间进行分区）和k-d树（对k维空间进行分区）。这些策略将数据空间分割成更小的部分，使得查询可以快速定位到感兴趣的区域。</li>
<li><strong>非均匀分布的数据</strong>：SP-GiST特别适用于处理数据分布不均匀的情况。它通过适应数据的实际分布来优化索引结构，减少查询时需要访问的节点数量。</li>
</ul>
<h3 id="索引结构"><a class="header" href="#索引结构">索引结构</a></h3>
<p>SP-GiST索引的结构包含内部节点和叶子节点：</p>
<ul>
<li><strong>内部节点</strong>：代表数据空间的分区，包含指向子节点的指针，这些指针基于分区策略定义的规则指向不同的区域。</li>
<li><strong>叶子节点</strong>：存储实际的数据项或指向数据项的指针。在叶子节点中，数据被组织在一起，因为它们属于同一个分区。</li>
</ul>
<h3 id="查询过程"><a class="header" href="#查询过程">查询过程</a></h3>
<p>查询SP-GiST索引时，根据查询条件和索引的分区策略，从根节点开始逐层向下遍历：</p>
<ol>
<li><strong>导航内部节点</strong>：在每个内部节点，根据分区逻辑确定哪些子节点可能包含查询条件指定的数据，然后遍历这些子节点。</li>
<li><strong>检查叶子节点</strong>：到达叶子节点后，检查其中的数据项以确定它们是否满足查询条件。</li>
</ol>
<h3 id="应用场景-1"><a class="header" href="#应用场景-1">应用场景</a></h3>
<p>SP-GiST索引适用于多种应用场景，特别是在处理空间数据和多维数据时表现出色，例如：</p>
<ul>
<li><strong>地理空间数据查询</strong>：对地理位置数据进行快速的范围查询和最近邻查询。</li>
<li><strong>多维数据查询</strong>：对多维数据进行有效的点查询和范围查询，如在推荐系统中查找最相似的项目。</li>
</ul>
<h3 id="特点和优势"><a class="header" href="#特点和优势">特点和优势</a></h3>
<ul>
<li><strong>灵活的分区策略</strong>：提供了对多种空间分区策略的支持，使得SP-GiST能够适应不同的数据分布和查询需求。</li>
<li><strong>高效的查询性能</strong>：特别是对于非均匀分布的数据，能够减少查询过程中需要访问的节点数量，提高查询效率。</li>
<li><strong>适用于复杂数据结构</strong>：如地理空间数据和多维数据，使其成为处理这类数据的理想选择。</li>
</ul>
<p>总之，SP-GiST索引通过其灵活的分区策略和高效的数据组织方式，为处理非均匀分布的数据和多维数据查询提供了强大的支持。</p>
<h1 id="brinblock-range-index索引-是如何工作的"><a class="header" href="#brinblock-range-index索引-是如何工作的">BRIN（Block Range INdex）索引 是如何工作的</a></h1>
<p>BRIN（Block Range Index）索引是PostgreSQL中一种用于加速对大数据集进行查询的索引类型，特别适用于数据按某种顺序存储的场景，如时间序列数据。BRIN索引的基本思想是对表中连续的物理块（pages）进行摘要信息的索引，而不是对每一行或每个值进行索引。这使得BRIN索引在处理大量数据时非常空间和时间高效，尤其是当数据自然按索引键排序时。</p>
<h3 id="工作原理-2"><a class="header" href="#工作原理-2">工作原理</a></h3>
<p>BRIN索引工作的基本原理如下：</p>
<ul>
<li><strong>块范围摘要</strong>：BRIN索引将表分成连续的块范围，每个范围包含多个物理块。对于每个块范围，BRIN记录该范围内的最小值和最大值（或其他摘要信息），这些信息构成了索引项。</li>
<li><strong>查询优化</strong>：当执行查询时，BRIN索引可以快速识别哪些块范围可能包含符合查询条件的行。如果查询条件与块范围的摘要信息不匹配，那么整个块范围可以被立即排除，从而避免扫描不相关的数据。</li>
</ul>
<h3 id="应用场景-2"><a class="header" href="#应用场景-2">应用场景</a></h3>
<p>BRIN索引特别适用于以下场景：</p>
<ul>
<li><strong>大量数据</strong>：适用于包含大量行的表，尤其是当这些数据根据索引键自然排序时（例如，按时间或地理位置排序的数据）。</li>
<li><strong>顺序存储的数据</strong>：当数据按索引键自然排序且查询通常涉及到这个排序键时，BRIN索引最有效。</li>
</ul>
<h3 id="优点"><a class="header" href="#优点">优点</a></h3>
<ul>
<li><strong>空间效率</strong>：BRIN索引只存储每个块范围的摘要信息，而不是每行的索引键，因此占用的空间非常小。</li>
<li><strong>构建速度</strong>：由于其简单的结构，BRIN索引可以非常快速地构建，即使是对非常大的表也是如此。</li>
<li><strong>查询性能</strong>：在适合其使用场景的查询中，BRIN索引可以显著减少数据扫描的量，提高查询性能。</li>
</ul>
<h3 id="缺点"><a class="header" href="#缺点">缺点</a></h3>
<ul>
<li><strong>数据分布依赖</strong>：BRIN索引的效率高度依赖于数据的物理存储顺序。如果数据不是按索引键排序的，那么BRIN索引可能不会提供太大的性能提升。</li>
<li><strong>维护成本</strong>：随着数据的插入、更新和删除，块范围内的摘要信息可能变得不准确，可能需要定期重新索引以保持查询性能。</li>
</ul>
<h3 id="使用和维护"><a class="header" href="#使用和维护">使用和维护</a></h3>
<ul>
<li><strong>创建索引</strong>：通过<code>CREATE INDEX</code>命令指定BRIN索引类型来创建索引。</li>
<li><strong>调整参数</strong>：可以调整块范围的大小以优化索引的效果，这依赖于数据的分布和查询模式。</li>
<li><strong>自动更新</strong>：BRIN索引会随着数据的变化自动更新，但在数据大量变化后，执行<code>REINDEX</code>可以提高其效率。</li>
</ul>
<p>BRIN索引提供了一种在大数据集上进行高效查询的方法，尤其是当数据按某种顺序存储时。通过智能地利用数据的物理存储特性，BRIN索引能够以极小的空间和维护成本提供快速的查询性能。</p>
<h1 id="gistgeneralized-search-tree索引是如何工作的"><a class="header" href="#gistgeneralized-search-tree索引是如何工作的">GiST（Generalized Search Tree）索引是如何工作的</a></h1>
<p>GiST（Generalized Search Tree）索引是PostgreSQL中一种提供高度灵活的索引框架，支持多种搜索算法的索引类型。GiST索引允许开发者为复杂的数据类型和查询定义自己的索引策略，包括但不限于几何数据类型的空间搜索、全文搜索以及其他任何可以定义排序规则的数据类型。GiST索引通过一个平衡树结构实现，这个结构类似于B-Tree，但提供了更多的灵活性，使其能够支持各种不同的搜索算法。以下是GiST索引工作原理的详细介绍：</p>
<h3 id="基本结构"><a class="header" href="#基本结构">基本结构</a></h3>
<ul>
<li><strong>节点</strong>：GiST索引是一种树状结构，包括根节点、内部节点和叶子节点。每个节点可以包含多个条目，这些条目根据索引的特定逻辑进行组织。</li>
<li><strong>条目</strong>：在内部节点中，每个条目包含一个指针指向子节点，以及一个“谓词”来描述子树（或子节点）包含的数据范围。在叶子节点中，条目直接引用表中的具体行。</li>
</ul>
<h3 id="索引操作"><a class="header" href="#索引操作">索引操作</a></h3>
<ul>
<li><strong>搜索</strong>：搜索操作从根节点开始，根据查询条件和节点中的谓词逐级向下遍历。在每个内部节点，根据谓词判断哪些子节点可能包含满足查询条件的数据，进而访问这些子节点。这个过程一直持续到叶子节点，最终找到满足条件的行。</li>
<li><strong>插入</strong>：插入新数据时，GiST索引根据定义的索引逻辑选择合适的叶子节点并将新条目插入。如有必要，进行节点分裂以保持树的平衡。</li>
<li><strong>删除和更新</strong>：删除或更新索引中的数据涉及到查找对应的叶子节点条目并进行相应的修改。如有必要，进行节点合并以保持树的平衡。</li>
</ul>
<h3 id="特点-1"><a class="header" href="#特点-1">特点</a></h3>
<ul>
<li><strong>灵活性</strong>：GiST提供了一个通用的框架，支持多种搜索算法。通过定义合适的谓词和索引逻辑，可以为各种复杂的数据类型和查询操作建立索引。</li>
<li><strong>扩展性</strong>：GiST允许开发者扩展PostgreSQL以支持新的数据类型和索引策略，使其能够应对各种特定的应用需求。</li>
<li><strong>多功能性</strong>：GiST支持范围查询、最近邻查询、全文搜索等多种类型的查询，覆盖了除传统B-Tree索引之外的广泛需求。</li>
</ul>
<h3 id="应用场景-3"><a class="header" href="#应用场景-3">应用场景</a></h3>
<ul>
<li><strong>空间数据索引</strong>：GiST被广泛用于空间数据库中，支持对几何对象进行高效的空间位置查询。</li>
<li><strong>全文搜索</strong>：通过支持全文搜索的操作，GiST可以用于构建文本搜索索引。</li>
<li><strong>其他复杂数据类型</strong>：例如，支持对网络地址、数组等进行索引的查询。</li>
</ul>
<p>总之，GiST索引通过其通用和灵活的框架，为PostgreSQL提供了支持广泛数据类型和复杂查询的能力，是一个强大的索引工具，适用于多种高级数据管理需求。</p>
<h1 id="wal-如何保证在不锁库的情况下支持并发控制和数据写入"><a class="header" href="#wal-如何保证在不锁库的情况下支持并发控制和数据写入">WAL 如何保证在不锁库的情况下支持并发控制和数据写入</a></h1>
<p>Write-Ahead Logging（WAL）是数据库管理系统中用于确保数据完整性和恢复能力的关键技术。WAL通过记录所有修改数据库状态的操作到日志中，在这些操作实际对数据库文件进行修改之前，确保这些操作被持久化。这种机制支持并发控制和数据写入的主要方式如下：</p>
<h3 id="并发控制"><a class="header" href="#并发控制">并发控制</a></h3>
<p>WAL本身主要关注数据的持久性和恢复，而并发控制则是通过多版本并发控制（MVCC）等技术实现的。不过，WAL与并发控制机制紧密协作，共同支持高效且安全的并发操作：</p>
<ul>
<li><strong>事务日志</strong>：WAL记录事务的所有变更，每个事务都有一个唯一的事务ID。这允许数据库在应用变更前先记录下变更，即使在并发环境下也能确保数据的一致性和完整性。</li>
<li><strong>恢复和回滚</strong>：在并发操作中，如果某个事务失败或需要回滚，WAL提供了必要的信息来撤销该事务的所有变更，而不影响其他并发运行的事务。</li>
</ul>
<h3 id="数据写入"><a class="header" href="#数据写入">数据写入</a></h3>
<p>WAL通过以下机制保证数据写入的安全性，同时避免了对数据库的全局锁定：</p>
<ul>
<li><strong>顺序写入</strong>：WAL日志是顺序写入的。相比于随机写入数据库文件，顺序写入减少了磁盘I/O的开销，提高了写入效率。这种方式特别适合并发写入，因为它避免了写入操作之间的竞争条件。</li>
<li><strong>延迟写入</strong>：实际的数据文件修改可以延迟进行，直到事务提交时才执行。在此之前，所有的修改都记录在WAL中。这样，即使发生系统崩溃，也能从WAL中恢复这些修改，而不需要在每次修改时都锁定数据库文件。</li>
<li><strong>检查点（Checkpoints）</strong>：定期将WAL中的数据同步到数据库文件中的操作称为检查点。检查点的存在减少了数据库恢复所需的时间，同时允许数据库在处理并发写入时维持较低的锁定需求。</li>
<li><strong>缓冲写入</strong>：数据库可以将数据先写入到缓冲区，在适当的时候再批量写入磁盘。这个过程由WAL日志顺序性和检查点机制支持，确保了数据的一致性，同时提高了并发写入的性能。</li>
</ul>
<p>总结来说，WAL通过记录事务的所有修改到顺序日志中，并结合MVCC等技术，实现了高效的并发控制和数据写入，而无需对整个数据库进行锁定。这种机制保证了即使在高并发环境下，数据库也能提供高性能和数据一致性保证。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docker-安装ubuntu"><a class="header" href="#docker-安装ubuntu"><a href="https://yeasy.gitbook.io/docker_practice/install/ubuntu">Docker 安装（Ubuntu）</a></a></h1>
<pre><code class="language-shell">curl -fsSL get.docker.com -o get-docker.sh
sudo sh get-docker.sh --mirror Aliyun
</code></pre>
<h1 id="启动docker"><a class="header" href="#启动docker">启动Docker</a></h1>
<pre><code class="language-shell">sudo systemctl enable docker
sudo systemctl start docker
</code></pre>
<h1 id="建立-docker用户组"><a class="header" href="#建立-docker用户组">建立 docker用户组</a></h1>
<pre><code class="language-shell">sudo groupadd docker
sudo usermod -aG docker $USER
newgrp docker # 刷新立即生效
# id 查看当前用户的信息
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-安装"><a class="header" href="#rust-安装"><a href="https://www.rust-lang.org/tools/install">Rust 安装</a></a></h1>
<pre><code class="language-shell">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
# 安装目录 ~/.cargo/bin
# 卸载 rustup self uninstall
</code></pre>
<h1 id="rust-升级"><a class="header" href="#rust-升级">Rust 升级</a></h1>
<pre><code class="language-shell"></code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
