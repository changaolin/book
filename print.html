<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>梦北</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="学习笔记">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">README</a></li><li class="chapter-item expanded "><a href="CPP/index.html"><strong aria-hidden="true">1.</strong> CPP学习笔记</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="CPP/Object.html"><strong aria-hidden="true">1.1.</strong> 类</a></li><li class="chapter-item expanded "><a href="CPP/STL.html"><strong aria-hidden="true">1.2.</strong> STL</a></li><li class="chapter-item expanded "><a href="CPP/Thread.html"><strong aria-hidden="true">1.3.</strong> Thread</a></li><li class="chapter-item expanded "><a href="CPP/TCP_socket.html"><strong aria-hidden="true">1.4.</strong> TCP_Socket</a></li><li class="chapter-item expanded "><a href="CPP/C++11.html"><strong aria-hidden="true">1.5.</strong> C++11</a></li><li class="chapter-item expanded "><a href="CPP/EMC++.html"><strong aria-hidden="true">1.6.</strong> Effective Modern C++</a></li></ol></li><li class="chapter-item expanded "><a href="Programmer/index.html"><strong aria-hidden="true">2.</strong> 程序员笔记</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Programmer/pkg_config.html"><strong aria-hidden="true">2.1.</strong> PKG-CONFIG</a></li></ol></li><li class="chapter-item expanded "><a href="Media/index.html"><strong aria-hidden="true">3.</strong> 流媒体笔记</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Media/ffmpeg_cmd.html"><strong aria-hidden="true">3.1.</strong> FFMPEG 命令行学习笔记</a></li><li class="chapter-item expanded "><a href="Media/ffmpeg_install.html"><strong aria-hidden="true">3.2.</strong> FFMPEG 安装 MACOS</a></li><li class="chapter-item expanded "><a href="Media/cmake.html"><strong aria-hidden="true">3.3.</strong> CMAKE 模板</a></li><li class="chapter-item expanded "><a href="Media/yuvplayer.html"><strong aria-hidden="true">3.4.</strong> YUVPLayer Demo(C)</a></li><li class="chapter-item expanded "><a href="Media/pcmplayer.html"><strong aria-hidden="true">3.5.</strong> PCMPLayer Demo(C)</a></li></ol></li><li class="chapter-item expanded "><a href="Redis/index.html"><strong aria-hidden="true">4.</strong> Redis</a></li><li class="chapter-item expanded "><a href="NET/index.html"><strong aria-hidden="true">5.</strong> NET</a></li><li class="chapter-item expanded "><a href="Vim/index.html"><strong aria-hidden="true">6.</strong> VIM</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Vim/ccls.html"><strong aria-hidden="true">6.1.</strong> CCLS</a></li></ol></li><li class="chapter-item expanded "><a href="Romanic/index.html"><strong aria-hidden="true">7.</strong> 四大浪漫</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Romanic/zoo.html"><strong aria-hidden="true">7.1.</strong> 计算机组成原理</a></li><li class="chapter-item expanded "><a href="Romanic/os.html"><strong aria-hidden="true">7.2.</strong> 操作系统实战笔记</a></li></ol></li><li class="chapter-item expanded "><a href="Tools/index.html"><strong aria-hidden="true">8.</strong> 工具</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Tools/Verilog.html"><strong aria-hidden="true">8.1.</strong> Verilog on MAC</a></li><li class="chapter-item expanded "><a href="Tools/Rules.html"><strong aria-hidden="true">8.2.</strong> Verilog语法规则</a></li></ol></li><li class="chapter-item expanded "><a href="WEB/index.html"><strong aria-hidden="true">9.</strong> Web</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="WEB/WebAssembly.html"><strong aria-hidden="true">9.1.</strong> WebAssembly</a></li></ol></li><li class="chapter-item expanded "><a href="Tools/index.html"><strong aria-hidden="true">10.</strong> Tools</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Tools/gparted.html"><strong aria-hidden="true">10.1.</strong> gparted</a></li></ol></li><li class="chapter-item expanded "><a href="ROS2/index.html"><strong aria-hidden="true">11.</strong> ROS2</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ROS2/ros2_qt_demo构建流程.html"><strong aria-hidden="true">11.1.</strong> ros2_qt_demo</a></li></ol></li><li class="chapter-item expanded "><a href="HASS/index.html"><strong aria-hidden="true">12.</strong> HASS</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="HASS/安装流程.html"><strong aria-hidden="true">12.1.</strong> HASS安装</a></li></ol></li><li class="chapter-item expanded "><a href="PostgreSQL/index.html"><strong aria-hidden="true">13.</strong> PostgreSQL</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">梦北</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="readme"><a class="header" href="#readme">README</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cpp学习笔记"><a class="header" href="#cpp学习笔记">CPP学习笔记</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基于类对象"><a class="header" href="#基于类对象">基于类（对象）</a></h1>
<ul>
<li>
<p>类是<font color='red'><strong>数据</strong></font>和数据的处理函数的一种组织形式。</p>
</li>
<li>
<p>类的设计要点（优先考虑<font color='red'><strong>数据</strong></font>的设计）：</p>
<ul>
<li>
<p>类Header 和 类Body</p>
</li>
<li>
<p>类分为无指针类，和有指针类（拷贝构造，delete []等）</p>
</li>
<li>
<p>构造函数无返回值，尽量使用构造参数列表形式。</p>
<ul>
<li>拷贝构造：String(const String&amp; str)</li>
<li>拷贝赋值：String&amp; operator=(const String&amp; str)  || return *this</li>
<li>委托构造</li>
</ul>
</li>
<li>
<p>函数构造需要考虑（名称-参数（类型，权限）-返回值（类型，权限））：</p>
<ul>
<li>函数分为类内函数和全局函数（const 放在 成员函数上，不放在全局函数上）</li>
<li>参数类型，仅可能的使用引用传递</li>
<li>考虑是否使用const 修饰入参</li>
<li>返回值尽可能使用引用返回</li>
<li>考虑返回值是否使用const</li>
</ul>
</li>
<li>
<p>static</p>
<ul>
<li>静态函数只能处理静态数据</li>
<li>static 数据只有一份：instance</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="面向对象"><a class="header" href="#面向对象">面向对象</a></h1>
<ul>
<li>复合 （内存 has a， Container / Component）
<ul>
<li>构造由内到外</li>
<li>析构由外到内</li>
</ul>
</li>
<li>委托（复合 by reference，Handle / Body）
<ul>
<li>共享，引用计数</li>
</ul>
</li>
<li>继承（is a，子类中有一部分父类的信息，继承数据，继承函数的调用权）
<ul>
<li>构造由内（父类）而外</li>
<li>析构由外而内</li>
<li>虚函数（virtual）
<ul>
<li>非虚函数：override 不希望子类重写</li>
<li>虚函数：希望子类override 重写，已经有默认实现</li>
<li>纯虚函数：子类必须override vitual func = 0;，没有默认实现</li>
<li>虚指针 &amp;&amp; 虚表（静态绑定-- call某个地址 ｜ 动态--绑定看调用方，多态）
<ul>
<li>一定是指针调用触发 虚链路（多态）</li>
<li>三个条件：指针，虚函数，向上转型</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="1-零散"><a class="header" href="#1-零散">1 零散</a></h1>
<h2 id="转换函数"><a class="header" href="#转换函数">转换函数</a></h2>
<h2 id="explict明白的明确的"><a class="header" href="#explict明白的明确的">explict（明白的，明确的）</a></h2>
<ul>
<li>non-explict-one-argument ctor</li>
</ul>
<h2 id="pointer-likeclass智能指针迭代器"><a class="header" href="#pointer-likeclass智能指针迭代器">Pointer-likeClass（智能指针，迭代器）</a></h2>
<h2 id="function-likeclass仿函数"><a class="header" href="#function-likeclass仿函数">Function-likeClass（仿函数）</a></h2>
<h2 id="类模板"><a class="header" href="#类模板">类模板</a></h2>
<ul>
<li>使用时指定类型</li>
</ul>
<h2 id="函数模板"><a class="header" href="#函数模板">函数模板</a></h2>
<h2 id="成员模板"><a class="header" href="#成员模板">成员模板</a></h2>
<h2 id="模板特化全偏特化-范围个数缩小"><a class="header" href="#模板特化全偏特化-范围个数缩小">模板特化（全/偏特化-范围｜个数缩小）</a></h2>
<h2 id="模板模板参数"><a class="header" href="#模板模板参数">模板模板参数</a></h2>
<h2 id="数量不定的模板参数typename-typessizeofargs"><a class="header" href="#数量不定的模板参数typename-typessizeofargs">数量不定的模板参数：typename... Types：sizeof...(args)</a></h2>
<h2 id="auto编译时推理"><a class="header" href="#auto编译时推理">auto（编译时推理）</a></h2>
<ul>
<li>声明时需要定义</li>
</ul>
<h2 id="objectmodel"><a class="header" href="#objectmodel">ObjectModel</a></h2>
<ul>
<li>虚指针（vptr）</li>
<li>虚表（vtbl）</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stl"><a class="header" href="#stl">STL</a></h1>
<p><a href="CPP/../resource/Slide.pdf">参考资料</a></p>
<p><a href="CPP/../resource/sample.cpp">源码</a></p>
<p><img src="CPP/../assets/STL.png" alt="截屏2022-06-22 20.23.54" /></p>
<h1 id="容器container"><a class="header" href="#容器container">容器（Container）</a></h1>
<p>前闭后开</p>
<h2 id="结构与分类"><a class="header" href="#结构与分类">结构与分类</a></h2>
<ul>
<li>序列容器
<ul>
<li>Array(固定空间)</li>
<li>Vector</li>
<li>Deque</li>
<li>List
<ul>
<li>Forward-List（单向链表）</li>
</ul>
</li>
</ul>
</li>
<li>关联容器（key:value）
<ul>
<li>Set/Multiset
<ul>
<li>Unordered Set/Multiset</li>
</ul>
</li>
<li>Map/Multimap
<ul>
<li>Unordered Map/Multimap</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="list"><a class="header" href="#list">List</a></h2>
<ul>
<li>双向链表</li>
<li>迭代器是class，</li>
</ul>
<h2 id="vector"><a class="header" href="#vector">Vector</a></h2>
<ul>
<li>2倍动态增长</li>
<li>不能原地扩充</li>
<li>迭代器是原始指针</li>
</ul>
<h2 id="deque"><a class="header" href="#deque">Deque</a></h2>
<ul>
<li>分段Buffer</li>
<li>双向扩充</li>
<li>begin</li>
<li>end</li>
<li>iterator
<ul>
<li>cur</li>
<li>first</li>
<li>end</li>
<li>node</li>
</ul>
</li>
</ul>
<h1 id="分配器allocators"><a class="header" href="#分配器allocators">分配器（Allocators）</a></h1>
<ul>
<li>VC6 的分配器没有特殊设计，调用的是 malloc和free</li>
<li>BC5 的分配器也没有特殊设计</li>
<li>GCC
<ul>
<li>&lt;stl_alloc.h&gt;</li>
</ul>
</li>
</ul>
<h1 id="算法algorithms"><a class="header" href="#算法algorithms">算法（Algorithms）</a></h1>
<ul>
<li>所有的算法，最终的行为无非就是比大小。</li>
<li>算法问迭代器问题</li>
</ul>
<h2 id="1-算法是一个函数模板"><a class="header" href="#1-算法是一个函数模板">1. 算法是一个函数模板</a></h2>
<pre><code>- 从语言层次来讲，算法是一个函数模板
- 其余部件都是一个类模板
</code></pre>
<h2 id="2-处理迭代器"><a class="header" href="#2-处理迭代器">2. 处理迭代器</a></h2>
<h2 id="3-实例"><a class="header" href="#3-实例">3. 实例</a></h2>
<ul>
<li>accumulate（累计）</li>
<li>for_each</li>
<li>replace
<ul>
<li>replace_if</li>
<li>replace_copy</li>
</ul>
</li>
<li>count
<ul>
<li>count_if</li>
</ul>
</li>
<li>find
<ul>
<li>find_if</li>
</ul>
</li>
<li>sort</li>
<li>binary_search</li>
</ul>
<h1 id="迭代器iterators"><a class="header" href="#迭代器iterators">迭代器（Iterators）</a></h1>
<p><img src="CPP/../assets/%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E5%9E%8B.png" alt="截屏2022-06-22 12.52.02" /></p>
<h2 id="1-五种相关类型"><a class="header" href="#1-五种相关类型">1. 五种相关类型</a></h2>
<ul>
<li>iterator_category （分类）</li>
<li>distance（两个iterator之间的距离的类型）</li>
<li>value_type（数据类型）</li>
<li>reference</li>
<li>pointer</li>
</ul>
<h2 id="2-traits中间层"><a class="header" href="#2-traits中间层">2. traits（中间层）</a></h2>
<ul>
<li>用于封装原生指针，用以实现上述五种类型的数据。</li>
</ul>
<h2 id="3-接口"><a class="header" href="#3-接口">3. 接口</a></h2>
<div class="table-wrapper"><table><thead><tr><th>名称</th><th>初始化</th><th>前</th><th>后</th><th>首元素</th><th>尾元素</th><th>随机</th><th>随机查询</th><th>大小</th><th>容积</th><th>反转</th><th>重设大小</th></tr></thead><tbody>
<tr><td><a href="https://en.cppreference.com/w/cpp/header/array">array</a></td><td></td><td></td><td>[push|pop]_back</td><td>front</td><td>back</td><td>[]/insert/erase</td><td>[].data</td><td>size</td><td>capacity</td><td></td><td></td></tr>
<tr><td>vector</td><td>vector<int>v1</td><td></td><td>[push|pop]_back</td><td></td><td></td><td></td><td></td><td></td><td></td><td>reserve</td><td></td></tr>
<tr><td>stack</td><td></td><td>pop</td><td>push</td><td>top</td><td></td><td></td><td></td><td>size</td><td></td><td></td><td></td></tr>
<tr><td><a href="https://zh.cppreference.com/w/cpp/container/deque">queue</a></td><td></td><td>push</td><td>pop</td><td>front</td><td>back</td><td></td><td></td><td>Size</td><td></td><td></td><td></td></tr>
<tr><td>deque</td><td></td><td>[push|pop]_front</td><td>[push|pop]_back</td><td>front</td><td>back</td><td>insert/erase</td><td></td><td>size</td><td></td><td></td><td>resize</td></tr>
<tr><td>Forward-list</td><td></td><td>[push|pop]_front</td><td></td><td>front</td><td>back</td><td>insert/erase</td><td></td><td></td><td></td><td></td><td>resize</td></tr>
<tr><td>list</td><td></td><td>[push|pop]_front</td><td>[push|pop]_back</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>set/mutiset</td><td></td><td></td><td></td><td></td><td></td><td>insert/erase</td><td></td><td>Size</td><td></td><td></td><td></td></tr>
<tr><td>map/multimap</td><td></td><td></td><td></td><td></td><td></td><td>insert/erase</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>string</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>tuple</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div>
<h1 id="适配器adapters"><a class="header" href="#适配器adapters">适配器（Adapters）</a></h1>
<ul>
<li>容器的适配器
<ul>
<li>stack</li>
<li>queue</li>
</ul>
</li>
<li>函数适配器
<ul>
<li>bind2nd
<ul>
<li>binder2nd</li>
</ul>
</li>
<li>nto1（取反）</li>
</ul>
</li>
<li>新形式的适配器
<ul>
<li>bind</li>
</ul>
</li>
</ul>
<h1 id="仿函数functors"><a class="header" href="#仿函数functors">仿函数（Functors）</a></h1>
<ul>
<li>STL 的仿函数必须public继承binary_function或者unary_function之后才能被适配器适配</li>
</ul>
<h2 id="1-算术类-"><a class="header" href="#1-算术类-">1. 算术类（+/-）</a></h2>
<h2 id="2-逻辑运算类-"><a class="header" href="#2-逻辑运算类-">2. 逻辑运算类（&amp;&amp; ||）</a></h2>
<h2 id="3-相对关系类---"><a class="header" href="#3-相对关系类---">3. 相对关系类( &lt; | &gt;=)</a></h2>
<h2 id="4-binary_function两个操作数"><a class="header" href="#4-binary_function两个操作数">4. binary_function:（两个操作数）</a></h2>
<h2 id="5-unary_function一个操作数"><a class="header" href="#5-unary_function一个操作数">5. unary_function（一个操作数）</a></h2>
<h1 id="标准库其他"><a class="header" href="#标准库其他">标准库其他</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="thread"><a class="header" href="#thread">Thread</a></h1>
<h1 id="一主要函数"><a class="header" href="#一主要函数">一、主要函数</a></h1>
<pre><code class="language-C"> #include &lt;pthread.h&gt;

int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg)
int pthread_join(pthread_t thread, void **value_ptr)
 # ps -Lf pid 
int pthread_cancel(pthread_t thread)
int pthread_detach(pthread_t thread)
void pthread_exit(void *value_ptr)
int pthread_kill(pthread_t thread, int sig)
int pthread_once(pthread_once_t *once_control, void (*init_routine)(void))
pthread_t pthread_self(void)
pthread_equal(tid1, tid2)
</code></pre>
<h1 id="二具体功能"><a class="header" href="#二具体功能">二、具体功能</a></h1>
<h2 id="21-线程的创建"><a class="header" href="#21-线程的创建">2.1 线程的创建</a></h2>
<h2 id="22-线程的中止"><a class="header" href="#22-线程的中止">2.2 线程的中止</a></h2>
<h3 id="221-异常终止"><a class="header" href="#221-异常终止">2.2.1 异常终止</a></h3>
<ul>
<li>主线程退出，子线程被强行终止</li>
<li>子线程中调用 exit()，则整个<strong>进程</strong>全部退出</li>
<li>缺省行为是终止程序的信号，会终止整个<strong>进程</strong></li>
</ul>
<h3 id="222-正常终止"><a class="header" href="#222-正常终止">2.2.2 正常终止</a></h3>
<ul>
<li>线程使用 return 返回，return 0 无需转换，return (void*) 1; 返回值是线程的结束码。</li>
<li>线程可以被同一进程的其他线程调用 pthread_cancel() 结束。</li>
<li>在线程中调用 pthread_exit((void*)1) 退出</li>
</ul>
<h2 id="23-线程的参数传递"><a class="header" href="#23-线程的参数传递">2.3 线程的参数传递</a></h2>
<ul>
<li>线程创建顺序和线程运行顺序并不保证一致。</li>
<li>全局变量不能代替线程的参数传递</li>
<li>参数需要类型类型强制转换</li>
<li>传递整型参数
<ul>
<li>pthread_create(&amp;pid, NULL, func, (void*)(long) number))</li>
<li>printf(&quot;%d&quot;, (int)(long)arg)</li>
</ul>
</li>
<li>传递地址参数(需要给每个线程传递一个单独的地址，不能使用同一个地址：全局变量)
<ul>
<li>int* var1 = new int; *var = 1;</li>
<li>pthread_create(&amp;pid, NULL, func, var1))</li>
<li>printf(&quot;%xx&quot;, *(int*)arg)</li>
<li>var1 需要在线程中释放内存。 delete  (int*)arg;</li>
</ul>
</li>
<li>线程退出状态
<ul>
<li>void* pv = 0;</li>
<li>pthread_join(pid, &amp;pv);</li>
<li>pv 保存线程 返回的值。</li>
</ul>
</li>
</ul>
<h2 id="24-线程资源的回收"><a class="header" href="#24-线程资源的回收">2.4 线程资源的回收</a></h2>
<ul>
<li>线程分离
<ul>
<li>joinable(默认状态)，在线程结束时，之后不会释放全部的资源，而是等待join，join之后资源才会释放（因此只能join一次）
<ul>
<li>pthread_join()</li>
<li>pthread_tryjoin_np()</li>
<li>pthread_timedjoin_np()</li>
</ul>
</li>
<li>unjoinable（不可分离）
<ul>
<li>pthread_detach(tid);
<ul>
<li>可以放在线程函数中 pthread_detach(pthread_self());</li>
</ul>
</li>
<li>创建线程前，调用pthread_attr_setdetachstat()设置线程属性。</li>
</ul>
</li>
</ul>
</li>
<li>线程清理函数释放资源
<ul>
<li>pthread_cleanup_push(func)</li>
<li>pthread_cleanup_pop(1)
<ul>
<li>填 0 标识 只退出不执行清理函数</li>
<li>非 0 则会退出并执行清理函数</li>
</ul>
</li>
<li>可以有多个线程清理函数，但必须push和pop成对在<strong>同一语句块</strong>中出现</li>
<li>在线程退出时 会调用线程清理函数。
<ul>
<li>pthread_exit()</li>
<li>return</li>
<li>Pthread_cancel()</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="25-线程取消"><a class="header" href="#25-线程取消">2.5 线程取消</a></h2>
<ul>
<li>可以被join</li>
<li>返回值 为 PTHREAD_CANCELED ，即 -1</li>
<li>pthread_setcancelstate() 设置线程的取消状态
<ul>
<li>只能放在线程的主函数中</li>
<li>可以被取消</li>
<li>不可以被取消</li>
</ul>
</li>
<li>pthread_setcacheltype() 设置线程的取消类型
<ul>
<li>立即取消</li>
<li>执行到 取消点是进行取消（默认）
<ul>
<li>accept()</li>
<li>close()</li>
<li>pthread_testcancel()； 设置取消点</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="26-线程与信号"><a class="header" href="#26-线程与信号">2.6 线程与信号</a></h2>
<ul>
<li>在多线程程序中，外部向进程发送信号不会中断系统调用</li>
<li>在多线程程序中，信号的处理是所有线程共享的</li>
<li>进程中的信号可以送达单个线程，会中断系统调用
<ul>
<li>pthread_kill(tid, sig)</li>
</ul>
</li>
<li>如果某个线程因为信号被终止，则整个进程都会被终止</li>
</ul>
<h2 id="27-线程安全"><a class="header" href="#27-线程安全">2.7 线程安全</a></h2>
<ul>
<li>原子性，可见行，顺序性
<ul>
<li>volatile
<ul>
<li>不从缓存中读取数据，而是从内存中读取</li>
<li>禁止代码重排序</li>
<li>不是原子的</li>
</ul>
</li>
</ul>
</li>
<li>原子操作
<ul>
<li>原子操作函数</li>
<li>CAS执行</li>
<li>原子类型 std::atomic&lt;int&gt; var;</li>
</ul>
</li>
<li>线程同步锁</li>
</ul>
<h2 id="28-线程同步"><a class="header" href="#28-线程同步">2.8 线程同步</a></h2>
<h3 id="281-互斥锁"><a class="header" href="#281-互斥锁">2.8.1 互斥锁</a></h3>
<ul>
<li>加锁解锁，其他等待</li>
<li>mutex</li>
</ul>
<h3 id="282-自旋锁"><a class="header" href="#282-自旋锁">2.8.2 自旋锁</a></h3>
<ul>
<li>加锁解锁，其他不等待</li>
<li>spin</li>
<li>共享标志</li>
</ul>
<h3 id="283-读写锁"><a class="header" href="#283-读写锁">2.8.3 读写锁</a></h3>
<ul>
<li>读模式加锁（可以多个持有读锁）</li>
<li>写模式加锁（只有不加锁的时候才能申请写锁，只能有一个持有写锁）</li>
<li>不加锁</li>
<li>rw</li>
</ul>
<h3 id="284-条件变量专为生产消费者设计"><a class="header" href="#284-条件变量专为生产消费者设计">2.8.4 条件变量（专为生产消费者设计）</a></h3>
<ul>
<li>
<p>与互斥锁一起使用</p>
</li>
<li>
<p>pthread_cond_wait() 等待被唤醒</p>
<ul>
<li>把互斥锁解锁</li>
<li>阻塞，等待信号唤醒</li>
<li>条件被触发+互斥锁加锁 （原子操作）</li>
</ul>
<pre><code class="language-c">pthread_cond_timedwait();  // 等待被唤醒，带超时机制
pthread_cond_signal();  // 唤醒一个等待中的线程
pthread_cond_broadcast(); // 唤醒全部等待中的线程
</code></pre>
</li>
</ul>
<h3 id="285-匿名信号量"><a class="header" href="#285-匿名信号量">2.8.5 （匿名）信号量</a></h3>
<ul>
<li>
<p>一个整数计数器，数值表示空闲的临界资源的数量</p>
</li>
<li>
<p>申请资源时，信号量减少</p>
</li>
<li>
<p>释放资源后，信号量增加</p>
<pre><code class="language-C">sem_t sem;
int sem_init();
int sem_destroy();
int sem_wait(sem_t* sem); //P操作
int sem_trywait(sem_t* sem); // P操作，不阻塞
int sem_timedwait(sem_t* sem); // P操作，超时
int sem_post(sem_t* sem); //V操作
int sem_getvalue(); // 获取信号想的值
</code></pre>
</li>
</ul>
<h3 id="286-生产消费者模型"><a class="header" href="#286-生产消费者模型">2.8.6 生产消费者模型</a></h3>
<ul>
<li>基本概念</li>
<li>互斥锁 + 条件变量实现生产消费者模型
<ul>
<li>在线程清理函数中需要释放 互斥锁</li>
</ul>
</li>
<li>信号量 实现生产消费者模型
<ul>
<li>需要手动加锁解锁（或者使用信号量代替互斥锁）</li>
</ul>
</li>
</ul>
<h3 id="287-多线程程序"><a class="header" href="#287-多线程程序">2.8.7 多线程程序</a></h3>
<ul>
<li>全局变量的线程安全</li>
<li>是否有不可重入函数</li>
</ul>
<p><img src="CPP/../assets/%E5%AE%89%E5%85%A8%E5%87%BD%E6%95%B0.png" alt="安全函数" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tcp_socket"><a class="header" href="#tcp_socket">TCP_Socket</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c11语言"><a class="header" href="#c11语言">C++11语言</a></h1>
<h2 id="0-关键字"><a class="header" href="#0-关键字">0. 关键字</a></h2>
<p><img src="CPP/../assets/C11%E5%85%B3%E9%94%AE%E5%AD%97.png" alt="截屏2022-06-30 22.15.35" /></p>
<h3 id="01-explcit"><a class="header" href="#01-explcit">0.1 explcit</a></h3>
<h3 id="02-noexcept"><a class="header" href="#02-noexcept">0.2 noexcept</a></h3>
<h3 id="03-const"><a class="header" href="#03-const">0.3 const...</a></h3>
<h3 id="04-const"><a class="header" href="#04-const">0.4 const</a></h3>
<h3 id="05-static"><a class="header" href="#05-static">0.5 static</a></h3>
<h3 id="06-typeplate"><a class="header" href="#06-typeplate">0.6 typeplate</a></h3>
<h3 id="07-tpyename"><a class="header" href="#07-tpyename">0.7 tpyename</a></h3>
<h3 id="08-class"><a class="header" href="#08-class">0.8 class</a></h3>
<h3 id="09-decltype"><a class="header" href="#09-decltype">0.9 decltype</a></h3>
<h3 id="010-auto"><a class="header" href="#010-auto">0.10 auto</a></h3>
<h3 id="011-public"><a class="header" href="#011-public">0.11 public</a></h3>
<h3 id="012-private"><a class="header" href="#012-private">0.12 private</a></h3>
<h3 id="013-proteced"><a class="header" href="#013-proteced">0.13 proteced</a></h3>
<h3 id="014-virtual"><a class="header" href="#014-virtual">0.14 virtual</a></h3>
<h2 id="015"><a class="header" href="#015">0.15</a></h2>
<h2 id="1-lambda"><a class="header" href="#1-lambda">1. lambda</a></h2>
<ul>
<li>格式
<ul>
<li>[=, &amp;](int x, char y) mutable~opt~ throwSpec~opt~ -&gt;retType~opt~ {...}</li>
</ul>
</li>
</ul>
<h2 id="2-variadic-templates"><a class="header" href="#2-variadic-templates">2. Variadic Templates</a></h2>
<ul>
<li>参数类型变化</li>
<li>参数个数变化</li>
<li>函数</li>
<li>class</li>
<li>模版</li>
</ul>
<pre><code class="language-c++">// 不可省略，作为递归的出口
void func()
{
  
}
template &lt;typename T, typename... Types&gt;
void func(const T&amp; firstArg, const Types&amp;... args) // ... 是类型的参数一部分
{
  处理 firstArg;
  // sizeof...(args); 用于得到args参数的个数
	func(args...);
}
//////////////////////////////////////////////////////////////////////////////
template &lt;typename... Args&gt;
ostream&amp; operator&lt;&lt; (ostream&amp; os, const tuple&lt;Args...&gt;&amp; t) {
  os &lt;&lt; &quot;[&quot; &lt;&lt; PRINT_TUPLE&lt;0, sizeof...(Args), Args...&gt;::print(os, t);
  return os &lt;&lt; &quot;]&quot;;
}
template &lt;int IDX, int MAX, typename... Args&gt;
struct PRINT_TUPLE {
  static void print(ostream&amp; os, const tuple&lt;Args...&gt;&amp; t) {
    os &lt;&lt; get&lt;IDX&gt;(t) &lt;&lt; (IDX + 1 == MAX) ? &quot;&quot; : &quot;,&quot;;
    PRINT_TUPLE&lt;IDX+1, MAX, Args...&gt;::print(os, t);
  }
}
template &lt;int MAX, typename... Args&gt;
struct PRINT_TYPLE&lt;MAX, MAX, Args...&gt; {
 static void print(ostream&amp; os, const tuple&lt;Args...&gt;&amp; t) {
 }
}

// cout &lt;&lt; make_tuple(7.5, string(&quot;hello&quot;), 32, 42)
// [7.5,hello,32,42]

/////////////////////////////////////////////////////////////////////////////
// 递归的继承
</code></pre>
<p><img src="CPP/../assets/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF.png" alt="截屏2022-06-30 21.56.25" /></p>
<p><img src="CPP/../assets/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF2.png" alt="截屏2022-06-30 22.04.50" /></p>
<p><img src="CPP/../assets/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF3.png" alt="截屏2022-06-30 22.07.23" /></p>
<p><img src="CPP/../assets/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF4.png" alt="截屏2022-06-30 22.13.34" /></p>
<h2 id="3-initializer_lists"><a class="header" href="#3-initializer_lists">3. initializer_lists</a></h2>
<h1 id="c11标准库"><a class="header" href="#c11标准库">c++11标准库</a></h1>
<h2 id="右值引用move"><a class="header" href="#右值引用move">右值引用｜Move</a></h2>
<ul>
<li>右值通常是临时对象，不能出现在等号左边</li>
<li>拷贝指针（必须有指针）</li>
<li>使用 std::move(left_value) 来将左值引用当作右值引用，来使用move语义</li>
</ul>
<pre><code class="language-c++">M c1(c);
M c2(std::move(c1)); // 必须确保后续不在使用c1
cl.swap(c2);

// move ctor
MyString（MyString	&amp;&amp; str） noexcept: initization list {}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="effective-moderc-c"><a class="header" href="#effective-moderc-c">Effective Moderc C++</a></h1>
<h1 id="零"><a class="header" href="#零">零</a></h1>
<h2 id="类型名称值址权限"><a class="header" href="#类型名称值址权限">类型，名称，值，址，权限</a></h2>
<p>int a = 10;</p>
<p>const char* val; </p>
<p>char* const val;</p>
<h1 id="一类型推导"><a class="header" href="#一类型推导">一、类型推导</a></h1>
<h2 id="11-理解模版类型推导"><a class="header" href="#11-理解模版类型推导">1.1 理解模版类型推导</a></h2>
<pre><code class="language-c++">template&lt;typename T&gt;
void f(ParamType param);
f(expr)
</code></pre>
<h3 id="111-paramtype-是指针或者引用但不是万能引用万能引用对左值和右值的处理方式不一样"><a class="header" href="#111-paramtype-是指针或者引用但不是万能引用万能引用对左值和右值的处理方式不一样">1.1.1 ParamType 是指针或者引用，但不是万能引用（万能引用对左值和右值的处理方式不一样）</a></h3>
<ul>
<li>忽略<em>expt</em>的引用类型</li>
<li>对<em>expr</em>的类型和<em>ParamType</em> 进行模式匹配，确定<em>T</em>的类型</li>
</ul>
<pre><code class="language-c++">template&lt;typename T&gt;
void f(T&amp; param); // param是个引用

int X = 27;  // x的型别是int
const int cx = x;  // cx 的型别是 const int
const int&amp; rx = x; // rx 是 x 的型别为 const int 的引用

f(x); // T 的型别是 int. param 的型别是 int&amp;
f(cx); // T 的型别是 const int, param 的型别是 const int&amp; 
f(rx); // T 的和别是 const int, param 的和别是 const int&amp;
</code></pre>
<h3 id="112-paramtype-是个万能引用"><a class="header" href="#112-paramtype-是个万能引用">1.1.2 ParamType 是个万能引用</a></h3>
<ul>
<li>如果 <em>expr</em> 是个左值，<em>T</em>和<em>ParamType</em>都会被推导为左值引用
<ul>
<li>首先，这是在模板型别推导中， T 被推导为引用型别的唯一情形。 </li>
<li>其次，尽管在声明时使用的是右值引用语法，它的型别推导结果却是左值引用。</li>
</ul>
</li>
<li>如果 <em>expr</em> 是个右值，则使用 1.1.1 的规则</li>
</ul>
<pre><code class="language-c++">template&lt;typename T&gt; 
void f(T&amp;&amp; param); // param现在是个万能引用

int X = 27;
const int ex = x;
const int&amp; rx = x;

f(x);  // X 是个左值，所以 T 的型别是 int&amp;, param 的 型别也是 int&amp;
f(cx); // cx 是个左值，所以 T 的型别是 const int&amp;, param 的型别也是 const int&amp;
f(rx); // rx 是个左值，所以 T 的型别是 const int&amp;, param 的型别也是 const int&amp;
f(27); //27 是个右值，所以 T 的型别是 int, 这么 一来, param的型别就成 int&amp;&amp;
</code></pre>
<h3 id="113-paramtype既不是指针或者引用也不是万能指针"><a class="header" href="#113-paramtype既不是指针或者引用也不是万能指针">1.1.3 ParamType既不是指针或者引用，也不是万能指针</a></h3>
<ul>
<li>若 expr具有引用型别，则忽略其引用部分。</li>
<li>忽略 expr 的引用性之后，若 expr 是个 const 对象，也忽略之。若其是个 volatile 对象，同忽略之</li>
</ul>
<pre><code class="language-c++">template&lt;typename T&gt;
void f(T param); // param现在是按值传递

intX =27;
const int cx = x; 
const int&amp; rx = x;

f(x); // T 和 param 的节别都是 int
f(cx); //T 和 param 的型别还都是 int
f(rx); //T 和 param 的型别仍都是 int
/*
请注意，即使 cx 和 rx 代表 const 值， param 仍然不具有 const 型别。这是合理的 。 
param 是个完全独立千 cx 和 rx 存在的对象 cx 和 rx 的 一 个副本。
从而 cx 和 rx 不可修改这一事实并不能说明 param是否可以修改。
正是由于这一原因， expr 的常址 性以及挥发性 (volatileness, 若有)可以在推导 param 的型别时加以忽略:
仅仅由千 expr 不可修改，并不能断定其副本也不可修改。
*/
</code></pre>
<h2 id="11-auto"><a class="header" href="#11-auto">1.1 auto</a></h2>
<h2 id="12-decltype"><a class="header" href="#12-decltype">1.2 decltype</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="程序员笔记"><a class="header" href="#程序员笔记">程序员笔记</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pkg-config"><a class="header" href="#pkg-config">PKG-CONFIG</a></h1>
<h2 id="地址"><a class="header" href="#地址"><a href="https://www.freedesktop.org/wiki/Software/pkg-config/">地址</a></a></h2>
<h2 id="一般用法"><a class="header" href="#一般用法">一般用法</a></h2>
<pre><code class="language-shell"> gcc -o test test.c `pkg-config --libs --cflags glib-2.0`
</code></pre>
<h2 id="环境变量"><a class="header" href="#环境变量">环境变量</a></h2>
<pre><code class="language-shell">export PKG_CONGIG_PATH=$PKG_CONFIG_PATH
</code></pre>
<h2 id="常用参数"><a class="header" href="#常用参数">常用参数</a></h2>
<pre><code>--cflags # -I/usr/include/***

--libs # -L/usr/lib/***

--list-all # 查看所有模块信息

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="流媒体笔记"><a class="header" href="#流媒体笔记">流媒体笔记</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ffmpeg-命令行学习"><a class="header" href="#ffmpeg-命令行学习">FFMPEG 命令行学习</a></h1>
<h1 id="命令分类"><a class="header" href="#命令分类"><a href="http://ffmpeg.org/ffmpeg.html">命令分类</a></a></h1>
<h2 id="0-基本格式"><a class="header" href="#0-基本格式">0. 基本格式</a></h2>
<pre><code class="language-shell">ffmpeg [global_options] {[input_file_options] -i input_url} ... {[output_file_options] output_url} ...
</code></pre>
<h2 id="input_url--i"><a class="header" href="#input_url--i">Input_url (-i)</a></h2>
<ul>
<li>regular files</li>
<li>pipes</li>
<li>network streams</li>
<li>grabbing devices</li>
<li>Based 0 numbers</li>
<li>...</li>
</ul>
<h2 id="input-or-output-data-types"><a class="header" href="#input-or-output-data-types">Input or output data types</a></h2>
<ul>
<li>video</li>
<li>audios</li>
<li>subtitles</li>
<li>attachment</li>
<li>data</li>
</ul>
<h2 id="stream"><a class="header" href="#stream">Stream</a></h2>
<h3 id="selection"><a class="header" href="#selection">selection</a></h3>
<ul>
<li>-map (attachment streams can only use map)</li>
<li>-vn</li>
<li>-an</li>
<li>-sn</li>
<li>-dn</li>
</ul>
<h3 id="handling"><a class="header" href="#handling">handling</a></h3>
<ul>
<li>-codec</li>
</ul>
<h3 id="example"><a class="header" href="#example">example</a></h3>
<pre><code>input file 'A.avi'
      stream 0: video 640x360
      stream 1: audio 2 channels

input file 'B.mp4'
      stream 0: video 1920x1080
      stream 1: audio 2 channels
      stream 2: subtitles (text)
      stream 3: audio 5.1 channels
      stream 4: subtitles (text)

input file 'C.mkv'
      stream 0: video 1280x720
      stream 1: audio 2 channels
      stream 2: subtitles (image)
      
ffmpeg -i A.avi -i B.mp4 out1.mkv out2.wav -map 1:a -c:a copy out3.mov
MKV: a/v/s from B-0/B-3/B-2
WAV: a B-3
out3.mov/MAP: B-Audio
</code></pre>
<pre><code>ffmpeg -i C.mkv out1.mkv -c:s dvdsub -an out2.mkv
</code></pre>
<pre><code>ffmpeg -i A.avi -i C.mkv -i B.mp4 -filter_complex &quot;overlay&quot; out1.mp4 out2.srt
</code></pre>
<pre><code>ffmpeg -i A.avi -i B.mp4 -i C.mkv -filter_complex &quot;[1:v]hue=s=0[outv];overlay;aresample&quot; \
       -map '[outv]' -an        out1.mp4 \
                                out2.mkv \
       -map '[outv]' -map 1:a:0 out3.mkv
fail
</code></pre>
<pre><code>ffmpeg -i A.avi -i B.mp4 -i C.mkv -filter_complex &quot;[1:v]hue=s=0[outv];overlay;aresample&quot; \
       -an        out1.mp4 \
                  out2.mkv \
       -map 1:a:0 out3.mkv
       
fail
</code></pre>
<pre><code>ffmpeg -i A.avi -i B.mp4 -i C.mkv -filter_complex &quot;[1:v]hue=s=0,split=2[outv1][outv2];overlay;aresample&quot; \
        -map '[outv1]' -an        out1.mp4 \
                                  out2.mkv \
        -map '[outv2]' -map 1:a:0 out3.mkv
success
</code></pre>
<h2 id="基本流程"><a class="header" href="#基本流程">基本流程</a></h2>
<pre><code> _______              ______________
|       |            |              |
| input |  demuxer   | encoded data |   decoder
| file  | ---------&gt; | packets      | -----+
|_______|            |______________|      |
                                           v
                                       _________
                                      |         |
                                      | decoded |
                                      | frames  |
                                      |_________|
 ________             ______________       |
|        |           |              |      |
| output | &lt;-------- | encoded data | &lt;----+
| file   |   muxer   | packets      |   encoder
|________|           |______________|


</code></pre>
<h2 id="filtering-vf-or--af"><a class="header" href="#filtering-vf-or--af">Filtering（-vf or -af）</a></h2>
<h3 id="simple-filtergraphs"><a class="header" href="#simple-filtergraphs">simple filtergraphs</a></h3>
<pre><code> _________                        ______________
|         |                      |              |
| decoded |                      | encoded data |
| frames  |\                   _ | packets      |
|_________| \                  /||______________|
             \   __________   /
  simple     _\||          | /  encoder
  filtergraph   | filtered |/
                | frames   |
                |__________|

</code></pre>
<h3 id="filter-for-video"><a class="header" href="#filter-for-video">filter for video</a></h3>
<pre><code> _______        _____________        _______        ________
|       |      |             |      |       |      |        |
| input | ---&gt; | deinterlace | ---&gt; | scale | ---&gt; | output |
|_______|      |_____________|      |_______|      |________|

</code></pre>
<h2 id="complex-filter-graphs"><a class="header" href="#complex-filter-graphs">Complex filter graphs</a></h2>
<pre><code> _________
|         |
| input 0 |\                    __________
|_________| \                  |          |
             \   _________    /| output 0 |
              \ |         |  / |__________|
 _________     \| complex | /
|         |     |         |/
| input 1 |----&gt;| filter  |\
|_________|     |         | \   __________
               /| graph   |  \ |          |
              / |         |   \| output 1 |
 _________   /  |_________|    |__________|
|         | /
| input 2 |/
|_________|

</code></pre>
<h2 id="stream-copy"><a class="header" href="#stream-copy">Stream Copy</a></h2>
<pre><code> _______              ______________            ________
|       |            |              |          |        |
| input |  demuxer   | encoded data |  muxer   | output |
| file  | ---------&gt; | packets      | -------&gt; | file   |
|_______|            |______________|          |________|

</code></pre>
<h2 id="1-通用查询参数"><a class="header" href="#1-通用查询参数">1. 通用查询参数</a></h2>
<ul>
<li>-formats</li>
</ul>
<p>​	Show available formats (including devices).</p>
<ul>
<li>-demuxers</li>
</ul>
<p>​	Show available demuxers.</p>
<ul>
<li>-muxers</li>
</ul>
<p>​	Show available muxers.</p>
<ul>
<li>-devices</li>
</ul>
<p>​	Show available devices.</p>
<ul>
<li>-codecs</li>
</ul>
<p>​	Show all codecs known to libavcodec.</p>
<ul>
<li>-decoders</li>
</ul>
<p>​	Show available decoders.</p>
<ul>
<li>-encoders</li>
</ul>
<p>​	Show all available encoders.</p>
<ul>
<li>-bsfs</li>
</ul>
<p>​	Show available bitstream filters.</p>
<ul>
<li>-protocols</li>
</ul>
<p>​	Show available protocols.</p>
<ul>
<li>-filters</li>
</ul>
<p>​	Show available libavfilter filters.</p>
<ul>
<li>-pix_fmts</li>
</ul>
<p>​	Show available pixel formats.</p>
<ul>
<li>-sample_fmts</li>
</ul>
<p>​	Show available sample formats.</p>
<ul>
<li>-layouts</li>
</ul>
<p>​	Show channel names and standard channel layouts.</p>
<h2 id="2-av参数"><a class="header" href="#2-av参数">2. AV参数</a></h2>
<ul>
<li>
<p>-f fmt (<em>input/output</em>)</p>
<p>Force input or output file format. The format is normally auto detected for input files and guessed from the file extension for output files, so this option is not needed in most cases.</p>
</li>
<li>
<p>-i url (<em>input</em>)</p>
<p>input file url</p>
</li>
<li>
<p>-c[:stream_specifier] codec (<em>input/output,per-stream</em>)</p>
<p>-codec[:stream_specifier] codec (<em>input/output,per-stream</em>)</p>
<p>Select an encoder (when used before an output file) or a decoder (when used before an input file) for one or more streams. codec is the name of a decoder/encoder or a special value <code>copy</code> (output only) to indicate that the stream is not to be re-encoded.</p>
</li>
<li>
<p>-t duration (<em>input/output</em>)</p>
<p>When used as an input option (before <code>-i</code>), limit the duration of data read from the input file.</p>
<p>When used as an output option (before an output url), stop writing the output after its duration reaches duration.</p>
<p>duration must be a time duration specification, see <a href="http://ffmpeg.org/ffmpeg-utils.html#time-duration-syntax">(ffmpeg-utils)the Time duration section in the ffmpeg-utils(1) manual</a>.</p>
<p>-to and -t are mutually exclusive and -t has priority.</p>
</li>
<li>
<p>-to position (<em>input/output</em>)</p>
<p>Stop writing the output or reading the input at position. position must be a time duration specification, see <a href="http://ffmpeg.org/ffmpeg-utils.html#time-duration-syntax">(ffmpeg-utils)the Time duration section in the ffmpeg-utils(1) manual</a>.</p>
<p>-to and -t are mutually exclusive and -t has priority.</p>
</li>
<li>
<p>-ss position (<em>input/output</em>)</p>
<p>When used as an input option (before <code>-i</code>), seeks in this input file to position. Note that in most formats it is not possible to seek exactly, so <code>ffmpeg</code> will seek to the closest seek point before position. When transcoding and -accurate_seek is enabled (the default), this extra segment between the seek point and position will be decoded and discarded. When doing stream copy or when -noaccurate_seek is used, it will be preserved.</p>
<p>When used as an output option (before an output url), decodes but discards input until the timestamps reach position.</p>
</li>
<li>
<p>-filter[:stream_specifier] filtergraph (<em>output,per-stream</em>)</p>
<p>Create the filtergraph specified by filtergraph and use it to filter the stream.</p>
<p>filtergraph is a description of the filtergraph to apply to the stream, and must have a single input and a single output of the same type of the stream. In the filtergraph, the input is associated to the label <code>in</code>, and the output to the label <code>out</code>. See the ffmpeg-filters manual for more information about the filtergraph syntax.</p>
<p>See the <a href="http://ffmpeg.org/ffmpeg.html#filter_005fcomplex_005foption">-filter_complex option</a> if you want to create filtergraphs with multiple inputs and/or outputs.</p>
</li>
<li>
<p>ffmpeg -f avfoundation -list_devices true -i &quot;&quot;</p>
</li>
</ul>
<h2 id="3-video参数"><a class="header" href="#3-video参数">3. Video参数</a></h2>
<ul>
<li>
<p>-r[:stream_specifier] fps (<em>input/output,per-stream</em>)</p>
<p>Set frame rate (Hz value, fraction or abbreviation).</p>
<p>As an input option, ignore any timestamps stored in the file and instead generate timestamps assuming constant frame rate fps. This is not the same as the -framerate option used for some input formats like image2 or v4l2 (it used to be the same in older versions of FFmpeg). If in doubt use -framerate instead of the input option -r.</p>
<p>As an output option, duplicate or drop input frames to achieve constant output frame rate fps.</p>
</li>
<li>
<p>-fpsmax[:stream_specifier] fps (<em>output,per-stream</em>)</p>
<p>Set maximum frame rate (Hz value, fraction or abbreviation).</p>
<p>Clamps output frame rate when output framerate is auto-set and is higher than this value. Useful in batch processing or when input framerate is wrongly detected as very high. It cannot be set together with <code>-r</code>. It is ignored during streamcopy.</p>
</li>
<li>
<p>-s[:stream_specifier] size (<em>input/output,per-stream</em>)</p>
<p>Set frame size.</p>
<p>As an input option, this is a shortcut for the video_size private option, recognized by some demuxers for which the frame size is either not stored in the file or is configurable – e.g. raw video or video grabbers.</p>
<p>As an output option, this inserts the <code>scale</code> video filter to the <em>end</em> of the corresponding filtergraph. Please use the <code>scale</code> filter directly to insert it at the beginning or some other place.</p>
<p>The format is ‘wxh’ (default - same as source).</p>
</li>
<li>
<p>-vn (<em>input/output</em>)</p>
<p>As an input option, blocks all video streams of a file from being filtered or being automatically selected or mapped for any output. See <code>-discard</code> option to disable streams individually.</p>
<p>As an output option, disables video recording i.e. automatic selection or mapping of any video stream. For full manual control see the <code>-map</code> option.</p>
</li>
<li>
<p>-vcodec codec (<em>output</em>)</p>
<p>Set the video codec. This is an alias for <code>-codec:v</code>.</p>
</li>
<li>
<p>-vf filtergraph (<em>output</em>)</p>
<p>Create the filtergraph specified by filtergraph and use it to filter the stream.</p>
<p>This is an alias for <code>-filter:v</code>, see the <a href="http://ffmpeg.org/ffmpeg.html#filter_005foption">-filter option</a>.</p>
</li>
<li>
<p>-pix_fmt[:stream_specifier] format (<em>input/output,per-stream</em>)</p>
<p>-pixel_format</p>
<p>Set pixel format. Use <code>-pix_fmts</code> to show all the supported pixel formats. If the selected pixel format can not be selected, ffmpeg will print a warning and select the best pixel format supported by the encoder. If pix_fmt is prefixed by a <code>+</code>, ffmpeg will exit with an error if the requested pixel format can not be selected, and automatic conversions inside filtergraphs are disabled. If pix_fmt is a single <code>+</code>, ffmpeg selects the same pixel format as the input (or graph output) and automatic conversions are disabled.</p>
</li>
</ul>
<h2 id="4-audio参数"><a class="header" href="#4-audio参数">4. Audio参数</a></h2>
<ul>
<li>
<p>-aq q (<em>output</em>)</p>
<p>Set the audio quality (codec-specific, VBR). This is an alias for -q:a.</p>
</li>
<li>
<p>-ac[:stream_specifier] channels (<em>input/output,per-stream</em>)</p>
<p>Set the number of audio channels. For output streams it is set by default to the number of input audio channels. For input streams this option only makes sense for audio grabbing devices and raw demuxers and is mapped to the corresponding demuxer options.</p>
</li>
<li>
<p>-an (<em>input/output</em>)</p>
<p>As an input option, blocks all audio streams of a file from being filtered or being automatically selected or mapped for any output. See <code>-discard</code> option to disable streams individually.</p>
<p>As an output option, disables audio recording i.e. automatic selection or mapping of any audio stream. For full manual control see the <code>-map</code> option.</p>
</li>
<li>
<p>-acodec codec (<em>input/output</em>)</p>
<p>Set the audio codec. This is an alias for <code>-codec:a</code>.</p>
</li>
<li>
<p>-sample_fmt[:stream_specifier] sample_fmt (<em>output,per-stream</em>)</p>
<p>Set the audio sample format. Use <code>-sample_fmts</code> to get a list of supported sample formats.</p>
</li>
<li>
<p>-af filtergraph (<em>output</em>)</p>
<p>Create the filtergraph specified by filtergraph and use it to filter the stream.</p>
<p>This is an alias for <code>-filter:a</code>, see the <a href="http://ffmpeg.org/ffmpeg.html#filter_005foption">-filter option</a>.</p>
</li>
<li>
<p>-ar</p>
</li>
<li>
<p>-f sl6le</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ffmpeg-安装-macos"><a class="header" href="#ffmpeg-安装-macos">FFMPEG 安装 MACOS</a></h1>
<pre><code class="language-shell">./configure --prefix=/usr/local/ffmpeg --enable-gpl --enable-nonfree --enable-libfdk-aac --enable-libx264 --enable-libx265 --enable-filter=delogo --enable-debug --disable-optimizations --enable-libspeex --enable-videotoolbox --enable-shared --enable-pthreads --enable-version3 --enable-hardcoded-tables --cc=clang --host-cflags= --host-ldflags= --disable-x86asm

brew install fdk-aac&amp;&amp;brew install x264&amp;&amp;brew install x265&amp;&amp;brew install speex&amp;&amp;brew install pkg-config&amp;&amp;brew  install sdl2



export PATH=$PATH:/usr/local/ffmpeg/bin
export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig:/usr/lib/pkgconfig:/usr/local/Cellar/sdl2/2.0.8/lib/pkgconfig:/usr/local/ffmpeg/lib/pkgconfig

codesign --remove-signature /path/to/*.dylib
codesign -s &quot;Apple Development: Your Name (10-char-ID)&quot;  /path/to/*.dylib
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cmake-模板"><a class="header" href="#cmake-模板">CMAKE 模板</a></h1>
<h2 id="cmakepkg"><a class="header" href="#cmakepkg"><a href="https://cmake.org/cmake/help/v3.19/module/FindPkgConfig.html?highlight=pkg#command:pkg_check_modules">CMake+Pkg</a></a></h2>
<ul>
<li>
<p><code>&lt;XXX&gt;_FOUND</code></p>
<p>set to 1 if module(s) exist</p>
</li>
<li>
<p><code>&lt;XXX&gt;_LIBRARIES</code></p>
<p>only the libraries (without the ‘-l’)</p>
</li>
<li>
<p><code>&lt;XXX&gt;_LINK_LIBRARIES</code></p>
<p>the libraries and their absolute paths</p>
</li>
<li>
<p><code>&lt;XXX&gt;_LIBRARY_DIRS</code></p>
<p>the paths of the libraries (without the ‘-L’)</p>
</li>
<li>
<p><code>&lt;XXX&gt;_LDFLAGS</code></p>
<p>all required linker flags</p>
</li>
<li>
<p><code>&lt;XXX&gt;_LDFLAGS_OTHER</code></p>
<p>all other linker flags</p>
</li>
<li>
<p><code>&lt;XXX&gt;_INCLUDE_DIRS</code></p>
<p>the ‘-I’ preprocessor flags (without the ‘-I’)</p>
</li>
<li>
<p><code>&lt;XXX&gt;_CFLAGS</code></p>
<p>all required cflags</p>
</li>
<li>
<p><code>&lt;XXX&gt;_CFLAGS_OTHER</code></p>
<p>the other compiler flags</p>
</li>
</ul>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.19)
project(player)

set(CMAKE_CXX_STANDARD 11)
list(APPEND SOURCE
	src/main.c)
set(ENV{PKG_CONFIG_PATH} 
	/usr/local/sdl2/lib/pkgconfig:/usr/local/ffmpeg/lib/pkgconfig
)
find_package(PkgConfig)
pkg_check_modules(FFMPEG REQUIRED IMPORTED_TARGET libavcodec libavformat libavutil)
pkg_check_modules(SDL2 REQUIRED IMPORTED_TARGET sdl2)
add_executable(${PROJECT_NAME} ${SOURCE})
target_link_libraries(${PROJECT_NAME} PRIVATE
	PkgConfig::FFMPEG
	PkgConfig::SDL2
	)
</code></pre>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.19)
project(player)

set(CMAKE_CXX_STANDARD 11)
list(APPEND SOURCE
	src/main.c)
set(ENV{PKG_CONFIG_PATH} 
	/usr/local/sdl2/lib/pkgconfig:/usr/local/ffmpeg/lib/pkgconfig
)
find_package(PkgConfig)
pkg_check_modules(FFMPEG REQUIRED IMPORTED_TARGET libavcodec libavformat libavutil)
pkg_check_modules(SDL2 REQUIRED IMPORTED_TARGET sdl2)
add_executable(player ${SOURCE})
include_directories(
	${FFMPEG_INCLUDE_DIRS}
	${SDL2_INCLUDE_DIRS}
	)
target_link_libraries(player PRIVATE
	${FFMPEG_LDFLAGS}
	${SDL2_LDFLAGS}
	)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="yuvplayer-demo"><a class="header" href="#yuvplayer-demo">YUVPLayer Demo</a></h1>
<pre><code class="language-C">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;SDL.h&gt;
#include &lt;pthread.h&gt;
#define REFRESH_EVENT (SDL_USEREVENT + 1)
#define QUIT_EVENT (SDL_USEREVENT + 2)
bool thread_exit = false;
int refresh()
{
	thread_exit = false;
	while (!thread_exit) {
		SDL_Event event;
		event.type = REFRESH_EVENT;
		SDL_PushEvent(&amp;event);
		SDL_Delay(40);
	}
	thread_exit = true;

	SDL_Event event;
	event.type = QUIT_EVENT;
	SDL_PushEvent(&amp;event);
	return 0;
}
int main(int argc, char* argv[])
{
	FILE* video_fd = NULL;

	SDL_Event event = {0};
	SDL_Rect rect = {0};

	unsigned int pixformat = 0;
	
	SDL_Window* window = NULL;
	SDL_Renderer* renderer = NULL;
	SDL_Texture* texture = NULL;
	SDL_Thread* timer_thread = NULL;

	int win_w = 1920;
	int win_h = 1080;
	const int video_w = win_w;
	const int video_h = win_h;
	
	unsigned char* video_pos = NULL;
	unsigned char* video_end = NULL;

	unsigned int remain_len = 0;
	size_t video_buffer_len = 0;
	size_t blank_space_len = 0;
	unsigned char* video_buf = NULL;

	const char* path = &quot;1.yuv&quot;;
	const unsigned int yuv_frame_len = video_w * video_h * 12 / 8;
	unsigned int tmp_yuv_frame_len = yuv_frame_len;

	if (yuv_frame_len &amp; 0xF) {
		tmp_yuv_frame_len = (yuv_frame_len &amp; 0xFFF0) + 0x10;
	}

	if (SDL_Init(SDL_INIT_VIDEO)) {
		printf(&quot;SDL INIT Fail!\n&quot;);
		return -1;
	}
	window = SDL_CreateWindow(
			&quot;YUV Player&quot;,
			SDL_WINDOWPOS_UNDEFINED,
			SDL_WINDOWPOS_UNDEFINED,
			win_w, win_h,
			SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE
	);
	if (window == NULL) {
		printf(&quot;Window create Fail!\n&quot;);
		// TODO 资源释放
		return -1;
	} 
	renderer = SDL_CreateRenderer(window, -1, 0);
	// IYVU: Y + U + V (3 planes)
	// YV12: Y + V + U (3 planes)
	pixformat = SDL_PIXELFORMAT_IYUV;
	texture = SDL_CreateTexture(
							renderer,
							pixformat,
							SDL_TEXTUREACCESS_STREAMING,
							video_w, video_h
							);

	video_buf = (unsigned char*) malloc(tmp_yuv_frame_len);
	if (video_buf == NULL) {
		// TODO 资源释放
		return -1;
	}
	video_fd = fopen(path, &quot;r&quot;);
	video_buffer_len = fread(video_buf, 1, yuv_frame_len, video_fd);
	if (video_buffer_len &lt;= 0) {
		return -1;
	}
	video_pos = video_buf;
	timer_thread = SDL_CreateThread(
		refresh,
		&quot;thread&quot;,
		NULL
	);
	do {
		SDL_WaitEvent(&amp;event);
		if (event.type == REFRESH_EVENT) {
			SDL_UpdateTexture(texture, NULL, video_pos, video_w);
			rect.x = 0;
			rect.y = 0;
			rect.w = win_w;
			rect.h = win_h;
			SDL_RenderCopy(renderer, texture, NULL, &amp;rect);
			SDL_RenderPresent(renderer);

			video_buffer_len = fread(video_buf, 1, yuv_frame_len, video_fd);
			if (video_buffer_len &lt;= 0) {
				thread_exit = true;
				continue;
			}
		} else if (event.type == SDL_WINDOWEVENT) {
			SDL_GetWindowSize(window, &amp;win_w, &amp;win_h);
		} else if (event.type == SDL_QUIT) {
			thread_exit = true;
		} else if (event.type == QUIT_EVENT) {
			break;
		}
	} while(1);
	return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pcmplayer-democ"><a class="header" href="#pcmplayer-democ">PCMPLayer Demo(C)</a></h1>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;SDL.h&gt;
#include &lt;pthread.h&gt;
#define BLOCK_SIZE 4096000
unsigned char* audio_buf = NULL;
unsigned char* audio_pos = NULL;
size_t buffer_len = 0;
void read_audio_data(void* userdatai, Uint8* stream, int len)
{
	if (buffer_len == 0) {
		return;
	}
	SDL_memset(stream, 0, len);
	len = (len &lt; buffer_len) ? len : buffer_len;
	SDL_MixAudio(stream, audio_pos, len, SDL_MIX_MAXVOLUME);
	audio_pos += len;
	buffer_len -= len;
}
int main(int argc, char* argv[])
{
	if (SDL_Init(SDL_INIT_AUDIO) != 0) {
		SDL_Log(&quot;init fail!\n&quot;);
		return -1;
	}
	const char* path = &quot;1.pcm&quot;;
	FILE* audio_fd = fopen(path, &quot;r&quot;);
	if (audio_fd == NULL) {
		SDL_Log(&quot;open fail!\n&quot;);
		SDL_Quit();
		return -1;
	}
	audio_buf = malloc(BLOCK_SIZE);
	if (audio_buf == NULL) {
		SDL_Log(&quot;malloc fail!\n&quot;);
		fclose(audio_fd);
		SDL_Quit();
	}
	SDL_AudioSpec spec;
	spec.freq = 48000;
	spec.channels = 2;
	spec.format = AUDIO_S16SYS;
	spec.callback = read_audio_data;
	spec.userdata = NULL;
	if (SDL_OpenAudio(&amp;spec, NULL) != 0) {
		SDL_Log(&quot;open audio fail!\n&quot;);
		fclose(audio_fd);
		free(audio_buf);
		SDL_Quit();
		return -1;
	}
	SDL_PauseAudio(0);
	do {
		buffer_len = fread(audio_buf, 1, BLOCK_SIZE, audio_fd);
		audio_pos = audio_buf;
		while (audio_pos &lt; (audio_buf + buffer_len)) {
			SDL_Delay(1);
		}
	} while(buffer_len != 0);

	SDL_CloseAudio();
	fclose(audio_fd);
	free(audio_buf);
	SDL_Quit();
	return 0;
}	
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="redis"><a class="header" href="#redis">Redis</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="net"><a class="header" href="#net">NET</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vim"><a class="header" href="#vim">VIM</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ccls"><a class="header" href="#ccls">CCLS</a></h1>
<h1 id="1-依赖"><a class="header" href="#1-依赖">1. 依赖</a></h1>
<ul>
<li>vim8+ ｜ <a href="https://github.com/neovim/neovim/wiki/Installing-Neovim#install-from-download">neovim</a></li>
<li><a href="https://github.com/llvm/llvm-project/releases">clang+llvm</a></li>
<li><a href="https://github.com/MaskRay/ccls">ccls</a></li>
<li><a href="https://github.com/nvm-sh/nvm">nvm</a></li>
<li>Node</li>
<li><a href="https://github.com/junegunn/vim-plug">vim-plug</a></li>
<li><a href="https://github.com/neoclide/coc.nvim">coc.nvim</a></li>
</ul>
<h1 id="2-neovim可选"><a class="header" href="#2-neovim可选">2. neovim(可选)</a></h1>
<h1 id="3-clangllvm"><a class="header" href="#3-clangllvm">3. <a href="https://github.com/llvm/llvm-project/releases">clang+llvm</a></a></h1>
<pre><code class="language-shell">wget https://github.com/llvm/llvm-project/releases/download/llvmorg-13.0.0/clang+llvm-13.0.0-x86_64-linux-gnu-ubuntu-20.04.tar.xz

tar -xvf *.tar.zx
cd clang+llvm-13.0.0-x86_64-linux-gnu-ubuntu-20.04
# &gt; bashrc
############clang+llvm
export LLVM_HOME=***/clang+llvm-13.0.0-x86_64-linux-gnu-ubuntu-20.04
export PATH=$LLVM_HOME/bin:$PATH
export C_IONCLUDE_PATH=$LLVM_HOME/include:$C_INCLUDE_PATH
export LD_LIBRARY_PATH=$LLVM_HOME/lib:$LD_LIBRARY_PATH

</code></pre>
<h1 id="4-ccls"><a class="header" href="#4-ccls">4. <a href="https://github.com/MaskRay/ccls">ccls</a></a></h1>
<pre><code class="language-shell">git clone --depth=1 --recursive https://github.com/MaskRay/ccls
cd ccls
# sudo apt install zlib1g zlib1g-dev
cmake -H. -BRelease -DCMAKE_BUILD_TYPE=Release
cmake --build Release
</code></pre>
<h1 id="5-nvm"><a class="header" href="#5-nvm">5. <a href="https://github.com/nvm-sh/nvm#troubleshooting-on-linux">nvm</a></a></h1>
<pre><code class="language-bash">export NVM_DIR=&quot;$HOME/.nvm&quot; &amp;&amp; (
  git clone https://github.com/nvm-sh/nvm.git &quot;$NVM_DIR&quot;
  cd &quot;$NVM_DIR&quot;
  git checkout `git describe --abbrev=0 --tags --match &quot;v[0-9]*&quot; $(git rev-list --tags --max-count=1)`
) &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot;

# &gt;&gt; ~/.bashrc
export NVM_DIR=&quot;$HOME/.nvm&quot;
[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm
[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \. &quot;$NVM_DIR/bash_completion&quot;  # This loads nvm bash_completion

</code></pre>
<h1 id="6-node"><a class="header" href="#6-node">6. node</a></h1>
<pre><code class="language-shell">nvm ls-remote
nvm install * 
nvm use *
</code></pre>
<h1 id="7-cocnvm"><a class="header" href="#7-cocnvm">7. <a href="https://github.com/neoclide/coc.nvim">coc.nvm</a></a></h1>
<pre><code>Plug 'neoclide/coc.nvim', {'branch': 'master', 'do': 'yarn install --frozen-lockfile'}
</code></pre>
<h1 id="8-cmake-生成-compile_commandsjson"><a class="header" href="#8-cmake-生成-compile_commandsjson">8. CMake 生成 compile_commands.json</a></h1>
<pre><code class="language-cmake">set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
# -DCMAKE_EXPORT_COMPILE_COMMANDS=ON 
cmake -H. -Bbuild -DCMAKE_BUILD_TYPE=Release -DCMAKE_EXPORT_COMPILE_COMMANDS=ON &amp;&amp; ln build/compile_commands.json ./
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="base"><a class="header" href="#base">Base</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="计算机组成原理"><a class="header" href="#计算机组成原理">计算机组成原理</a></h1>
<h1 id="1-冯诺依曼系统三大组成"><a class="header" href="#1-冯诺依曼系统三大组成">1. 冯诺依曼系统三大组成</a></h1>
<h2 id="11-控制器"><a class="header" href="#11-控制器">1.1 控制器</a></h2>
<h3 id="111-性能"><a class="header" href="#111-性能">1.1.1 性能</a></h3>
<ul>
<li>空间</li>
<li>时间
<ul>
<li>指令周期</li>
<li>CPU周期</li>
<li>时钟周期</li>
<li>指令数 * 指令运行的平均周期 * 时钟周期 </li>
</ul>
</li>
<li>能耗
<ul>
<li>能耗= 1 / 2 * 负载电容 * 电压的平方 * 开关频率 * 晶体管数量</li>
</ul>
</li>
</ul>
<h3 id="112-控制流程"><a class="header" href="#112-控制流程">1.1.2 控制流程</a></h3>
<ul>
<li>取码</li>
<li>译码</li>
<li>执行（处理器执行）</li>
</ul>
<h2 id="12-处理器"><a class="header" href="#12-处理器">1.2 处理器</a></h2>
<ul>
<li>CPU（ALU）</li>
<li>GPU</li>
<li>DPU</li>
</ul>
<h2 id="13-存储器"><a class="header" href="#13-存储器">1.3 存储器</a></h2>
<ul>
<li>
<p>寄存器</p>
<ul>
<li>状态寄存器</li>
<li>命令（指令）寄存器</li>
<li>数据寄存器</li>
</ul>
</li>
<li>
<p>内存</p>
</li>
<li>
<p>外存</p>
</li>
<li>
<p>网络存储</p>
</li>
</ul>
<h1 id="2-指令和运算"><a class="header" href="#2-指令和运算">2. 指令和运算</a></h1>
<h2 id="21-指令分类"><a class="header" href="#21-指令分类">2.1 指令分类</a></h2>
<ul>
<li>运算类</li>
<li>数据传输类</li>
<li>逻辑类
<ul>
<li>与或非异或</li>
<li>有条件跳转</li>
<li>无条件跳转</li>
</ul>
</li>
</ul>
<h2 id="22-性能优化"><a class="header" href="#22-性能优化">2.2 性能优化</a></h2>
<h3 id="221-指令流水线"><a class="header" href="#221-指令流水线">2.2.1 指令流水线</a></h3>
<ul>
<li>取码</li>
<li>译码</li>
<li>执行
<ul>
<li>ALU计算（执行）</li>
<li>访寸</li>
<li>写回</li>
</ul>
</li>
</ul>
<h3 id="222-结构冒险增加资源"><a class="header" href="#222-结构冒险增加资源">2.2.2 结构冒险（增加资源）</a></h3>
<ul>
<li>分为指令内存和数据内存（哈佛结构）</li>
<li>NOP再分配</li>
</ul>
<h3 id="223-数据冒险流水线冒泡"><a class="header" href="#223-数据冒险流水线冒泡">2.2.3 数据冒险（流水线冒泡）</a></h3>
<p>增加空指令NOP</p>
<ul>
<li>写后读（数据依赖）</li>
<li>读后写（反依赖）</li>
<li>写后写（输出依赖）</li>
</ul>
<p>指令分发和结果重排序（乱序）</p>
<h3 id="224-控制冒险"><a class="header" href="#224-控制冒险">2.2.4 控制冒险</a></h3>
<ul>
<li>分支预测</li>
<li>局部性原理</li>
</ul>
<h1 id="3-处理器"><a class="header" href="#3-处理器">3. 处理器</a></h1>
<ul>
<li>CPU
<ul>
<li>CISC</li>
<li>RISC</li>
<li>RISC-V</li>
</ul>
</li>
<li>GPU</li>
</ul>
<h1 id="4-存储与io"><a class="header" href="#4-存储与io">4. 存储与I/O</a></h1>
<h2 id="41-普通存储"><a class="header" href="#41-普通存储">4.1 普通存储</a></h2>
<ul>
<li>寄存器</li>
<li>内存
<ul>
<li>SRAM</li>
<li>DRAM</li>
</ul>
</li>
<li>外存
<ul>
<li>SSD</li>
<li>HHD</li>
</ul>
</li>
</ul>
<h2 id="42-存储信息同步"><a class="header" href="#42-存储信息同步">4.2 存储信息同步</a></h2>
<ul>
<li>写直达</li>
<li>写回</li>
<li>MESI 协议（广播）</li>
</ul>
<h2 id="43-虚拟内存"><a class="header" href="#43-虚拟内存">4.3 虚拟内存</a></h2>
<ul>
<li>TLB-MMU-CPU</li>
</ul>
<h2 id="44-bus"><a class="header" href="#44-bus">4.4 BUS</a></h2>
<h3 id="441-双独立总线"><a class="header" href="#441-双独立总线">4.4.1 双独立总线</a></h3>
<ul>
<li>CPU - 本地总线（快） - Cache</li>
<li>CPU - 系统总线（前段总线、慢） - 内存｜I/O
<ul>
<li>IO总线</li>
<li>内存总线</li>
</ul>
</li>
</ul>
<pre><code class="language-html">CPU&lt;-系统总线-&gt;北桥芯片(IO桥接器)&lt;-内存总线-&gt;内存
  						     ⬆️
 &lt;------------------IO总线------------------------&gt;
 		⬇️             ⬇️                  ⬇️
 USB控制器         显卡适配器          硬盘控制器
   ⬇️               ⬇️                 ⬇️
  键盘/鼠标         显示器               硬盘
</code></pre>
<ul>
<li>
<p>从功能区分</p>
<ul>
<li>
<p>数据总线</p>
</li>
<li>
<p>地址总线</p>
</li>
<li>
<p>控制总线</p>
</li>
</ul>
</li>
</ul>
<h2 id="45-io设备"><a class="header" href="#45-io设备">4.5 IO设备</a></h2>
<ul>
<li>接口 + 设备</li>
<li>驱动</li>
<li>IOPS
<ul>
<li>top</li>
<li>iostat</li>
<li>iotop</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="操作系统实战笔记"><a class="header" href="#操作系统实战笔记">操作系统实战笔记</a></h1>
<h1 id="1-构建基础景象"><a class="header" href="#1-构建基础景象">1. 构建基础景象</a></h1>
<h2 id="11-grubcfg"><a class="header" href="#11-grubcfg">1.1 grub.cfg</a></h2>
<pre><code>menuentry 'HelloOS' {
insmod part_msdos
insmod ext2
set root='hd0,msdos1' #我们的硬盘只有一个分区所以是'hd0,msdos1'
multiboot2 /boot/HelloOS.eki #加载boot目录下的HelloOS.eki文件
boot #引导启动
}
set timeout_style=menu
if [ &quot;${timeout}&quot; = 0 ]; then
  set timeout=10 #等待10秒钟自动启动
fi
</code></pre>
<h2 id="12-一键脚本-makefile"><a class="header" href="#12-一键脚本-makefile">1.2 一键脚本 Makefile</a></h2>
<pre><code class="language-makefile">PHONY:all
OSNAME=HelloOS
IMGNAME=hd
LOOP=loop11
REMOTE=vm
REMOTE_DIR=/home/cal/code/os/cosmos/cal/cal2
all:
	make clean
	make create_os
	make build_os
build_os:
	scp ${REMOTE}:${REMOTE_DIR}/${IMGNAME}.img ./
	VBoxManage convertfromraw ./hd.img --format VDI ./${IMGNAME}.vdi
	VBoxManage storagectl ${OSNAME} --name &quot;SATA&quot; --add sata --controller IntelAhci --portcount 1
	VBoxManage closemedium disk ./${IMGNAME}.vdi
	VBoxManage storageattach ${OSNAME} --storagectl &quot;SATA&quot; --port 1 --device 0 --type hdd --medium ./${IMGNAME}.vdi
create_os:
	VBoxManage createvm --name ${OSNAME} --register
start:
	VBoxManage startvm ${OSNAME}
close:
	VBoxManage controlvm ${OSNAME} poweroff
clean:
	rm -rf ./hd.vdi
	rm -rf ./hd.img
	VBoxManage unregistervm --delete ${OSNAME}
doc:
	echo &quot;https://cloud.tencent.com/developer/article/2030930&quot;
	echo &quot;https://blog.csdn.net/HandsomeHong/article/details/115418206&quot;
build_remote:
	scp Makefile ${REMOTE}:${REMOTE_DIR}/ 
	scp grub.cfg ${REMOTE}:${REMOTE_DIR}
	ssh ${REMOTE} &quot;make --file=${REMOTE_DIR}/Makefile remote&quot;
remote:
	dd bs=512 if=/dev/zero of=${IMGNAME}.img count=204800
	sudo losetup /dev/${LOOP} ${IMGNAME}.img
	sudo mkfs.ext4 -q /dev/${LOOP}
	sudo mkdir ./hdisk
	sudo mount -o loop ./${IMGNAME}.img ./hdisk/
	sudo mkdir ./hdisk/boot/
	sudo grub-install --boot-directory=./hdisk/boot/ --force --allow-floppy /dev/${LOOP}
	sudo cp grub.cfg ./hdist/boot/grub/
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="工具"><a class="header" href="#工具">工具</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="verilog-on-mac"><a class="header" href="#verilog-on-mac"><a href="https://zhuanlan.zhihu.com/p/291571592">Verilog on MAC</a></a></h1>
<h1 id="1-安装"><a class="header" href="#1-安装">1. 安装</a></h1>
<h2 id="11-安装-verilog-和-gtkware"><a class="header" href="#11-安装-verilog-和-gtkware">1.1 安装 Verilog 和 gtkware</a></h2>
<pre><code class="language-bash">brew install icarus-verilog
brew install verilator
brew install xquartz # --cask
brew install gtkwave # --cask
</code></pre>
<h2 id="12-安装-graphviz"><a class="header" href="#12-安装-graphviz">1.2 安装 graphviz</a></h2>
<pre><code class="language-bash">brew install graphviz # 可以打印png格式的电路结构图
brew install xdot
</code></pre>
<h2 id="13-安装yosys"><a class="header" href="#13-安装yosys">1.3 安装yosys</a></h2>
<pre><code class="language-shell">git clone https://github.com/YosysHQ/yosys.git
cd yosys
brew tap Homebrew/bundle &amp;&amp; brew bundle
make
sudo make install
# 输入 yosys 进入工作模式
</code></pre>
<h1 id="2-验证安装"><a class="header" href="#2-验证安装">2. 验证安装</a></h1>
<h2 id="21-编写counterv"><a class="header" href="#21-编写counterv">2.1 编写counter.v</a></h2>
<pre><code class="language-verilog">module counter (clk, rst, en, count);
   input clk, rst, en;
   output reg [1:0] count;
   always @(posedge clk)
      if (rst)      //复位信号
         count &lt;= 2'd0;
      else if (en)  //使能信号
         count &lt;= count + 2'd1;
endmodule
</code></pre>
<h2 id="22-test-bench-counter_tbv"><a class="header" href="#22-test-bench-counter_tbv">2.2 test bench: counter_tb.v</a></h2>
<pre><code class="language-verilog">`timescale 1ns / 1ps
module counter_tb;

reg clk;
reg reset;
reg enable;
wire [1:0] counter_out;

counter c1(clk,reset,enable,counter_out);

/*iverilog */
initial
begin            
    $dumpfile(&quot;wave.vcd&quot;);        //生成的vcd文件名称
    $dumpvars(0, counter_tb);     //tb模块名称
end
/*iverilog */

initial
begin
  clk=0;
  reset=1;
  enable=1;
  clk=1;
  #10
  reset=0;
end
always
#5 clk=~clk;

initial
  #2000 $finish;

endmodule
</code></pre>
<h2 id="23-编写仿真执行脚本-simu_runsh"><a class="header" href="#23-编写仿真执行脚本-simu_runsh">2.3 编写仿真执行脚本: simu_run.sh</a></h2>
<p>执行脚本查看波形图</p>
<pre><code class="language-shell">echo &quot;开始编译&quot;
iverilog -o wave ./counter.v counter_tb.v
echo &quot;编译完成&quot;

echo &quot;生成波形文件&quot;
vvp -n wave -lxt2 
cp wave.vcd wave.lxt

echo &quot;打开波形文件&quot;
gtkwave wave.vcd
</code></pre>
<h2 id="24-编写综合文件-counterys-下载"><a class="header" href="#24-编写综合文件-counterys-下载">2.4 编写综合文件: counter.ys <a href="https://pan.baidu.com/s/1ngzdwX9KkDVTJVOoGkx3dg">下载</a></a></h2>
<p>执行</p>
<pre><code class="language-bash">yosys counter.ys
</code></pre>
<pre><code class="language-verilog"># read design
read_verilog counter.v
hierarchy -check -top counter

# the high-level stuff
proc; opt; memory; opt; fsm; opt

# mapping to internal cell library
techmap; opt

# mapping flip-flops to mycells.lib
dfflibmap -liberty mycells.lib

# mapping logic to mycells.lib
abc -liberty mycells.lib

# cleanup
clean

write_verilog counter_gate.v

# 其中的mycells.lib和mycells.v是自定义的库文件 需要从标题链接下载 提取码 5076
</code></pre>
<p>mycells.v</p>
<pre><code class="language-verilog">module NOT(A, Y);
input A;
output Y = ~A;
endmodule

module NAND(A, B, Y);
input A, B;
output Y = ~(A &amp; B);
endmodule

module NOR(A, B, Y);
input A, B;
output Y = ~(A | B);
endmodule

module DFF(C, D, Q);
input C, D;
output reg Q;
always @(posedge C)
	Q &lt;= D;
endmodule
</code></pre>
<p>mycells.lib</p>
<pre><code class="language-verilog">library(demo) {
  cell(BUF) {
    area: 6;
    pin(A) { direction: input; }
    pin(Y) { direction: output;
              function: &quot;A&quot;; }
  }
  cell(NOT) {
    area: 3;
    pin(A) { direction: input; }
    pin(Y) { direction: output;
              function: &quot;A'&quot;; }
  }
  cell(NAND) {
    area: 4;
    pin(A) { direction: input; }
    pin(B) { direction: input; }
    pin(Y) { direction: output;
             function: &quot;(A*B)'&quot;; }
  }
  cell(NOR) {
    area: 4;
    pin(A) { direction: input; }
    pin(B) { direction: input; }
    pin(Y) { direction: output;
             function: &quot;(A+B)'&quot;; }
  }
  cell(DFF) {
    area: 18;
    ff(IQ, IQN) { clocked_on: C;
                  next_state: D; }
    pin(C) { direction: input;
                 clock: true; }
    pin(D) { direction: input; }
    pin(Q) { direction: output;
              function: &quot;IQ&quot;; }
  }
}
</code></pre>
<h2 id="25-打印电路图-counter_show_pdfys"><a class="header" href="#25-打印电路图-counter_show_pdfys">2.5 打印电路图: counter_show_pdf.ys</a></h2>
<p>执行</p>
<pre><code class="language-bash">yosys counter_show_pdf.ys # 该过程共输出4个dot文件和4个pdf文件，分别对应了counter网表的四种详细等级的输出
# dot counter_03.dot -T png -o counter_03.png # 输出png
</code></pre>
<pre><code class="language-verilog"># read design
read_verilog counter.v
hierarchy -check -top counter

# show0: print counter without high-level stuff
show -notitle -stretch -format pdf -prefix counter_00

# the high-level stuff
proc; opt; memory; opt; fsm; opt

# show1: print counter with high-level stuff
show -notitle -stretch -format pdf -prefix counter_01

# mapping to internal cell library
techmap; opt
splitnets -ports;;

# show3: print counter mappped with internal cell library
show -notitle -stretch -format pdf -prefix counter_02

# mapping flip-flops to mycells.lib
dfflibmap -liberty mycells.lib

# mapping logic to mycells.lib
abc -liberty mycells.lib

# cleanup
clean

# show4: print counter with internal cell lib and mycell lib
show -notitle -stretch -lib mycells.v -format pdf -prefix counter_03

shell
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="verilog语法规则"><a class="header" href="#verilog语法规则"><a href="https://www.runoob.com/w3cnote/verilog-timing-control.html">Verilog语法规则</a></a></h1>
<h1 id="1-关键字"><a class="header" href="#1-关键字">1. 关键字</a></h1>
<ul>
<li>
<p>wire (wire 型变量只能被赋值一次)</p>
</li>
<li>
<p>assign (任何已经声明 wire 变量的连续赋值语句都是以 assign 开头)</p>
</li>
<li>
<p>//</p>
</li>
<li>
<p>/**/</p>
</li>
<li>
<p>reg[31:0]</p>
</li>
<li>
<p>input</p>
</li>
<li>
<p>output</p>
</li>
<li>
<p>module</p>
</li>
<li>
<p>endmodule</p>
</li>
<li>
<p>always</p>
</li>
<li>
<p>postedge</p>
</li>
<li>
<p>beigin</p>
</li>
<li>
<p>end</p>
</li>
<li>
<p>$time</p>
</li>
<li>
<p>$finish</p>
</li>
<li>
<p>or （or 也可以用逗号 <strong>,</strong> 来代替）</p>
<ul>
<li>更为简洁的写法是 <strong>@*</strong> 或 <strong>@(*)</strong>，表示对语句块中的所有输入变量的变化都是敏感的</li>
</ul>
</li>
<li>
<p>event (事件)</p>
<pre><code class="language-verilog">event     start_receiving ;
always @( posedge clk_samp) begin
        -&gt; start_receiving ;       //采样时钟上升沿作为时间触发时刻
end
 
always @(start_receiving) begin
    data_buf = {data_if[0], data_if[1]} ; //触发时刻，对多维数据整合
end
</code></pre>
</li>
<li>
<p>fork （并行， begin）</p>
</li>
<li>
<p>join （并行, end）</p>
</li>
<li>
<p>disable</p>
</li>
<li>
<p>case</p>
</li>
<li>
<p>casez(casez 用问号 &quot;?&quot; 来表示无关值。)</p>
</li>
<li>
<p>casex(casex 用 &quot;x&quot; 来表示无关值)</p>
<pre><code class="language-verilog">module mux4to1(
    input [3:0]     sel ,
    input [1:0]     p0 ,
    input [1:0]     p1 ,
    input [1:0]     p2 ,
    input [1:0]     p3 ,
    output [1:0]    sout);
 
    reg [1:0]     sout_t ;
    always @(*)
        casez(sel)
            4'b???1:     sout_t = p0 ;
            4'b??1?:     sout_t = p1 ;
            4'b?1??:     sout_t = p2 ;
            4'b1???:     sout_t = p3 ;  
        default:         sout_t = 2'b0 ;
    endcase
    assign      sout = sout_t ;
 
endmodule
</code></pre>
</li>
<li>
<p>default</p>
</li>
<li>
<p>while</p>
</li>
<li>
<p>for</p>
</li>
<li>
<p>repeat</p>
</li>
<li>
<p>forever</p>
</li>
<li>
<p>deassign</p>
</li>
<li>
<p>force</p>
</li>
<li>
<p>release</p>
</li>
</ul>
<h1 id="2-数值"><a class="header" href="#2-数值">2. 数值</a></h1>
<ul>
<li>0</li>
<li>1</li>
<li>X 或者 x (未知)</li>
<li>Z 或者 z (高组态)</li>
<li>b|B|d|D|h|H|o|O</li>
<li>4'b1011</li>
<li>b1011 自动匹配位宽</li>
<li>字符串
<ul>
<li>reg [0: 14*8 -1] str;</li>
<li>str = &quot;www.runoob.com&quot;;</li>
</ul>
</li>
</ul>
<h1 id="3-数据类型"><a class="header" href="#3-数据类型">3. 数据类型</a></h1>
<ul>
<li>wire</li>
<li>reg</li>
<li>integer （整数）</li>
<li>real （实数）</li>
<li>time</li>
<li>数组
<ul>
<li>integer     flag [7:0] ; <em>//8个整数组成的数组</em>
reg [3:0]    counter [3:0] ; <em>//由4个4bit计数器组成的数组</em>
wire [7:0]    addr_bus [3:0] ; <em>//由4个8bit wire型变量组成的数组</em>
wire       data_bit[7:0][5:0] ; <em>//声明1bit wire型变量的二维数组</em>
reg [31:0]    data_4d[11:0][3:0][3:0][255:0] ; <em>//声明4维的32bit数据变量数组</em></li>
</ul>
</li>
<li>parameter（只能赋值一次）
<ul>
<li>parameter    data_width = 10'd32 ;</li>
</ul>
</li>
<li>RAM 或者 ROM
<ul>
<li>用寄存器数组表示</li>
<li>reg [7:0]     mem[0:1023] ;   <em>//1Kbyte存储器，位宽8bit</em></li>
</ul>
</li>
</ul>
<h1 id="4-表达式"><a class="header" href="#4-表达式">4. 表达式</a></h1>
<h2 id="41-操作符"><a class="header" href="#41-操作符">4.1 操作符</a></h2>
<ul>
<li>
<p>算术、关系、等价、逻辑、按位、归约、移位、拼接、条件操作符</p>
</li>
<li>
<p>归约</p>
<ul>
<li>归约操作符只有一个操作数，它对这个向量操作数逐位进行操作，最终产生一个 1bit 结果。</li>
</ul>
</li>
<li>
<p>拼接操作符(拼接符操作数必须指定位宽，常数的话也需要指定位宽)</p>
<p>{,}</p>
<pre><code class="language-verilog">A = 4'b1010 ;
B = 1'b1 ;
Y1 = {B, A[3:2], A[0], 4'h3 };  //结果为Y1='b1100_0011
Y2 = {4{B}, 3'd4};  //结果为 Y2=7'b111_1100
Y3 = {32{1'b0}};  //结果为 Y3=32h0，常用作寄存器初始化时匹配位宽的赋初值
</code></pre>
</li>
<li>
<p>条件操作符(可以多路)</p>
<pre><code class="language-verilog">assign   hsel = (addr[9:8] == 2'b00) ? hsel_p1 : 
                (addr[9:8] == 2'b01) ? hsel_p2 :
                (addr[9:8] == 2'b10) ? hsel_p3 :
                (addr[9:8] == 2'b11) ? hsel_p4 ;
</code></pre>
</li>
</ul>
<h1 id="5-编译指令"><a class="header" href="#5-编译指令">5. <a href="https://www.runoob.com/w3cnote/verilog-compile-instruction.html">编译指令</a></a></h1>
<p>以反引号 <strong>`</strong> 开始的某些标识符是 Verilog 系统编译指令。</p>
<h2 id="51-define-undef"><a class="header" href="#51-define-undef">5.1 `define, `undef</a></h2>
<p>在编译阶段，<strong>`define</strong> 用于文本替换，类似于 C 语言中的 <strong>#define</strong>。</p>
<p>一旦 <strong>`define</strong> 指令被编译，其在整个编译过程中都会有效。例如，在一个文件中定义</p>
<pre><code class="language-verilog">`ifdef, `ifndef, `elsif, `else, `endif
</code></pre>
<h2 id="52-include"><a class="header" href="#52-include">5.2 `include</a></h2>
<p>使用 <strong>`include</strong> 可以在编译时将一个 Verilog 文件内嵌到另一个 Verilog 文件中，作用类似于 C 语言中的 #include 结构。该指令通常用于将全局或公用的头文件包含在设计文件里。</p>
<p>文件路径既可以使用相对路径，也可以使用绝对路径。</p>
<pre><code class="language-verilog">`include         &quot;../../param.v&quot;
`include         &quot;header.v&quot;
</code></pre>
<h2 id="53-timescale"><a class="header" href="#53-timescale">5.3 `timescale</a></h2>
<p>在 Verilog 模型中，时延有具体的单位时间表述，并用 <strong>`timescale</strong> 编译指令将时间单位与实际时间相关联。</p>
<p>在编译过程中，<strong><code>timescale 指令会影响后面所有模块中的时延值，直至遇到另一个 **</code>timescale</strong> 指令或 <strong>`resetall</strong> 指令。</p>
<p>该指令用于定义时延、仿真的单位和精度，格式为：</p>
<pre><code class="language-verilog">`timescale      time_unit / time_precision
# time_unit 表示时间单位，time_precision 表示时间精度，它们均是由数字以及单位 s（秒），ms（毫秒），us（微妙），ns（纳秒），ps（皮秒）和 fs（飞秒）组成。时间精度可以和时间单位一样，但是时间精度大小不能超过时间单位大小

`timescale 1ns/100ps    //时间单位为1ns，精度为100ps，合法
</code></pre>
<h2 id="53-default_nettype"><a class="header" href="#53-default_nettype">5.3 `default_nettype</a></h2>
<p>该指令用于为隐式的线网变量指定为线网类型，即将没有被声明的连线定义为线网类型。</p>
<pre><code class="language-verilog">`default_nettype wand 
`default_nettype none
</code></pre>
<h1 id="6-时延"><a class="header" href="#6-时延">6. 时延</a></h1>
<h1 id="7-过程结构"><a class="header" href="#7-过程结构">7. 过程结构</a></h1>
<p>这些语句在模块间并行执行，与其在模块的前后顺序没有关系。</p>
<h2 id="71-initil"><a class="header" href="#71-initil">7.1 initil</a></h2>
<h2 id="72-always"><a class="header" href="#72-always">7.2 always</a></h2>
<h1 id="8-过程赋值"><a class="header" href="#8-过程赋值">8. 过程赋值</a></h1>
<p>在设计电路时，always 时序逻辑块中多用非阻塞赋值，always 组合逻辑块中多用阻塞赋值；在仿真电路时，initial 块中一般多用阻塞赋值</p>
<h2 id="81-阻塞赋值-"><a class="header" href="#81-阻塞赋值-">8.1 阻塞赋值 (=)</a></h2>
<h2 id="82-非阻塞赋值-"><a class="header" href="#82-非阻塞赋值-">8.2 非阻塞赋值 (&lt;=)</a></h2>
<h2 id="83-并行"><a class="header" href="#83-并行">8.3 并行</a></h2>
<h1 id="9-时序控制"><a class="header" href="#9-时序控制">9. 时序控制</a></h1>
<ul>
<li>事件控制用符号 <strong>@</strong> 表示。</li>
<li>posedge 指信号发生边沿正向跳变</li>
<li>negedge 指信号发生负向边沿跳变</li>
<li>未指明跳变方向时，则 2 种情况的边沿变化都会触发相关事件</li>
</ul>
<pre><code class="language-verilog">//信号clk只要发生变化，就执行q&lt;=d，双边沿D触发器模型
always @(clk) q &lt;= d ;                
//在信号clk上升沿时刻，执行q&lt;=d，正边沿D触发器模型
always @(posedge clk) q &lt;= d ;  
//在信号clk下降沿时刻，执行q&lt;=d，负边沿D触发器模型
always @(negedge clk) q &lt;= d ; 
//立刻计算d的值，并在clk上升沿时刻赋值给q，不推荐这种写法
q = @(posedge clk) d ;  
</code></pre>
<pre><code class="language-verilog">// Verilog 中还支持使用电平作为敏感信号来控制时序，即后面语句的执行需要等待某个条件为真。Verilog 中使用关键字 wait 来表示这种电平敏感情况
initial begin
    wait (start_enable) ;      //等待 start 信号
    forever begin
        //start信号使能后，在clk_samp上升沿，对数据进行整合
        @(posedge clk_samp)  ;
        data_buf = {data_if[0], data_if[1]} ;      
    end
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="web"><a class="header" href="#web">Web</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webassembly"><a class="header" href="#webassembly"><a href="https://juejin.cn/post/7038540255510659109">WebAssembly</a></a></h1>
<h1 id="1-安装cc转换工具"><a class="header" href="#1-安装cc转换工具">1. 安装C/C++转换工具</a></h1>
<pre><code class="language-shell"># https://emscripten.org/docs/getting_started/downloads.html
git clone https://github.com/emscripten-core/emsdk.git
cd emsdk
# Fetch the latest version of the emsdk (not needed the first time you clone)
git pull

# Download and install the latest SDK tools.
./emsdk install latest
# Make the &quot;latest&quot; SDK &quot;active&quot; for the current user. (writes .emscripten file)
./emsdk activate latest
# Activate PATH and other environment variables in the current terminal
source ./emsdk_env.sh
</code></pre>
<h1 id="2--测试"><a class="header" href="#2--测试">2.  测试</a></h1>
<pre><code class="language-shell">mkdir hello
cd hello
touch hello.c
</code></pre>
<pre><code class="language-c++">#include &lt;stdio.h&gt;
int main(int argc, char ** argv) {
    printf(&quot;Hello, world!&quot;);
}
</code></pre>
<pre><code class="language-shell"># 编译
emcc ./hello.c -s WASM=1 -s EXIT_RUNTIME=1 -o hello.html

# WASM=1 :表示生成wasm格式文件而不是asm格式文件，目前新版本默认就是wasm
# EXIT_RUNTIME=1:编译出的wasm默认情况下不会退出运行的，这是web情况下期待的方式，主程序main虽然运行结束了，但模块没有退出，静态变量可以保持在内存中，不释放。同时标准 I/O 缓冲区没有被flush，加此参数则能让模块结束，才能看到I/O输出，否则无法看到printf的输出
# o:输出文件格式
# O:是用来指定优化级别，优化级别有 -O0, -O1, -O2, -O3 -Os这五种级别。不指定是为 -O0, 即没有优化，开发时一般指定为 -O0 或 -O1， 这样编译速度快，调试方便。 正式发布时可以是 -O2 或 -O3，这时代码会优化，执行更快。-Os 不光是执行快，同时优化大小，可生成更小的执行文件。
# 执行后目录下会生成hello.html hello.js 和hello.wasm三个文件。
</code></pre>
<pre><code class="language-shell"># 运行
emrun --no_browser --port 8080 .

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="工具-1"><a class="header" href="#工具-1">工具</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gparted"><a class="header" href="#gparted">gparted</a></h1>
<h1 id="1-安装-1"><a class="header" href="#1-安装-1">1. 安装</a></h1>
<pre><code class="language-shell">apt install gparted
</code></pre>
<h1 id="2-系统盘扩容"><a class="header" href="#2-系统盘扩容">2. 系统盘扩容</a></h1>
<h2 id="21-提示系统盘只读"><a class="header" href="#21-提示系统盘只读">2.1 提示系统盘只读</a></h2>
<pre><code class="language-shell">sudo -i
mount -o remount -rw /
mount -o remount -rw /var/snap/firefox/common/host-hunspell # 挂载点 ,可以在info中查看
# 刷新后可以扩容
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ros2"><a class="header" href="#ros2">ROS2</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ros2_qt_demo"><a class="header" href="#ros2_qt_demo">ros2_qt_demo</a></h1>
<h1 id="1-生成qt5和ros2同名项目"><a class="header" href="#1-生成qt5和ros2同名项目">1. 生成qt5和ros2同名项目</a></h1>
<pre><code class="language-shell"># qtcreator 创建 名称为 ros2_qt_demo
# ros2 创建
mkdir ros2_ws
cd ros2_ws
mkdir src
ros2 pkg create --build-type ament_cmake ros2_qt_demo
mkdir ui # mainwindow.ui
mkdir resource # NULL
mkdir src  # main.cpp mainwindow.cpp
rm include/* # mainwindow.h
</code></pre>
<h1 id="2-合并cmakelisttxt"><a class="header" href="#2-合并cmakelisttxt">2. 合并CMakeList.txt</a></h1>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.8)
project(ros2_qt_demo)

if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES &quot;Clang&quot;)
  add_compile_options(-Wall -Wextra -Wpedantic)
endif()
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# find dependencies
find_package(ament_cmake REQUIRED)
find_package(QT NAMES Qt6 Qt5 REQUIRED COMPONENTS Widgets)
find_package(Qt${QT_VERSION_MAJOR} REQUIRED COMPONENTS Widgets)

# uncomment the following section in order to fill in
# further dependencies manually.
# find_package(&lt;dependency&gt; REQUIRED)

file(GLOB PRO_SRC_DIR RELATIVE ${CMAKE_SOURCE_DIR} FOLLOW_SYMLINKS src/*.cpp)
file(GLOB PRO_INCLUDE_DIR RELATIVE ${CMAKE_SOURCE_DIR} FOLLOW_SYMLINKS include/*.h *.hpp)
file(GLOB PRO_UI_DIR RELATIVE ${CMAKE_SOURCE_DIR} FOLLOW_SYMLINKS ui/*.ui)
file(GLOB PRO_RES_DIR RELATIVE ${CMAKE_SOURCE_DIR} FOLLOW_SYMLINKS resource/*.qrc)
qt5_wrap_ui(QT_UI_HPP ${PRO_UI_DIR})
qt5_wrap_cpp(QT_MOC_HPP ${PRO_INCLUDE_DIR})
qt5_add_resources(QT_RES_HPP ${PRO_RES_DIR})
include_directories(
	include/
	${CMAKE_CURRENT_BINARY_DIR}
)
add_executable(${PROJECT_NAME}
            ${PRO_SRC_DIR}
            ${PRO_INCLUDE_DIR}
            ${PRO_UI_DIR}
            # ${PRO_RES_DIR}
            ${QT_UI_HPP}
            ${QT_MOC_HPP}
            ${QT_RES_HPP}
        )

target_link_libraries(${PROJECT_NAME} PRIVATE Qt${QT_VERSION_MAJOR}::Widgets)
install(TARGETS ${PROJECT_NAME} DESTINATION lib/${PROJECT_NAME})
 
if(BUILD_TESTING)
  find_package(ament_lint_auto REQUIRED)
  # the following line skips the linter which checks for copyrights
  # comment the line when a copyright and license is added to all source files
  set(ament_cmake_copyright_FOUND TRUE)
  # the following line skips cpplint (only works in a git repo)
  # comment the line when this package is in a git repo and when
  # a copyright and license is added to all source files
  set(ament_cmake_cpplint_FOUND TRUE)
  ament_lint_auto_find_test_dependencies()
endif()
if(QT_VERSION_MAJOR EQUAL 6)
    qt_finalize_executable(ros2_qt_demo)
endif()
ament_package()

</code></pre>
<h1 id="3-qtcreator-使用"><a class="header" href="#3-qtcreator-使用">3. qtcreator 使用</a></h1>
<pre><code class="language-shell"># 需要进入到qtcreator的安装目录 使用终端打开
# 原因是 需要加载ros2的环境 # ~/.bashrc里面的
</code></pre>
<h1 id="4-coclon-使用"><a class="header" href="#4-coclon-使用">4. coclon 使用</a></h1>
<pre><code class="language-shell"># 安装
sudo apt install python3-colcon-common-extensions
# ros2_ws 目录
coclon build
source install/setup.sh
coclon run ros2_qt_demo ros2_qt_demo
# 也可以使用qtcreator打开,方法同3
</code></pre>
<h1 id="5-新建文件"><a class="header" href="#5-新建文件">5. 新建文件</a></h1>
<h2 id="51-通过qtcreator创建文件后需要将对应的hcppui-文件放入到具体的includesrcresource-文件夹中"><a class="header" href="#51-通过qtcreator创建文件后需要将对应的hcppui-文件放入到具体的includesrcresource-文件夹中">5.1 通过qtcreator创建文件后需要将对应的.h,.cpp,.ui 文件放入到具体的include,src,resource 文件夹中</a></h2>
<h2 id="52-新增之后需要到build目录手动执行cmake--之后qtcreator中才会刷新文件目录"><a class="header" href="#52-新增之后需要到build目录手动执行cmake--之后qtcreator中才会刷新文件目录">5.2 新增之后需要到build目录手动执行cmake .. ，之后qtcreator中才会刷新文件目录</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hass"><a class="header" href="#hass">HASS</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hass安装"><a class="header" href="#hass安装">HASS安装</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="postgresql"><a class="header" href="#postgresql">PostgreSQL</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
