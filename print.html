<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>梦北</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="学习笔记">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">README</a></li><li class="chapter-item expanded "><a href="CPP/index.html"><strong aria-hidden="true">1.</strong> CPP学习笔记</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="CPP/Object.html"><strong aria-hidden="true">1.1.</strong> 类</a></li><li class="chapter-item expanded "><a href="CPP/STL.html"><strong aria-hidden="true">1.2.</strong> STL</a></li><li class="chapter-item expanded "><a href="CPP/Thread.html"><strong aria-hidden="true">1.3.</strong> Thread</a></li><li class="chapter-item expanded "><a href="CPP/TCP_socket.html"><strong aria-hidden="true">1.4.</strong> TCP_Socket</a></li><li class="chapter-item expanded "><a href="CPP/C++11.html"><strong aria-hidden="true">1.5.</strong> C++11</a></li><li class="chapter-item expanded "><a href="CPP/EMC++.html"><strong aria-hidden="true">1.6.</strong> Effective Modern C++</a></li></ol></li><li class="chapter-item expanded "><a href="Programmer/index.html"><strong aria-hidden="true">2.</strong> 程序员笔记</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Programmer/pkg_config.html"><strong aria-hidden="true">2.1.</strong> PKG-CONFIG</a></li></ol></li><li class="chapter-item expanded "><a href="Media/index.html"><strong aria-hidden="true">3.</strong> 流媒体笔记</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Media/ffmpeg_cmd.html"><strong aria-hidden="true">3.1.</strong> FFMPEG 命令行学习笔记</a></li><li class="chapter-item expanded "><a href="Media/ffmpeg_install.html"><strong aria-hidden="true">3.2.</strong> FFMPEG 安装 MACOS</a></li><li class="chapter-item expanded "><a href="Media/cmake.html"><strong aria-hidden="true">3.3.</strong> CMAKE 模板</a></li><li class="chapter-item expanded "><a href="Media/yuvplayer.html"><strong aria-hidden="true">3.4.</strong> YUVPLayer Demo(C)</a></li><li class="chapter-item expanded "><a href="Media/pcmplayer.html"><strong aria-hidden="true">3.5.</strong> PCMPLayer Demo(C)</a></li></ol></li><li class="chapter-item expanded "><a href="Redis/index.html"><strong aria-hidden="true">4.</strong> Redis</a></li><li class="chapter-item expanded "><a href="NET/index.html"><strong aria-hidden="true">5.</strong> NET</a></li><li class="chapter-item expanded "><a href="Vim/index.html"><strong aria-hidden="true">6.</strong> VIM</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Vim/ccls.html"><strong aria-hidden="true">6.1.</strong> CCLS</a></li></ol></li><li class="chapter-item expanded "><a href="Base/index.html"><strong aria-hidden="true">7.</strong> Base</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Base/zoo.html"><strong aria-hidden="true">7.1.</strong> 计算机组成原理</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">梦北</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="readme"><a class="header" href="#readme">README</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cpp学习笔记"><a class="header" href="#cpp学习笔记">CPP学习笔记</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基于类对象"><a class="header" href="#基于类对象">基于类（对象）</a></h1>
<ul>
<li>
<p>类是<font color='red'><strong>数据</strong></font>和数据的处理函数的一种组织形式。</p>
</li>
<li>
<p>类的设计要点（优先考虑<font color='red'><strong>数据</strong></font>的设计）：</p>
<ul>
<li>
<p>类Header 和 类Body</p>
</li>
<li>
<p>类分为无指针类，和有指针类（拷贝构造，delete []等）</p>
</li>
<li>
<p>构造函数无返回值，尽量使用构造参数列表形式。</p>
<ul>
<li>拷贝构造：String(const String&amp; str)</li>
<li>拷贝赋值：String&amp; operator=(const String&amp; str)  || return *this</li>
<li>委托构造</li>
</ul>
</li>
<li>
<p>函数构造需要考虑（名称-参数（类型，权限）-返回值（类型，权限））：</p>
<ul>
<li>函数分为类内函数和全局函数（const 放在 成员函数上，不放在全局函数上）</li>
<li>参数类型，仅可能的使用引用传递</li>
<li>考虑是否使用const 修饰入参</li>
<li>返回值尽可能使用引用返回</li>
<li>考虑返回值是否使用const</li>
</ul>
</li>
<li>
<p>static</p>
<ul>
<li>静态函数只能处理静态数据</li>
<li>static 数据只有一份：instance</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="面向对象"><a class="header" href="#面向对象">面向对象</a></h1>
<ul>
<li>复合 （内存 has a， Container / Component）
<ul>
<li>构造由内到外</li>
<li>析构由外到内</li>
</ul>
</li>
<li>委托（复合 by reference，Handle / Body）
<ul>
<li>共享，引用计数</li>
</ul>
</li>
<li>继承（is a，子类中有一部分父类的信息，继承数据，继承函数的调用权）
<ul>
<li>构造由内（父类）而外</li>
<li>析构由外而内</li>
<li>虚函数（virtual）
<ul>
<li>非虚函数：override 不希望子类重写</li>
<li>虚函数：希望子类override 重写，已经有默认实现</li>
<li>纯虚函数：子类必须override vitual func = 0;，没有默认实现</li>
<li>虚指针 &amp;&amp; 虚表（静态绑定-- call某个地址 ｜ 动态--绑定看调用方，多态）
<ul>
<li>一定是指针调用触发 虚链路（多态）</li>
<li>三个条件：指针，虚函数，向上转型</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="1-零散"><a class="header" href="#1-零散">1 零散</a></h1>
<h2 id="转换函数"><a class="header" href="#转换函数">转换函数</a></h2>
<h2 id="explict明白的明确的"><a class="header" href="#explict明白的明确的">explict（明白的，明确的）</a></h2>
<ul>
<li>non-explict-one-argument ctor</li>
</ul>
<h2 id="pointer-likeclass智能指针迭代器"><a class="header" href="#pointer-likeclass智能指针迭代器">Pointer-likeClass（智能指针，迭代器）</a></h2>
<h2 id="function-likeclass仿函数"><a class="header" href="#function-likeclass仿函数">Function-likeClass（仿函数）</a></h2>
<h2 id="类模板"><a class="header" href="#类模板">类模板</a></h2>
<ul>
<li>使用时指定类型</li>
</ul>
<h2 id="函数模板"><a class="header" href="#函数模板">函数模板</a></h2>
<h2 id="成员模板"><a class="header" href="#成员模板">成员模板</a></h2>
<h2 id="模板特化全偏特化-范围个数缩小"><a class="header" href="#模板特化全偏特化-范围个数缩小">模板特化（全/偏特化-范围｜个数缩小）</a></h2>
<h2 id="模板模板参数"><a class="header" href="#模板模板参数">模板模板参数</a></h2>
<h2 id="数量不定的模板参数typename-typessizeofargs"><a class="header" href="#数量不定的模板参数typename-typessizeofargs">数量不定的模板参数：typename... Types：sizeof...(args)</a></h2>
<h2 id="auto编译时推理"><a class="header" href="#auto编译时推理">auto（编译时推理）</a></h2>
<ul>
<li>声明时需要定义</li>
</ul>
<h2 id="objectmodel"><a class="header" href="#objectmodel">ObjectModel</a></h2>
<ul>
<li>虚指针（vptr）</li>
<li>虚表（vtbl）</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stl"><a class="header" href="#stl">STL</a></h1>
<p><a href="CPP/../resource/Slide.pdf">参考资料</a></p>
<p><a href="CPP/../resource/sample.cpp">源码</a></p>
<p><img src="CPP/../assets/STL.png" alt="截屏2022-06-22 20.23.54" /></p>
<h1 id="容器container"><a class="header" href="#容器container">容器（Container）</a></h1>
<p>前闭后开</p>
<h2 id="结构与分类"><a class="header" href="#结构与分类">结构与分类</a></h2>
<ul>
<li>序列容器
<ul>
<li>Array(固定空间)</li>
<li>Vector</li>
<li>Deque</li>
<li>List
<ul>
<li>Forward-List（单向链表）</li>
</ul>
</li>
</ul>
</li>
<li>关联容器（key:value）
<ul>
<li>Set/Multiset
<ul>
<li>Unordered Set/Multiset</li>
</ul>
</li>
<li>Map/Multimap
<ul>
<li>Unordered Map/Multimap</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="list"><a class="header" href="#list">List</a></h2>
<ul>
<li>双向链表</li>
<li>迭代器是class，</li>
</ul>
<h2 id="vector"><a class="header" href="#vector">Vector</a></h2>
<ul>
<li>2倍动态增长</li>
<li>不能原地扩充</li>
<li>迭代器是原始指针</li>
</ul>
<h2 id="deque"><a class="header" href="#deque">Deque</a></h2>
<ul>
<li>分段Buffer</li>
<li>双向扩充</li>
<li>begin</li>
<li>end</li>
<li>iterator
<ul>
<li>cur</li>
<li>first</li>
<li>end</li>
<li>node</li>
</ul>
</li>
</ul>
<h1 id="分配器allocators"><a class="header" href="#分配器allocators">分配器（Allocators）</a></h1>
<ul>
<li>VC6 的分配器没有特殊设计，调用的是 malloc和free</li>
<li>BC5 的分配器也没有特殊设计</li>
<li>GCC
<ul>
<li>&lt;stl_alloc.h&gt;</li>
</ul>
</li>
</ul>
<h1 id="算法algorithms"><a class="header" href="#算法algorithms">算法（Algorithms）</a></h1>
<ul>
<li>所有的算法，最终的行为无非就是比大小。</li>
<li>算法问迭代器问题</li>
</ul>
<h2 id="1-算法是一个函数模板"><a class="header" href="#1-算法是一个函数模板">1. 算法是一个函数模板</a></h2>
<pre><code>- 从语言层次来讲，算法是一个函数模板
- 其余部件都是一个类模板
</code></pre>
<h2 id="2-处理迭代器"><a class="header" href="#2-处理迭代器">2. 处理迭代器</a></h2>
<h2 id="3-实例"><a class="header" href="#3-实例">3. 实例</a></h2>
<ul>
<li>accumulate（累计）</li>
<li>for_each</li>
<li>replace
<ul>
<li>replace_if</li>
<li>replace_copy</li>
</ul>
</li>
<li>count
<ul>
<li>count_if</li>
</ul>
</li>
<li>find
<ul>
<li>find_if</li>
</ul>
</li>
<li>sort</li>
<li>binary_search</li>
</ul>
<h1 id="迭代器iterators"><a class="header" href="#迭代器iterators">迭代器（Iterators）</a></h1>
<p><img src="CPP/../assets/%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E5%9E%8B.png" alt="截屏2022-06-22 12.52.02" /></p>
<h2 id="1-五种相关类型"><a class="header" href="#1-五种相关类型">1. 五种相关类型</a></h2>
<ul>
<li>iterator_category （分类）</li>
<li>distance（两个iterator之间的距离的类型）</li>
<li>value_type（数据类型）</li>
<li>reference</li>
<li>pointer</li>
</ul>
<h2 id="2-traits中间层"><a class="header" href="#2-traits中间层">2. traits（中间层）</a></h2>
<ul>
<li>用于封装原生指针，用以实现上述五种类型的数据。</li>
</ul>
<h2 id="3-接口"><a class="header" href="#3-接口">3. 接口</a></h2>
<div class="table-wrapper"><table><thead><tr><th>名称</th><th>初始化</th><th>前</th><th>后</th><th>首元素</th><th>尾元素</th><th>随机</th><th>随机查询</th><th>大小</th><th>容积</th><th>反转</th><th>重设大小</th></tr></thead><tbody>
<tr><td><a href="https://en.cppreference.com/w/cpp/header/array">array</a></td><td></td><td></td><td>[push|pop]_back</td><td>front</td><td>back</td><td>[]/insert/erase</td><td>[].data</td><td>size</td><td>capacity</td><td></td><td></td></tr>
<tr><td>vector</td><td>vector<int>v1</td><td></td><td>[push|pop]_back</td><td></td><td></td><td></td><td></td><td></td><td></td><td>reserve</td><td></td></tr>
<tr><td>stack</td><td></td><td>pop</td><td>push</td><td>top</td><td></td><td></td><td></td><td>size</td><td></td><td></td><td></td></tr>
<tr><td><a href="https://zh.cppreference.com/w/cpp/container/deque">queue</a></td><td></td><td>push</td><td>pop</td><td>front</td><td>back</td><td></td><td></td><td>Size</td><td></td><td></td><td></td></tr>
<tr><td>deque</td><td></td><td>[push|pop]_front</td><td>[push|pop]_back</td><td>front</td><td>back</td><td>insert/erase</td><td></td><td>size</td><td></td><td></td><td>resize</td></tr>
<tr><td>Forward-list</td><td></td><td>[push|pop]_front</td><td></td><td>front</td><td>back</td><td>insert/erase</td><td></td><td></td><td></td><td></td><td>resize</td></tr>
<tr><td>list</td><td></td><td>[push|pop]_front</td><td>[push|pop]_back</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>set/mutiset</td><td></td><td></td><td></td><td></td><td></td><td>insert/erase</td><td></td><td>Size</td><td></td><td></td><td></td></tr>
<tr><td>map/multimap</td><td></td><td></td><td></td><td></td><td></td><td>insert/erase</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>string</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>tuple</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div>
<h1 id="适配器adapters"><a class="header" href="#适配器adapters">适配器（Adapters）</a></h1>
<ul>
<li>容器的适配器
<ul>
<li>stack</li>
<li>queue</li>
</ul>
</li>
<li>函数适配器
<ul>
<li>bind2nd
<ul>
<li>binder2nd</li>
</ul>
</li>
<li>nto1（取反）</li>
</ul>
</li>
<li>新形式的适配器
<ul>
<li>bind</li>
</ul>
</li>
</ul>
<h1 id="仿函数functors"><a class="header" href="#仿函数functors">仿函数（Functors）</a></h1>
<ul>
<li>STL 的仿函数必须public继承binary_function或者unary_function之后才能被适配器适配</li>
</ul>
<h2 id="1-算术类-"><a class="header" href="#1-算术类-">1. 算术类（+/-）</a></h2>
<h2 id="2-逻辑运算类-"><a class="header" href="#2-逻辑运算类-">2. 逻辑运算类（&amp;&amp; ||）</a></h2>
<h2 id="3-相对关系类---"><a class="header" href="#3-相对关系类---">3. 相对关系类( &lt; | &gt;=)</a></h2>
<h2 id="4-binary_function两个操作数"><a class="header" href="#4-binary_function两个操作数">4. binary_function:（两个操作数）</a></h2>
<h2 id="5-unary_function一个操作数"><a class="header" href="#5-unary_function一个操作数">5. unary_function（一个操作数）</a></h2>
<h1 id="标准库其他"><a class="header" href="#标准库其他">标准库其他</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="thread"><a class="header" href="#thread">Thread</a></h1>
<h1 id="一主要函数"><a class="header" href="#一主要函数">一、主要函数</a></h1>
<pre><code class="language-C"> #include &lt;pthread.h&gt;

int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg)
int pthread_join(pthread_t thread, void **value_ptr)
 # ps -Lf pid 
int pthread_cancel(pthread_t thread)
int pthread_detach(pthread_t thread)
void pthread_exit(void *value_ptr)
int pthread_kill(pthread_t thread, int sig)
int pthread_once(pthread_once_t *once_control, void (*init_routine)(void))
pthread_t pthread_self(void)
pthread_equal(tid1, tid2)
</code></pre>
<h1 id="二具体功能"><a class="header" href="#二具体功能">二、具体功能</a></h1>
<h2 id="21-线程的创建"><a class="header" href="#21-线程的创建">2.1 线程的创建</a></h2>
<h2 id="22-线程的中止"><a class="header" href="#22-线程的中止">2.2 线程的中止</a></h2>
<h3 id="221-异常终止"><a class="header" href="#221-异常终止">2.2.1 异常终止</a></h3>
<ul>
<li>主线程退出，子线程被强行终止</li>
<li>子线程中调用 exit()，则整个<strong>进程</strong>全部退出</li>
<li>缺省行为是终止程序的信号，会终止整个<strong>进程</strong></li>
</ul>
<h3 id="222-正常终止"><a class="header" href="#222-正常终止">2.2.2 正常终止</a></h3>
<ul>
<li>线程使用 return 返回，return 0 无需转换，return (void*) 1; 返回值是线程的结束码。</li>
<li>线程可以被同一进程的其他线程调用 pthread_cancel() 结束。</li>
<li>在线程中调用 pthread_exit((void*)1) 退出</li>
</ul>
<h2 id="23-线程的参数传递"><a class="header" href="#23-线程的参数传递">2.3 线程的参数传递</a></h2>
<ul>
<li>线程创建顺序和线程运行顺序并不保证一致。</li>
<li>全局变量不能代替线程的参数传递</li>
<li>参数需要类型类型强制转换</li>
<li>传递整型参数
<ul>
<li>pthread_create(&amp;pid, NULL, func, (void*)(long) number))</li>
<li>printf(&quot;%d&quot;, (int)(long)arg)</li>
</ul>
</li>
<li>传递地址参数(需要给每个线程传递一个单独的地址，不能使用同一个地址：全局变量)
<ul>
<li>int* var1 = new int; *var = 1;</li>
<li>pthread_create(&amp;pid, NULL, func, var1))</li>
<li>printf(&quot;%xx&quot;, *(int*)arg)</li>
<li>var1 需要在线程中释放内存。 delete  (int*)arg;</li>
</ul>
</li>
<li>线程退出状态
<ul>
<li>void* pv = 0;</li>
<li>pthread_join(pid, &amp;pv);</li>
<li>pv 保存线程 返回的值。</li>
</ul>
</li>
</ul>
<h2 id="24-线程资源的回收"><a class="header" href="#24-线程资源的回收">2.4 线程资源的回收</a></h2>
<ul>
<li>线程分离
<ul>
<li>joinable(默认状态)，在线程结束时，之后不会释放全部的资源，而是等待join，join之后资源才会释放（因此只能join一次）
<ul>
<li>pthread_join()</li>
<li>pthread_tryjoin_np()</li>
<li>pthread_timedjoin_np()</li>
</ul>
</li>
<li>unjoinable（不可分离）
<ul>
<li>pthread_detach(tid);
<ul>
<li>可以放在线程函数中 pthread_detach(pthread_self());</li>
</ul>
</li>
<li>创建线程前，调用pthread_attr_setdetachstat()设置线程属性。</li>
</ul>
</li>
</ul>
</li>
<li>线程清理函数释放资源
<ul>
<li>pthread_cleanup_push(func)</li>
<li>pthread_cleanup_pop(1)
<ul>
<li>填 0 标识 只退出不执行清理函数</li>
<li>非 0 则会退出并执行清理函数</li>
</ul>
</li>
<li>可以有多个线程清理函数，但必须push和pop成对在<strong>同一语句块</strong>中出现</li>
<li>在线程退出时 会调用线程清理函数。
<ul>
<li>pthread_exit()</li>
<li>return</li>
<li>Pthread_cancel()</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="25-线程取消"><a class="header" href="#25-线程取消">2.5 线程取消</a></h2>
<ul>
<li>可以被join</li>
<li>返回值 为 PTHREAD_CANCELED ，即 -1</li>
<li>pthread_setcancelstate() 设置线程的取消状态
<ul>
<li>只能放在线程的主函数中</li>
<li>可以被取消</li>
<li>不可以被取消</li>
</ul>
</li>
<li>pthread_setcacheltype() 设置线程的取消类型
<ul>
<li>立即取消</li>
<li>执行到 取消点是进行取消（默认）
<ul>
<li>accept()</li>
<li>close()</li>
<li>pthread_testcancel()； 设置取消点</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="26-线程与信号"><a class="header" href="#26-线程与信号">2.6 线程与信号</a></h2>
<ul>
<li>在多线程程序中，外部向进程发送信号不会中断系统调用</li>
<li>在多线程程序中，信号的处理是所有线程共享的</li>
<li>进程中的信号可以送达单个线程，会中断系统调用
<ul>
<li>pthread_kill(tid, sig)</li>
</ul>
</li>
<li>如果某个线程因为信号被终止，则整个进程都会被终止</li>
</ul>
<h2 id="27-线程安全"><a class="header" href="#27-线程安全">2.7 线程安全</a></h2>
<ul>
<li>原子性，可见行，顺序性
<ul>
<li>volatile
<ul>
<li>不从缓存中读取数据，而是从内存中读取</li>
<li>禁止代码重排序</li>
<li>不是原子的</li>
</ul>
</li>
</ul>
</li>
<li>原子操作
<ul>
<li>原子操作函数</li>
<li>CAS执行</li>
<li>原子类型 std::atomic&lt;int&gt; var;</li>
</ul>
</li>
<li>线程同步锁</li>
</ul>
<h2 id="28-线程同步"><a class="header" href="#28-线程同步">2.8 线程同步</a></h2>
<h3 id="281-互斥锁"><a class="header" href="#281-互斥锁">2.8.1 互斥锁</a></h3>
<ul>
<li>加锁解锁，其他等待</li>
<li>mutex</li>
</ul>
<h3 id="282-自旋锁"><a class="header" href="#282-自旋锁">2.8.2 自旋锁</a></h3>
<ul>
<li>加锁解锁，其他不等待</li>
<li>spin</li>
<li>共享标志</li>
</ul>
<h3 id="283-读写锁"><a class="header" href="#283-读写锁">2.8.3 读写锁</a></h3>
<ul>
<li>读模式加锁（可以多个持有读锁）</li>
<li>写模式加锁（只有不加锁的时候才能申请写锁，只能有一个持有写锁）</li>
<li>不加锁</li>
<li>rw</li>
</ul>
<h3 id="284-条件变量专为生产消费者设计"><a class="header" href="#284-条件变量专为生产消费者设计">2.8.4 条件变量（专为生产消费者设计）</a></h3>
<ul>
<li>
<p>与互斥锁一起使用</p>
</li>
<li>
<p>pthread_cond_wait() 等待被唤醒</p>
<ul>
<li>把互斥锁解锁</li>
<li>阻塞，等待信号唤醒</li>
<li>条件被触发+互斥锁加锁 （原子操作）</li>
</ul>
<pre><code class="language-c">pthread_cond_timedwait();  // 等待被唤醒，带超时机制
pthread_cond_signal();  // 唤醒一个等待中的线程
pthread_cond_broadcast(); // 唤醒全部等待中的线程
</code></pre>
</li>
</ul>
<h3 id="285-匿名信号量"><a class="header" href="#285-匿名信号量">2.8.5 （匿名）信号量</a></h3>
<ul>
<li>
<p>一个整数计数器，数值表示空闲的临界资源的数量</p>
</li>
<li>
<p>申请资源时，信号量减少</p>
</li>
<li>
<p>释放资源后，信号量增加</p>
<pre><code class="language-C">sem_t sem;
int sem_init();
int sem_destroy();
int sem_wait(sem_t* sem); //P操作
int sem_trywait(sem_t* sem); // P操作，不阻塞
int sem_timedwait(sem_t* sem); // P操作，超时
int sem_post(sem_t* sem); //V操作
int sem_getvalue(); // 获取信号想的值
</code></pre>
</li>
</ul>
<h3 id="286-生产消费者模型"><a class="header" href="#286-生产消费者模型">2.8.6 生产消费者模型</a></h3>
<ul>
<li>基本概念</li>
<li>互斥锁 + 条件变量实现生产消费者模型
<ul>
<li>在线程清理函数中需要释放 互斥锁</li>
</ul>
</li>
<li>信号量 实现生产消费者模型
<ul>
<li>需要手动加锁解锁（或者使用信号量代替互斥锁）</li>
</ul>
</li>
</ul>
<h3 id="287-多线程程序"><a class="header" href="#287-多线程程序">2.8.7 多线程程序</a></h3>
<ul>
<li>全局变量的线程安全</li>
<li>是否有不可重入函数</li>
</ul>
<p><img src="CPP/../assets/%E5%AE%89%E5%85%A8%E5%87%BD%E6%95%B0.png" alt="安全函数" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tcp_socket"><a class="header" href="#tcp_socket">TCP_Socket</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c11语言"><a class="header" href="#c11语言">C++11语言</a></h1>
<h2 id="0-关键字"><a class="header" href="#0-关键字">0. 关键字</a></h2>
<p><img src="CPP/../assets/C11%E5%85%B3%E9%94%AE%E5%AD%97.png" alt="截屏2022-06-30 22.15.35" /></p>
<h3 id="01-explcit"><a class="header" href="#01-explcit">0.1 explcit</a></h3>
<h3 id="02-noexcept"><a class="header" href="#02-noexcept">0.2 noexcept</a></h3>
<h3 id="03-const"><a class="header" href="#03-const">0.3 const...</a></h3>
<h3 id="04-const"><a class="header" href="#04-const">0.4 const</a></h3>
<h3 id="05-static"><a class="header" href="#05-static">0.5 static</a></h3>
<h3 id="06-typeplate"><a class="header" href="#06-typeplate">0.6 typeplate</a></h3>
<h3 id="07-tpyename"><a class="header" href="#07-tpyename">0.7 tpyename</a></h3>
<h3 id="08-class"><a class="header" href="#08-class">0.8 class</a></h3>
<h3 id="09-decltype"><a class="header" href="#09-decltype">0.9 decltype</a></h3>
<h3 id="010-auto"><a class="header" href="#010-auto">0.10 auto</a></h3>
<h3 id="011-public"><a class="header" href="#011-public">0.11 public</a></h3>
<h3 id="012-private"><a class="header" href="#012-private">0.12 private</a></h3>
<h3 id="013-proteced"><a class="header" href="#013-proteced">0.13 proteced</a></h3>
<h3 id="014-virtual"><a class="header" href="#014-virtual">0.14 virtual</a></h3>
<h2 id="015"><a class="header" href="#015">0.15</a></h2>
<h2 id="1-lambda"><a class="header" href="#1-lambda">1. lambda</a></h2>
<ul>
<li>格式
<ul>
<li>[=, &amp;](int x, char y) mutable~opt~ throwSpec~opt~ -&gt;retType~opt~ {...}</li>
</ul>
</li>
</ul>
<h2 id="2-variadic-templates"><a class="header" href="#2-variadic-templates">2. Variadic Templates</a></h2>
<ul>
<li>参数类型变化</li>
<li>参数个数变化</li>
<li>函数</li>
<li>class</li>
<li>模版</li>
</ul>
<pre><code class="language-c++">// 不可省略，作为递归的出口
void func()
{
  
}
template &lt;typename T, typename... Types&gt;
void func(const T&amp; firstArg, const Types&amp;... args) // ... 是类型的参数一部分
{
  处理 firstArg;
  // sizeof...(args); 用于得到args参数的个数
	func(args...);
}
//////////////////////////////////////////////////////////////////////////////
template &lt;typename... Args&gt;
ostream&amp; operator&lt;&lt; (ostream&amp; os, const tuple&lt;Args...&gt;&amp; t) {
  os &lt;&lt; &quot;[&quot; &lt;&lt; PRINT_TUPLE&lt;0, sizeof...(Args), Args...&gt;::print(os, t);
  return os &lt;&lt; &quot;]&quot;;
}
template &lt;int IDX, int MAX, typename... Args&gt;
struct PRINT_TUPLE {
  static void print(ostream&amp; os, const tuple&lt;Args...&gt;&amp; t) {
    os &lt;&lt; get&lt;IDX&gt;(t) &lt;&lt; (IDX + 1 == MAX) ? &quot;&quot; : &quot;,&quot;;
    PRINT_TUPLE&lt;IDX+1, MAX, Args...&gt;::print(os, t);
  }
}
template &lt;int MAX, typename... Args&gt;
struct PRINT_TYPLE&lt;MAX, MAX, Args...&gt; {
 static void print(ostream&amp; os, const tuple&lt;Args...&gt;&amp; t) {
 }
}

// cout &lt;&lt; make_tuple(7.5, string(&quot;hello&quot;), 32, 42)
// [7.5,hello,32,42]

/////////////////////////////////////////////////////////////////////////////
// 递归的继承
</code></pre>
<p><img src="CPP/../assets/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF.png" alt="截屏2022-06-30 21.56.25" /></p>
<p><img src="CPP/../assets/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF2.png" alt="截屏2022-06-30 22.04.50" /></p>
<p><img src="CPP/../assets/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF3.png" alt="截屏2022-06-30 22.07.23" /></p>
<p><img src="CPP/../assets/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF4.png" alt="截屏2022-06-30 22.13.34" /></p>
<h2 id="3-initializer_lists"><a class="header" href="#3-initializer_lists">3. initializer_lists</a></h2>
<h1 id="c11标准库"><a class="header" href="#c11标准库">c++11标准库</a></h1>
<h2 id="右值引用move"><a class="header" href="#右值引用move">右值引用｜Move</a></h2>
<ul>
<li>右值通常是临时对象，不能出现在等号左边</li>
<li>拷贝指针（必须有指针）</li>
<li>使用 std::move(left_value) 来将左值引用当作右值引用，来使用move语义</li>
</ul>
<pre><code class="language-c++">M c1(c);
M c2(std::move(c1)); // 必须确保后续不在使用c1
cl.swap(c2);

// move ctor
MyString（MyString	&amp;&amp; str） noexcept: initization list {}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="effective-moderc-c"><a class="header" href="#effective-moderc-c">Effective Moderc C++</a></h1>
<h1 id="零"><a class="header" href="#零">零</a></h1>
<h2 id="类型名称值址权限"><a class="header" href="#类型名称值址权限">类型，名称，值，址，权限</a></h2>
<p>int a = 10;</p>
<p>const char* val; </p>
<p>char* const val;</p>
<h1 id="一类型推导"><a class="header" href="#一类型推导">一、类型推导</a></h1>
<h2 id="11-理解模版类型推导"><a class="header" href="#11-理解模版类型推导">1.1 理解模版类型推导</a></h2>
<pre><code class="language-c++">template&lt;typename T&gt;
void f(ParamType param);
f(expr)
</code></pre>
<h3 id="111-paramtype-是指针或者引用但不是万能引用万能引用对左值和右值的处理方式不一样"><a class="header" href="#111-paramtype-是指针或者引用但不是万能引用万能引用对左值和右值的处理方式不一样">1.1.1 ParamType 是指针或者引用，但不是万能引用（万能引用对左值和右值的处理方式不一样）</a></h3>
<ul>
<li>忽略<em>expt</em>的引用类型</li>
<li>对<em>expr</em>的类型和<em>ParamType</em> 进行模式匹配，确定<em>T</em>的类型</li>
</ul>
<pre><code class="language-c++">template&lt;typename T&gt;
void f(T&amp; param); // param是个引用

int X = 27;  // x的型别是int
const int cx = x;  // cx 的型别是 const int
const int&amp; rx = x; // rx 是 x 的型别为 const int 的引用

f(x); // T 的型别是 int. param 的型别是 int&amp;
f(cx); // T 的型别是 const int, param 的型别是 const int&amp; 
f(rx); // T 的和别是 const int, param 的和别是 const int&amp;
</code></pre>
<h3 id="112-paramtype-是个万能引用"><a class="header" href="#112-paramtype-是个万能引用">1.1.2 ParamType 是个万能引用</a></h3>
<ul>
<li>如果 <em>expr</em> 是个左值，<em>T</em>和<em>ParamType</em>都会被推导为左值引用
<ul>
<li>首先，这是在模板型别推导中， T 被推导为引用型别的唯一情形。 </li>
<li>其次，尽管在声明时使用的是右值引用语法，它的型别推导结果却是左值引用。</li>
</ul>
</li>
<li>如果 <em>expr</em> 是个右值，则使用 1.1.1 的规则</li>
</ul>
<pre><code class="language-c++">template&lt;typename T&gt; 
void f(T&amp;&amp; param); // param现在是个万能引用

int X = 27;
const int ex = x;
const int&amp; rx = x;

f(x);  // X 是个左值，所以 T 的型别是 int&amp;, param 的 型别也是 int&amp;
f(cx); // cx 是个左值，所以 T 的型别是 const int&amp;, param 的型别也是 const int&amp;
f(rx); // rx 是个左值，所以 T 的型别是 const int&amp;, param 的型别也是 const int&amp;
f(27); //27 是个右值，所以 T 的型别是 int, 这么 一来, param的型别就成 int&amp;&amp;
</code></pre>
<h3 id="113-paramtype既不是指针或者引用也不是万能指针"><a class="header" href="#113-paramtype既不是指针或者引用也不是万能指针">1.1.3 ParamType既不是指针或者引用，也不是万能指针</a></h3>
<ul>
<li>若 expr具有引用型别，则忽略其引用部分。</li>
<li>忽略 expr 的引用性之后，若 expr 是个 const 对象，也忽略之。若其是个 volatile 对象，同忽略之</li>
</ul>
<pre><code class="language-c++">template&lt;typename T&gt;
void f(T param); // param现在是按值传递

intX =27;
const int cx = x; 
const int&amp; rx = x;

f(x); // T 和 param 的节别都是 int
f(cx); //T 和 param 的型别还都是 int
f(rx); //T 和 param 的型别仍都是 int
/*
请注意，即使 cx 和 rx 代表 const 值， param 仍然不具有 const 型别。这是合理的 。 
param 是个完全独立千 cx 和 rx 存在的对象 cx 和 rx 的 一 个副本。
从而 cx 和 rx 不可修改这一事实并不能说明 param是否可以修改。
正是由于这一原因， expr 的常址 性以及挥发性 (volatileness, 若有)可以在推导 param 的型别时加以忽略:
仅仅由千 expr 不可修改，并不能断定其副本也不可修改。
*/
</code></pre>
<h2 id="11-auto"><a class="header" href="#11-auto">1.1 auto</a></h2>
<h2 id="12-decltype"><a class="header" href="#12-decltype">1.2 decltype</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="程序员笔记"><a class="header" href="#程序员笔记">程序员笔记</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pkg-config"><a class="header" href="#pkg-config">PKG-CONFIG</a></h1>
<h2 id="地址"><a class="header" href="#地址"><a href="https://www.freedesktop.org/wiki/Software/pkg-config/">地址</a></a></h2>
<h2 id="一般用法"><a class="header" href="#一般用法">一般用法</a></h2>
<pre><code class="language-shell"> gcc -o test test.c `pkg-config --libs --cflags glib-2.0`
</code></pre>
<h2 id="环境变量"><a class="header" href="#环境变量">环境变量</a></h2>
<pre><code class="language-shell">export PKG_CONGIG_PATH=$PKG_CONFIG_PATH
</code></pre>
<h2 id="常用参数"><a class="header" href="#常用参数">常用参数</a></h2>
<pre><code>--cflags # -I/usr/include/***

--libs # -L/usr/lib/***

--list-all # 查看所有模块信息

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="流媒体笔记"><a class="header" href="#流媒体笔记">流媒体笔记</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ffmpeg-命令行学习"><a class="header" href="#ffmpeg-命令行学习">FFMPEG 命令行学习</a></h1>
<h1 id="命令分类"><a class="header" href="#命令分类"><a href="http://ffmpeg.org/ffmpeg.html">命令分类</a></a></h1>
<h2 id="0-基本格式"><a class="header" href="#0-基本格式">0. 基本格式</a></h2>
<pre><code class="language-shell">ffmpeg [global_options] {[input_file_options] -i input_url} ... {[output_file_options] output_url} ...
</code></pre>
<h2 id="input_url--i"><a class="header" href="#input_url--i">Input_url (-i)</a></h2>
<ul>
<li>regular files</li>
<li>pipes</li>
<li>network streams</li>
<li>grabbing devices</li>
<li>Based 0 numbers</li>
<li>...</li>
</ul>
<h2 id="input-or-output-data-types"><a class="header" href="#input-or-output-data-types">Input or output data types</a></h2>
<ul>
<li>video</li>
<li>audios</li>
<li>subtitles</li>
<li>attachment</li>
<li>data</li>
</ul>
<h2 id="stream"><a class="header" href="#stream">Stream</a></h2>
<h3 id="selection"><a class="header" href="#selection">selection</a></h3>
<ul>
<li>-map (attachment streams can only use map)</li>
<li>-vn</li>
<li>-an</li>
<li>-sn</li>
<li>-dn</li>
</ul>
<h3 id="handling"><a class="header" href="#handling">handling</a></h3>
<ul>
<li>-codec</li>
</ul>
<h3 id="example"><a class="header" href="#example">example</a></h3>
<pre><code>input file 'A.avi'
      stream 0: video 640x360
      stream 1: audio 2 channels

input file 'B.mp4'
      stream 0: video 1920x1080
      stream 1: audio 2 channels
      stream 2: subtitles (text)
      stream 3: audio 5.1 channels
      stream 4: subtitles (text)

input file 'C.mkv'
      stream 0: video 1280x720
      stream 1: audio 2 channels
      stream 2: subtitles (image)
      
ffmpeg -i A.avi -i B.mp4 out1.mkv out2.wav -map 1:a -c:a copy out3.mov
MKV: a/v/s from B-0/B-3/B-2
WAV: a B-3
out3.mov/MAP: B-Audio
</code></pre>
<pre><code>ffmpeg -i C.mkv out1.mkv -c:s dvdsub -an out2.mkv
</code></pre>
<pre><code>ffmpeg -i A.avi -i C.mkv -i B.mp4 -filter_complex &quot;overlay&quot; out1.mp4 out2.srt
</code></pre>
<pre><code>ffmpeg -i A.avi -i B.mp4 -i C.mkv -filter_complex &quot;[1:v]hue=s=0[outv];overlay;aresample&quot; \
       -map '[outv]' -an        out1.mp4 \
                                out2.mkv \
       -map '[outv]' -map 1:a:0 out3.mkv
fail
</code></pre>
<pre><code>ffmpeg -i A.avi -i B.mp4 -i C.mkv -filter_complex &quot;[1:v]hue=s=0[outv];overlay;aresample&quot; \
       -an        out1.mp4 \
                  out2.mkv \
       -map 1:a:0 out3.mkv
       
fail
</code></pre>
<pre><code>ffmpeg -i A.avi -i B.mp4 -i C.mkv -filter_complex &quot;[1:v]hue=s=0,split=2[outv1][outv2];overlay;aresample&quot; \
        -map '[outv1]' -an        out1.mp4 \
                                  out2.mkv \
        -map '[outv2]' -map 1:a:0 out3.mkv
success
</code></pre>
<h2 id="基本流程"><a class="header" href="#基本流程">基本流程</a></h2>
<pre><code> _______              ______________
|       |            |              |
| input |  demuxer   | encoded data |   decoder
| file  | ---------&gt; | packets      | -----+
|_______|            |______________|      |
                                           v
                                       _________
                                      |         |
                                      | decoded |
                                      | frames  |
                                      |_________|
 ________             ______________       |
|        |           |              |      |
| output | &lt;-------- | encoded data | &lt;----+
| file   |   muxer   | packets      |   encoder
|________|           |______________|


</code></pre>
<h2 id="filtering-vf-or--af"><a class="header" href="#filtering-vf-or--af">Filtering（-vf or -af）</a></h2>
<h3 id="simple-filtergraphs"><a class="header" href="#simple-filtergraphs">simple filtergraphs</a></h3>
<pre><code> _________                        ______________
|         |                      |              |
| decoded |                      | encoded data |
| frames  |\                   _ | packets      |
|_________| \                  /||______________|
             \   __________   /
  simple     _\||          | /  encoder
  filtergraph   | filtered |/
                | frames   |
                |__________|

</code></pre>
<h3 id="filter-for-video"><a class="header" href="#filter-for-video">filter for video</a></h3>
<pre><code> _______        _____________        _______        ________
|       |      |             |      |       |      |        |
| input | ---&gt; | deinterlace | ---&gt; | scale | ---&gt; | output |
|_______|      |_____________|      |_______|      |________|

</code></pre>
<h2 id="complex-filter-graphs"><a class="header" href="#complex-filter-graphs">Complex filter graphs</a></h2>
<pre><code> _________
|         |
| input 0 |\                    __________
|_________| \                  |          |
             \   _________    /| output 0 |
              \ |         |  / |__________|
 _________     \| complex | /
|         |     |         |/
| input 1 |----&gt;| filter  |\
|_________|     |         | \   __________
               /| graph   |  \ |          |
              / |         |   \| output 1 |
 _________   /  |_________|    |__________|
|         | /
| input 2 |/
|_________|

</code></pre>
<h2 id="stream-copy"><a class="header" href="#stream-copy">Stream Copy</a></h2>
<pre><code> _______              ______________            ________
|       |            |              |          |        |
| input |  demuxer   | encoded data |  muxer   | output |
| file  | ---------&gt; | packets      | -------&gt; | file   |
|_______|            |______________|          |________|

</code></pre>
<h2 id="1-通用查询参数"><a class="header" href="#1-通用查询参数">1. 通用查询参数</a></h2>
<ul>
<li>-formats</li>
</ul>
<p>​	Show available formats (including devices).</p>
<ul>
<li>-demuxers</li>
</ul>
<p>​	Show available demuxers.</p>
<ul>
<li>-muxers</li>
</ul>
<p>​	Show available muxers.</p>
<ul>
<li>-devices</li>
</ul>
<p>​	Show available devices.</p>
<ul>
<li>-codecs</li>
</ul>
<p>​	Show all codecs known to libavcodec.</p>
<ul>
<li>-decoders</li>
</ul>
<p>​	Show available decoders.</p>
<ul>
<li>-encoders</li>
</ul>
<p>​	Show all available encoders.</p>
<ul>
<li>-bsfs</li>
</ul>
<p>​	Show available bitstream filters.</p>
<ul>
<li>-protocols</li>
</ul>
<p>​	Show available protocols.</p>
<ul>
<li>-filters</li>
</ul>
<p>​	Show available libavfilter filters.</p>
<ul>
<li>-pix_fmts</li>
</ul>
<p>​	Show available pixel formats.</p>
<ul>
<li>-sample_fmts</li>
</ul>
<p>​	Show available sample formats.</p>
<ul>
<li>-layouts</li>
</ul>
<p>​	Show channel names and standard channel layouts.</p>
<h2 id="2-av参数"><a class="header" href="#2-av参数">2. AV参数</a></h2>
<ul>
<li>
<p>-f fmt (<em>input/output</em>)</p>
<p>Force input or output file format. The format is normally auto detected for input files and guessed from the file extension for output files, so this option is not needed in most cases.</p>
</li>
<li>
<p>-i url (<em>input</em>)</p>
<p>input file url</p>
</li>
<li>
<p>-c[:stream_specifier] codec (<em>input/output,per-stream</em>)</p>
<p>-codec[:stream_specifier] codec (<em>input/output,per-stream</em>)</p>
<p>Select an encoder (when used before an output file) or a decoder (when used before an input file) for one or more streams. codec is the name of a decoder/encoder or a special value <code>copy</code> (output only) to indicate that the stream is not to be re-encoded.</p>
</li>
<li>
<p>-t duration (<em>input/output</em>)</p>
<p>When used as an input option (before <code>-i</code>), limit the duration of data read from the input file.</p>
<p>When used as an output option (before an output url), stop writing the output after its duration reaches duration.</p>
<p>duration must be a time duration specification, see <a href="http://ffmpeg.org/ffmpeg-utils.html#time-duration-syntax">(ffmpeg-utils)the Time duration section in the ffmpeg-utils(1) manual</a>.</p>
<p>-to and -t are mutually exclusive and -t has priority.</p>
</li>
<li>
<p>-to position (<em>input/output</em>)</p>
<p>Stop writing the output or reading the input at position. position must be a time duration specification, see <a href="http://ffmpeg.org/ffmpeg-utils.html#time-duration-syntax">(ffmpeg-utils)the Time duration section in the ffmpeg-utils(1) manual</a>.</p>
<p>-to and -t are mutually exclusive and -t has priority.</p>
</li>
<li>
<p>-ss position (<em>input/output</em>)</p>
<p>When used as an input option (before <code>-i</code>), seeks in this input file to position. Note that in most formats it is not possible to seek exactly, so <code>ffmpeg</code> will seek to the closest seek point before position. When transcoding and -accurate_seek is enabled (the default), this extra segment between the seek point and position will be decoded and discarded. When doing stream copy or when -noaccurate_seek is used, it will be preserved.</p>
<p>When used as an output option (before an output url), decodes but discards input until the timestamps reach position.</p>
</li>
<li>
<p>-filter[:stream_specifier] filtergraph (<em>output,per-stream</em>)</p>
<p>Create the filtergraph specified by filtergraph and use it to filter the stream.</p>
<p>filtergraph is a description of the filtergraph to apply to the stream, and must have a single input and a single output of the same type of the stream. In the filtergraph, the input is associated to the label <code>in</code>, and the output to the label <code>out</code>. See the ffmpeg-filters manual for more information about the filtergraph syntax.</p>
<p>See the <a href="http://ffmpeg.org/ffmpeg.html#filter_005fcomplex_005foption">-filter_complex option</a> if you want to create filtergraphs with multiple inputs and/or outputs.</p>
</li>
<li>
<p>ffmpeg -f avfoundation -list_devices true -i &quot;&quot;</p>
</li>
</ul>
<h2 id="3-video参数"><a class="header" href="#3-video参数">3. Video参数</a></h2>
<ul>
<li>
<p>-r[:stream_specifier] fps (<em>input/output,per-stream</em>)</p>
<p>Set frame rate (Hz value, fraction or abbreviation).</p>
<p>As an input option, ignore any timestamps stored in the file and instead generate timestamps assuming constant frame rate fps. This is not the same as the -framerate option used for some input formats like image2 or v4l2 (it used to be the same in older versions of FFmpeg). If in doubt use -framerate instead of the input option -r.</p>
<p>As an output option, duplicate or drop input frames to achieve constant output frame rate fps.</p>
</li>
<li>
<p>-fpsmax[:stream_specifier] fps (<em>output,per-stream</em>)</p>
<p>Set maximum frame rate (Hz value, fraction or abbreviation).</p>
<p>Clamps output frame rate when output framerate is auto-set and is higher than this value. Useful in batch processing or when input framerate is wrongly detected as very high. It cannot be set together with <code>-r</code>. It is ignored during streamcopy.</p>
</li>
<li>
<p>-s[:stream_specifier] size (<em>input/output,per-stream</em>)</p>
<p>Set frame size.</p>
<p>As an input option, this is a shortcut for the video_size private option, recognized by some demuxers for which the frame size is either not stored in the file or is configurable – e.g. raw video or video grabbers.</p>
<p>As an output option, this inserts the <code>scale</code> video filter to the <em>end</em> of the corresponding filtergraph. Please use the <code>scale</code> filter directly to insert it at the beginning or some other place.</p>
<p>The format is ‘wxh’ (default - same as source).</p>
</li>
<li>
<p>-vn (<em>input/output</em>)</p>
<p>As an input option, blocks all video streams of a file from being filtered or being automatically selected or mapped for any output. See <code>-discard</code> option to disable streams individually.</p>
<p>As an output option, disables video recording i.e. automatic selection or mapping of any video stream. For full manual control see the <code>-map</code> option.</p>
</li>
<li>
<p>-vcodec codec (<em>output</em>)</p>
<p>Set the video codec. This is an alias for <code>-codec:v</code>.</p>
</li>
<li>
<p>-vf filtergraph (<em>output</em>)</p>
<p>Create the filtergraph specified by filtergraph and use it to filter the stream.</p>
<p>This is an alias for <code>-filter:v</code>, see the <a href="http://ffmpeg.org/ffmpeg.html#filter_005foption">-filter option</a>.</p>
</li>
<li>
<p>-pix_fmt[:stream_specifier] format (<em>input/output,per-stream</em>)</p>
<p>-pixel_format</p>
<p>Set pixel format. Use <code>-pix_fmts</code> to show all the supported pixel formats. If the selected pixel format can not be selected, ffmpeg will print a warning and select the best pixel format supported by the encoder. If pix_fmt is prefixed by a <code>+</code>, ffmpeg will exit with an error if the requested pixel format can not be selected, and automatic conversions inside filtergraphs are disabled. If pix_fmt is a single <code>+</code>, ffmpeg selects the same pixel format as the input (or graph output) and automatic conversions are disabled.</p>
</li>
</ul>
<h2 id="4-audio参数"><a class="header" href="#4-audio参数">4. Audio参数</a></h2>
<ul>
<li>
<p>-aq q (<em>output</em>)</p>
<p>Set the audio quality (codec-specific, VBR). This is an alias for -q:a.</p>
</li>
<li>
<p>-ac[:stream_specifier] channels (<em>input/output,per-stream</em>)</p>
<p>Set the number of audio channels. For output streams it is set by default to the number of input audio channels. For input streams this option only makes sense for audio grabbing devices and raw demuxers and is mapped to the corresponding demuxer options.</p>
</li>
<li>
<p>-an (<em>input/output</em>)</p>
<p>As an input option, blocks all audio streams of a file from being filtered or being automatically selected or mapped for any output. See <code>-discard</code> option to disable streams individually.</p>
<p>As an output option, disables audio recording i.e. automatic selection or mapping of any audio stream. For full manual control see the <code>-map</code> option.</p>
</li>
<li>
<p>-acodec codec (<em>input/output</em>)</p>
<p>Set the audio codec. This is an alias for <code>-codec:a</code>.</p>
</li>
<li>
<p>-sample_fmt[:stream_specifier] sample_fmt (<em>output,per-stream</em>)</p>
<p>Set the audio sample format. Use <code>-sample_fmts</code> to get a list of supported sample formats.</p>
</li>
<li>
<p>-af filtergraph (<em>output</em>)</p>
<p>Create the filtergraph specified by filtergraph and use it to filter the stream.</p>
<p>This is an alias for <code>-filter:a</code>, see the <a href="http://ffmpeg.org/ffmpeg.html#filter_005foption">-filter option</a>.</p>
</li>
<li>
<p>-ar</p>
</li>
<li>
<p>-f sl6le</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ffmpeg-安装-macos"><a class="header" href="#ffmpeg-安装-macos">FFMPEG 安装 MACOS</a></h1>
<pre><code class="language-shell">./configure --prefix=/usr/local/ffmpeg --enable-gpl --enable-nonfree --enable-libfdk-aac --enable-libx264 --enable-libx265 --enable-filter=delogo --enable-debug --disable-optimizations --enable-libspeex --enable-videotoolbox --enable-shared --enable-pthreads --enable-version3 --enable-hardcoded-tables --cc=clang --host-cflags= --host-ldflags= --disable-x86asm

brew install fdk-aac&amp;&amp;brew install x264&amp;&amp;brew install x265&amp;&amp;brew install speex&amp;&amp;brew install pkg-config&amp;&amp;brew  install sdl2



export PATH=$PATH:/usr/local/ffmpeg/bin
export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig:/usr/lib/pkgconfig:/usr/local/Cellar/sdl2/2.0.8/lib/pkgconfig:/usr/local/ffmpeg/lib/pkgconfig

codesign --remove-signature /path/to/*.dylib
codesign -s &quot;Apple Development: Your Name (10-char-ID)&quot;  /path/to/*.dylib
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cmake-模板"><a class="header" href="#cmake-模板">CMAKE 模板</a></h1>
<h2 id="cmakepkg"><a class="header" href="#cmakepkg"><a href="https://cmake.org/cmake/help/v3.19/module/FindPkgConfig.html?highlight=pkg#command:pkg_check_modules">CMake+Pkg</a></a></h2>
<ul>
<li>
<p><code>&lt;XXX&gt;_FOUND</code></p>
<p>set to 1 if module(s) exist</p>
</li>
<li>
<p><code>&lt;XXX&gt;_LIBRARIES</code></p>
<p>only the libraries (without the ‘-l’)</p>
</li>
<li>
<p><code>&lt;XXX&gt;_LINK_LIBRARIES</code></p>
<p>the libraries and their absolute paths</p>
</li>
<li>
<p><code>&lt;XXX&gt;_LIBRARY_DIRS</code></p>
<p>the paths of the libraries (without the ‘-L’)</p>
</li>
<li>
<p><code>&lt;XXX&gt;_LDFLAGS</code></p>
<p>all required linker flags</p>
</li>
<li>
<p><code>&lt;XXX&gt;_LDFLAGS_OTHER</code></p>
<p>all other linker flags</p>
</li>
<li>
<p><code>&lt;XXX&gt;_INCLUDE_DIRS</code></p>
<p>the ‘-I’ preprocessor flags (without the ‘-I’)</p>
</li>
<li>
<p><code>&lt;XXX&gt;_CFLAGS</code></p>
<p>all required cflags</p>
</li>
<li>
<p><code>&lt;XXX&gt;_CFLAGS_OTHER</code></p>
<p>the other compiler flags</p>
</li>
</ul>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.19)
project(player)

set(CMAKE_CXX_STANDARD 11)
list(APPEND SOURCE
	src/main.c)
set(ENV{PKG_CONFIG_PATH} 
	/usr/local/sdl2/lib/pkgconfig:/usr/local/ffmpeg/lib/pkgconfig
)
find_package(PkgConfig)
pkg_check_modules(FFMPEG REQUIRED IMPORTED_TARGET libavcodec libavformat libavutil)
pkg_check_modules(SDL2 REQUIRED IMPORTED_TARGET sdl2)
add_executable(${PROJECT_NAME} ${SOURCE})
target_link_libraries(${PROJECT_NAME} PRIVATE
	PkgConfig::FFMPEG
	PkgConfig::SDL2
	)
</code></pre>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.19)
project(player)

set(CMAKE_CXX_STANDARD 11)
list(APPEND SOURCE
	src/main.c)
set(ENV{PKG_CONFIG_PATH} 
	/usr/local/sdl2/lib/pkgconfig:/usr/local/ffmpeg/lib/pkgconfig
)
find_package(PkgConfig)
pkg_check_modules(FFMPEG REQUIRED IMPORTED_TARGET libavcodec libavformat libavutil)
pkg_check_modules(SDL2 REQUIRED IMPORTED_TARGET sdl2)
add_executable(player ${SOURCE})
include_directories(
	${FFMPEG_INCLUDE_DIRS}
	${SDL2_INCLUDE_DIRS}
	)
target_link_libraries(player PRIVATE
	${FFMPEG_LDFLAGS}
	${SDL2_LDFLAGS}
	)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="yuvplayer-demo"><a class="header" href="#yuvplayer-demo">YUVPLayer Demo</a></h1>
<pre><code class="language-C">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;SDL.h&gt;
#include &lt;pthread.h&gt;
#define REFRESH_EVENT (SDL_USEREVENT + 1)
#define QUIT_EVENT (SDL_USEREVENT + 2)
bool thread_exit = false;
int refresh()
{
	thread_exit = false;
	while (!thread_exit) {
		SDL_Event event;
		event.type = REFRESH_EVENT;
		SDL_PushEvent(&amp;event);
		SDL_Delay(40);
	}
	thread_exit = true;

	SDL_Event event;
	event.type = QUIT_EVENT;
	SDL_PushEvent(&amp;event);
	return 0;
}
int main(int argc, char* argv[])
{
	FILE* video_fd = NULL;

	SDL_Event event = {0};
	SDL_Rect rect = {0};

	unsigned int pixformat = 0;
	
	SDL_Window* window = NULL;
	SDL_Renderer* renderer = NULL;
	SDL_Texture* texture = NULL;
	SDL_Thread* timer_thread = NULL;

	int win_w = 1920;
	int win_h = 1080;
	const int video_w = win_w;
	const int video_h = win_h;
	
	unsigned char* video_pos = NULL;
	unsigned char* video_end = NULL;

	unsigned int remain_len = 0;
	size_t video_buffer_len = 0;
	size_t blank_space_len = 0;
	unsigned char* video_buf = NULL;

	const char* path = &quot;1.yuv&quot;;
	const unsigned int yuv_frame_len = video_w * video_h * 12 / 8;
	unsigned int tmp_yuv_frame_len = yuv_frame_len;

	if (yuv_frame_len &amp; 0xF) {
		tmp_yuv_frame_len = (yuv_frame_len &amp; 0xFFF0) + 0x10;
	}

	if (SDL_Init(SDL_INIT_VIDEO)) {
		printf(&quot;SDL INIT Fail!\n&quot;);
		return -1;
	}
	window = SDL_CreateWindow(
			&quot;YUV Player&quot;,
			SDL_WINDOWPOS_UNDEFINED,
			SDL_WINDOWPOS_UNDEFINED,
			win_w, win_h,
			SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE
	);
	if (window == NULL) {
		printf(&quot;Window create Fail!\n&quot;);
		// TODO 资源释放
		return -1;
	} 
	renderer = SDL_CreateRenderer(window, -1, 0);
	// IYVU: Y + U + V (3 planes)
	// YV12: Y + V + U (3 planes)
	pixformat = SDL_PIXELFORMAT_IYUV;
	texture = SDL_CreateTexture(
							renderer,
							pixformat,
							SDL_TEXTUREACCESS_STREAMING,
							video_w, video_h
							);

	video_buf = (unsigned char*) malloc(tmp_yuv_frame_len);
	if (video_buf == NULL) {
		// TODO 资源释放
		return -1;
	}
	video_fd = fopen(path, &quot;r&quot;);
	video_buffer_len = fread(video_buf, 1, yuv_frame_len, video_fd);
	if (video_buffer_len &lt;= 0) {
		return -1;
	}
	video_pos = video_buf;
	timer_thread = SDL_CreateThread(
		refresh,
		&quot;thread&quot;,
		NULL
	);
	do {
		SDL_WaitEvent(&amp;event);
		if (event.type == REFRESH_EVENT) {
			SDL_UpdateTexture(texture, NULL, video_pos, video_w);
			rect.x = 0;
			rect.y = 0;
			rect.w = win_w;
			rect.h = win_h;
			SDL_RenderCopy(renderer, texture, NULL, &amp;rect);
			SDL_RenderPresent(renderer);

			video_buffer_len = fread(video_buf, 1, yuv_frame_len, video_fd);
			if (video_buffer_len &lt;= 0) {
				thread_exit = true;
				continue;
			}
		} else if (event.type == SDL_WINDOWEVENT) {
			SDL_GetWindowSize(window, &amp;win_w, &amp;win_h);
		} else if (event.type == SDL_QUIT) {
			thread_exit = true;
		} else if (event.type == QUIT_EVENT) {
			break;
		}
	} while(1);
	return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pcmplayer-democ"><a class="header" href="#pcmplayer-democ">PCMPLayer Demo(C)</a></h1>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;SDL.h&gt;
#include &lt;pthread.h&gt;
#define BLOCK_SIZE 4096000
unsigned char* audio_buf = NULL;
unsigned char* audio_pos = NULL;
size_t buffer_len = 0;
void read_audio_data(void* userdatai, Uint8* stream, int len)
{
	if (buffer_len == 0) {
		return;
	}
	SDL_memset(stream, 0, len);
	len = (len &lt; buffer_len) ? len : buffer_len;
	SDL_MixAudio(stream, audio_pos, len, SDL_MIX_MAXVOLUME);
	audio_pos += len;
	buffer_len -= len;
}
int main(int argc, char* argv[])
{
	if (SDL_Init(SDL_INIT_AUDIO) != 0) {
		SDL_Log(&quot;init fail!\n&quot;);
		return -1;
	}
	const char* path = &quot;1.pcm&quot;;
	FILE* audio_fd = fopen(path, &quot;r&quot;);
	if (audio_fd == NULL) {
		SDL_Log(&quot;open fail!\n&quot;);
		SDL_Quit();
		return -1;
	}
	audio_buf = malloc(BLOCK_SIZE);
	if (audio_buf == NULL) {
		SDL_Log(&quot;malloc fail!\n&quot;);
		fclose(audio_fd);
		SDL_Quit();
	}
	SDL_AudioSpec spec;
	spec.freq = 48000;
	spec.channels = 2;
	spec.format = AUDIO_S16SYS;
	spec.callback = read_audio_data;
	spec.userdata = NULL;
	if (SDL_OpenAudio(&amp;spec, NULL) != 0) {
		SDL_Log(&quot;open audio fail!\n&quot;);
		fclose(audio_fd);
		free(audio_buf);
		SDL_Quit();
		return -1;
	}
	SDL_PauseAudio(0);
	do {
		buffer_len = fread(audio_buf, 1, BLOCK_SIZE, audio_fd);
		audio_pos = audio_buf;
		while (audio_pos &lt; (audio_buf + buffer_len)) {
			SDL_Delay(1);
		}
	} while(buffer_len != 0);

	SDL_CloseAudio();
	fclose(audio_fd);
	free(audio_buf);
	SDL_Quit();
	return 0;
}	
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="redis"><a class="header" href="#redis">Redis</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="net"><a class="header" href="#net">NET</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vim"><a class="header" href="#vim">VIM</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ccls"><a class="header" href="#ccls">CCLS</a></h1>
<h1 id="1-依赖"><a class="header" href="#1-依赖">1. 依赖</a></h1>
<ul>
<li>vim8+ ｜ <a href="https://github.com/neovim/neovim/wiki/Installing-Neovim#install-from-download">neovim</a></li>
<li><a href="https://github.com/llvm/llvm-project/releases">clang+llvm</a></li>
<li><a href="https://github.com/MaskRay/ccls">ccls</a></li>
<li><a href="https://github.com/nvm-sh/nvm">nvm</a></li>
<li>Node</li>
<li><a href="https://github.com/junegunn/vim-plug">vim-plug</a></li>
<li><a href="https://github.com/neoclide/coc.nvim">coc.nvim</a></li>
</ul>
<h1 id="2-neovim可选"><a class="header" href="#2-neovim可选">2. neovim(可选)</a></h1>
<h1 id="3-clangllvm"><a class="header" href="#3-clangllvm">3. <a href="https://github.com/llvm/llvm-project/releases">clang+llvm</a></a></h1>
<pre><code class="language-shell">wget https://github.com/llvm/llvm-project/releases/download/llvmorg-13.0.0/clang+llvm-13.0.0-x86_64-linux-gnu-ubuntu-20.04.tar.xz

tar -xvf *.tar.zx
cd clang+llvm-13.0.0-x86_64-linux-gnu-ubuntu-20.04
# &gt; bashrc
############clang+llvm
export LLVM_HOME=***/clang+llvm-13.0.0-x86_64-linux-gnu-ubuntu-20.04
export PATH=$LLVM_HOME/bin:$PATH
export C_IONCLUDE_PATH=$LLVM_HOME/include:$C_INCLUDE_PATH
export LD_LIBRARY_PATH=$LLVM_HOME/lib:$LD_LIBRARY_PATH

</code></pre>
<h1 id="4-ccls"><a class="header" href="#4-ccls">4. <a href="https://github.com/MaskRay/ccls">ccls</a></a></h1>
<pre><code class="language-shell">git clone --depth=1 --recursive https://github.com/MaskRay/ccls
cd ccls
# sudo apt install zlib1g zlib1g-dev
cmake -H. -BRelease -DCMAKE_BUILD_TYPE=Release
cmake --build Release
</code></pre>
<h1 id="5-nvm"><a class="header" href="#5-nvm">5. <a href="https://github.com/nvm-sh/nvm#troubleshooting-on-linux">nvm</a></a></h1>
<pre><code class="language-bash">export NVM_DIR=&quot;$HOME/.nvm&quot; &amp;&amp; (
  git clone https://github.com/nvm-sh/nvm.git &quot;$NVM_DIR&quot;
  cd &quot;$NVM_DIR&quot;
  git checkout `git describe --abbrev=0 --tags --match &quot;v[0-9]*&quot; $(git rev-list --tags --max-count=1)`
) &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot;

# &gt;&gt; ~/.bashrc
export NVM_DIR=&quot;$HOME/.nvm&quot;
[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm
[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \. &quot;$NVM_DIR/bash_completion&quot;  # This loads nvm bash_completion

</code></pre>
<h1 id="6-node"><a class="header" href="#6-node">6. node</a></h1>
<pre><code class="language-shell">nvm ls-remote
nvm install * 
nvm use *
</code></pre>
<h1 id="7-cocnvm"><a class="header" href="#7-cocnvm">7. <a href="https://github.com/neoclide/coc.nvim">coc.nvm</a></a></h1>
<pre><code>Plug 'neoclide/coc.nvim', {'branch': 'master', 'do': 'yarn install --frozen-lockfile'}
</code></pre>
<h1 id="8-cmake-生成-compile_commandsjson"><a class="header" href="#8-cmake-生成-compile_commandsjson">8. CMake 生成 compile_commands.json</a></h1>
<pre><code class="language-cmake">set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
# -DCMAKE_EXPORT_COMPILE_COMMANDS=ON 
cmake -H. -Bbuild -DCMAKE_BUILD_TYPE=Release -DCMAKE_EXPORT_COMPILE_COMMANDS=ON &amp;&amp; ln build/compile_commands.json ./
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="base"><a class="header" href="#base">Base</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="计算机组成原理"><a class="header" href="#计算机组成原理">计算机组成原理</a></h1>
<h1 id="1-冯诺依曼系统三大组成"><a class="header" href="#1-冯诺依曼系统三大组成">1. 冯诺依曼系统三大组成</a></h1>
<h2 id="11-控制器"><a class="header" href="#11-控制器">1.1 控制器</a></h2>
<h3 id="111-性能"><a class="header" href="#111-性能">1.1.1 性能</a></h3>
<ul>
<li>空间</li>
<li>时间
<ul>
<li>指令周期</li>
<li>CPU周期</li>
<li>时钟周期</li>
<li>指令数 * 指令运行的平均周期 * 时钟周期 </li>
</ul>
</li>
<li>能耗
<ul>
<li>能耗= 1 / 2 * 负载电容 * 电压的平方 * 开关频率 * 晶体管数量</li>
</ul>
</li>
</ul>
<h3 id="112-控制流程"><a class="header" href="#112-控制流程">1.1.2 控制流程</a></h3>
<ul>
<li>取码</li>
<li>译码</li>
<li>执行（处理器执行）</li>
</ul>
<h2 id="12-处理器"><a class="header" href="#12-处理器">1.2 处理器</a></h2>
<ul>
<li>CPU（ALU）</li>
<li>GPU</li>
<li>DPU</li>
</ul>
<h2 id="13-存储器"><a class="header" href="#13-存储器">1.3 存储器</a></h2>
<ul>
<li>寄存器</li>
<li>内存</li>
<li>外存</li>
<li>网络存储</li>
</ul>
<h1 id="2-指令和运算"><a class="header" href="#2-指令和运算">2. 指令和运算</a></h1>
<h2 id="21-指令分类"><a class="header" href="#21-指令分类">2.1 指令分类</a></h2>
<ul>
<li>运算类</li>
<li>数据传输类</li>
<li>逻辑类
<ul>
<li>与或非异或</li>
<li>有条件跳转</li>
<li>无条件跳转</li>
</ul>
</li>
</ul>
<h2 id="22-性能优化"><a class="header" href="#22-性能优化">2.2 性能优化</a></h2>
<h3 id="221-指令流水线"><a class="header" href="#221-指令流水线">2.2.1 指令流水线</a></h3>
<ul>
<li>取码</li>
<li>译码</li>
<li>执行
<ul>
<li>ALU计算（执行）</li>
<li>访寸</li>
<li>写回</li>
</ul>
</li>
</ul>
<h3 id="222-结构冒险增加资源"><a class="header" href="#222-结构冒险增加资源">2.2.2 结构冒险（增加资源）</a></h3>
<ul>
<li>分为指令内存和数据内存（哈佛结构）</li>
<li>NOP再分配</li>
</ul>
<h3 id="223-数据冒险流水线冒泡"><a class="header" href="#223-数据冒险流水线冒泡">2.2.3 数据冒险（流水线冒泡）</a></h3>
<p>增加空指令NOP</p>
<ul>
<li>写后读（数据依赖）</li>
<li>读后写（反依赖）</li>
<li>写后写（输出依赖）</li>
</ul>
<p>指令分发和结果重排序（乱序）</p>
<h3 id="224-控制冒险"><a class="header" href="#224-控制冒险">2.2.4 控制冒险</a></h3>
<ul>
<li>分支预测</li>
<li>局部性原理</li>
</ul>
<h1 id="3-处理器"><a class="header" href="#3-处理器">3. 处理器</a></h1>
<ul>
<li>CPU
<ul>
<li>CISC</li>
<li>RISC</li>
<li>RISC-V</li>
</ul>
</li>
<li>GPU</li>
</ul>
<h1 id="4-存储与io"><a class="header" href="#4-存储与io">4. 存储与I/O</a></h1>
<h2 id="41-普通存储"><a class="header" href="#41-普通存储">4.1 普通存储</a></h2>
<ul>
<li>寄存器</li>
<li>内存
<ul>
<li>SRAM</li>
<li>DRAM</li>
</ul>
</li>
<li>外存
<ul>
<li>SSD</li>
<li>HHD</li>
</ul>
</li>
</ul>
<h2 id="42-存储信息同步"><a class="header" href="#42-存储信息同步">4.2 存储信息同步</a></h2>
<ul>
<li>写直达</li>
<li>写回</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
