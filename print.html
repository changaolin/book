<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>梦北</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="学习笔记">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="README.html">README</a></li><li><a href="CPP/README.html"><strong aria-hidden="true">1.</strong> CPP学习笔记</a></li><li><ol class="section"><li><a href="CPP/Object.html"><strong aria-hidden="true">1.1.</strong> 类</a></li><li><a href="CPP/STL.html"><strong aria-hidden="true">1.2.</strong> STL</a></li><li><a href="CPP/Thread.html"><strong aria-hidden="true">1.3.</strong> Thread</a></li><li><a href="CPP/TCP_socket.html"><strong aria-hidden="true">1.4.</strong> TCP_Socket</a></li></ol></li><li><a href="Programmer/README.html"><strong aria-hidden="true">2.</strong> 程序员笔记</a></li><li><ol class="section"><li><a href="Programmer/pkg_config.html"><strong aria-hidden="true">2.1.</strong> PKG-CONFIG</a></li></ol></li><li><a href="Media/README.html"><strong aria-hidden="true">3.</strong> 流媒体笔记</a></li><li><ol class="section"><li><a href="Media/ffmpeg_cmd.html"><strong aria-hidden="true">3.1.</strong> FFMPEG 命令行学习笔记</a></li><li><a href="Media/cmake.html"><strong aria-hidden="true">3.2.</strong> CMAKE 模板</a></li><li><a href="Media/yuvplayer.html"><strong aria-hidden="true">3.3.</strong> YUVPLayer Demo(C)</a></li><li><a href="Media/pcmplayer.html"><strong aria-hidden="true">3.4.</strong> PCMPLayer Demo(C)</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="submenu">
                                <li><button class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li><button class="theme" id="rust">Rust</button></li>
                                <li><button class="theme" id="coal">Coal</button></li>
                                <li><button class="theme" id="navy">Navy</button></li>
                                <li><button class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title">梦北</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="print.html#readme" id="readme"><h1>README</h1></a>
<a class="header" href="print.html#cpp学习笔记" id="cpp学习笔记"><h1>CPP学习笔记</h1></a>
<a class="header" href="print.html#基于类对象" id="基于类对象"><h1>基于类（对象）</h1></a>
<ul>
<li>
<p>类是<font color='red'><strong>数据</strong></font>和数据的处理函数的一种组织形式。</p>
</li>
<li>
<p>类的设计要点（优先考虑<font color='red'><strong>数据</strong></font>的设计）：</p>
<ul>
<li>
<p>类Header 和 类Body</p>
</li>
<li>
<p>类分为无指针类，和有指针类（拷贝构造，delete []等）</p>
</li>
<li>
<p>构造函数无返回值，尽量使用构造参数列表形式。</p>
<ul>
<li>拷贝构造：String(const String&amp; str)</li>
<li>拷贝赋值：String&amp; operator=(const String&amp; str)  || return *this</li>
<li>委托构造</li>
</ul>
</li>
<li>
<p>函数构造需要考虑（名称-参数（类型，权限）-返回值（类型，权限））：</p>
<ul>
<li>函数分为类内函数和全局函数（const 放在 成员函数上，不放在全局函数上）</li>
<li>参数类型，仅可能的使用引用传递</li>
<li>考虑是否使用const 修饰入参</li>
<li>返回值尽可能使用引用返回</li>
<li>考虑返回值是否使用const</li>
</ul>
</li>
<li>
<p>static</p>
<ul>
<li>静态函数只能处理静态数据</li>
<li>static 数据只有一份：instance</li>
</ul>
</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#面向对象" id="面向对象"><h1>面向对象</h1></a>
<ul>
<li>复合 （内存 has a， Container / Component）
<ul>
<li>构造由内到外</li>
<li>析构由外到内</li>
</ul>
</li>
<li>委托（复合 by reference，Handle / Body）
<ul>
<li>共享，引用计数</li>
</ul>
</li>
<li>继承（is a，子类中有一部分父类的信息，继承数据，继承函数的调用权）
<ul>
<li>构造由内（父类）而外</li>
<li>析构由外而内</li>
<li>虚函数（virtual）
<ul>
<li>非虚函数：override 不希望子类重写</li>
<li>虚函数：希望子类override 重写，已经有默认实现</li>
<li>纯虚函数：子类必须override vitual func = 0;，没有默认实现</li>
<li>虚指针 &amp;&amp; 虚表（静态绑定-- call某个地址 ｜ 动态--绑定看调用方，多态）
<ul>
<li>一定是指针调用触发 虚链路（多态）</li>
<li>三个条件：指针，虚函数，向上转型</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#1-零散" id="1-零散"><h1>1 零散</h1></a>
<a class="header" href="print.html#转换函数" id="转换函数"><h2>转换函数</h2></a>
<a class="header" href="print.html#explict明白的明确的" id="explict明白的明确的"><h2>explict（明白的，明确的）</h2></a>
<ul>
<li>non-explict-one-argument ctor</li>
</ul>
<a class="header" href="print.html#pointer-likeclass智能指针迭代器" id="pointer-likeclass智能指针迭代器"><h2>Pointer-likeClass（智能指针，迭代器）</h2></a>
<a class="header" href="print.html#function-likeclass仿函数" id="function-likeclass仿函数"><h2>Function-likeClass（仿函数）</h2></a>
<a class="header" href="print.html#类模板" id="类模板"><h2>类模板</h2></a>
<ul>
<li>使用时指定类型</li>
</ul>
<a class="header" href="print.html#函数模板" id="函数模板"><h2>函数模板</h2></a>
<a class="header" href="print.html#成员模板" id="成员模板"><h2>成员模板</h2></a>
<a class="header" href="print.html#模板特化全偏特化-范围个数缩小" id="模板特化全偏特化-范围个数缩小"><h2>模板特化（全/偏特化-范围｜个数缩小）</h2></a>
<a class="header" href="print.html#模板模板参数" id="模板模板参数"><h2>模板模板参数</h2></a>
<a class="header" href="print.html#数量不定的模板参数typename-typessizeofargs" id="数量不定的模板参数typename-typessizeofargs"><h2>数量不定的模板参数：typename... Types：sizeof...(args)</h2></a>
<a class="header" href="print.html#auto编译时推理" id="auto编译时推理"><h2>auto（编译时推理）</h2></a>
<ul>
<li>声明时需要定义</li>
</ul>
<a class="header" href="print.html#objectmodel" id="objectmodel"><h2>ObjectModel</h2></a>
<ul>
<li>虚指针（vptr）</li>
<li>虚表（vtbl）</li>
</ul>
<a class="header" href="print.html#stl" id="stl"><h1>STL</h1></a>
<p><a href="../resource/Slide.pdf">参考资料</a></p>
<p><a href="../resource/sample.cpp">源码</a></p>
<a class="header" href="print.html#容器container" id="容器container"><h1>容器（Container）</h1></a>
<p>前闭后开</p>
<a class="header" href="print.html#结构与分类" id="结构与分类"><h2>结构与分类</h2></a>
<ul>
<li>序列容器
<ul>
<li>Array(固定空间)</li>
<li>Vector</li>
<li>Deque</li>
<li>List
<ul>
<li>Forward-List（单向链表）</li>
</ul>
</li>
</ul>
</li>
<li>关联容器（key:value）
<ul>
<li>Set/Multiset
<ul>
<li>Unordered Set/Multiset</li>
</ul>
</li>
<li>Map/Multimap
<ul>
<li>Unordered Map/Multimap</li>
</ul>
</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#list" id="list"><h2>List</h2></a>
<ul>
<li>双向链表</li>
<li>迭代器是class，</li>
</ul>
<a class="header" href="print.html#vector" id="vector"><h2>Vector</h2></a>
<ul>
<li>2倍动态增长</li>
<li>不能原地扩充</li>
<li>迭代器是原始指针</li>
</ul>
<a class="header" href="print.html#deque" id="deque"><h2>Deque</h2></a>
<ul>
<li>分段Buffer</li>
<li>双向扩充</li>
<li>begin</li>
<li>end</li>
<li>iterator
<ul>
<li>cur</li>
<li>first</li>
<li>end</li>
<li>node</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#分配器allocators" id="分配器allocators"><h1>分配器（Allocators）</h1></a>
<ul>
<li>VC6 的分配器没有特殊设计，调用的是 malloc和free</li>
<li>BC5 的分配器也没有特殊设计</li>
<li>GCC
<ul>
<li>&lt;stl_alloc.h&gt;</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#算法algorithms" id="算法algorithms"><h1>算法（Algorithms）</h1></a>
<ul>
<li>所有的算法，最终的行为无非就是比大小。</li>
</ul>
<a class="header" href="print.html#1-算法是一个函数模板" id="1-算法是一个函数模板"><h2>1. 算法是一个函数模板</h2></a>
<pre><code>- 从语言层次来讲，算法是一个函数模板
- 其余部件都是一个类模板
</code></pre>
<a class="header" href="print.html#2-处理迭代器" id="2-处理迭代器"><h2>2. 处理迭代器</h2></a>
<a class="header" href="print.html#迭代器iterators" id="迭代器iterators"><h1>迭代器（Iterators）</h1></a>
<p><img src="../assets/%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E5%9E%8B.png" alt="截屏2022-06-22 12.52.02" /></p>
<a class="header" href="print.html#1-五种相关类型" id="1-五种相关类型"><h2>1. 五种相关类型</h2></a>
<ul>
<li>iterator_category （分类）</li>
<li>distance（两个iterator之间的距离的类型）</li>
<li>value_type（数据类型）</li>
<li>reference</li>
<li>pointer</li>
</ul>
<a class="header" href="print.html#2-traits中间层" id="2-traits中间层"><h2>2. traits（中间层）</h2></a>
<ul>
<li>用于封装原生指针，用以实现上述五种类型的数据。</li>
</ul>
<a class="header" href="print.html#适配器adapters" id="适配器adapters"><h1>适配器（Adapters）</h1></a>
<a class="header" href="print.html#仿函数functors" id="仿函数functors"><h1>仿函数（Functors）</h1></a>
<a class="header" href="print.html#标准库其他" id="标准库其他"><h1>标准库其他</h1></a>
<a class="header" href="print.html#thread" id="thread"><h1>Thread</h1></a>
<a class="header" href="print.html#一主要函数" id="一主要函数"><h1>一、主要函数</h1></a>
<pre><code class="language-C"> #include &lt;pthread.h&gt;

int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg)
int pthread_join(pthread_t thread, void **value_ptr)
 # ps -Lf pid 
int pthread_cancel(pthread_t thread)
int pthread_detach(pthread_t thread)
void pthread_exit(void *value_ptr)
int pthread_kill(pthread_t thread, int sig)
int pthread_once(pthread_once_t *once_control, void (*init_routine)(void))
pthread_t pthread_self(void)
pthread_equal(tid1, tid2)
</code></pre>
<a class="header" href="print.html#二具体功能" id="二具体功能"><h1>二、具体功能</h1></a>
<a class="header" href="print.html#21-线程的创建" id="21-线程的创建"><h2>2.1 线程的创建</h2></a>
<a class="header" href="print.html#22-线程的中止" id="22-线程的中止"><h2>2.2 线程的中止</h2></a>
<a class="header" href="print.html#221-异常终止" id="221-异常终止"><h3>2.2.1 异常终止</h3></a>
<ul>
<li>主线程退出，子线程被强行终止</li>
<li>子线程中调用 exit()，则整个<strong>进程</strong>全部退出</li>
<li>缺省行为是终止程序的信号，会终止整个<strong>进程</strong></li>
</ul>
<a class="header" href="print.html#222-正常终止" id="222-正常终止"><h3>2.2.2 正常终止</h3></a>
<ul>
<li>线程使用 return 返回，return 0 无需转换，return (void*) 1; 返回值是线程的结束码。</li>
<li>线程可以被同一进程的其他线程调用 pthread_cancel() 结束。</li>
<li>在线程中调用 pthread_exit((void*)1) 退出</li>
</ul>
<a class="header" href="print.html#23-线程的参数传递" id="23-线程的参数传递"><h2>2.3 线程的参数传递</h2></a>
<ul>
<li>线程创建顺序和线程运行顺序并不保证一致。</li>
<li>全局变量不能代替线程的参数传递</li>
<li>参数需要类型类型强制转换</li>
<li>传递整型参数
<ul>
<li>pthread_create(&amp;pid, NULL, func, (void*)(long) number))</li>
<li>printf(&quot;%d&quot;, (int)(long)arg)</li>
</ul>
</li>
<li>传递地址参数(需要给每个线程传递一个单独的地址，不能使用同一个地址：全局变量)
<ul>
<li>int* var1 = new int; <em>var = 1;</em>)arg;</li>
</ul>
</li>
<li>线程退出状态
<ul>
<li>void* pv = 0;</li>
<li>pthread_join(pid, &amp;pv);</li>
<li>pv 保存线程 返回的值。</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#24-线程资源的回收" id="24-线程资源的回收"><h2>2.4 线程资源的回收</h2></a>
<ul>
<li>线程分离
<ul>
<li>joinable(默认状态)，在线程结束时，之后不会释放全部的资源，而是等待join，join之后资源才会释放（因此只能join一次）
<ul>
<li>pthread_join()</li>
<li>pthread_tryjoin_np()</li>
<li>pthread_timedjoin_np()</li>
</ul>
</li>
<li>unjoinable（不可分离）
<ul>
<li>pthread_detach(tid);
<ul>
<li>可以放在线程函数中 pthread_detach(pthread_self());</li>
</ul>
</li>
<li>创建线程前，调用pthread_attr_setdetachstat()设置线程属性。</li>
</ul>
</li>
</ul>
</li>
<li>线程清理函数释放资源
<ul>
<li>pthread_cleanup_push(func)</li>
<li>pthread_cleanup_pop(1)
<ul>
<li>填 0 标识 只退出不执行清理函数</li>
<li>非 0 则会退出并执行清理函数</li>
</ul>
</li>
<li>可以有多个线程清理函数，但必须push和pop成对在<strong>同一语句块</strong>中出现</li>
<li>在线程退出时 会调用线程清理函数。
<ul>
<li>pthread_exit()</li>
<li>return</li>
<li>Pthread_cancel()</li>
</ul>
</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#25-线程取消" id="25-线程取消"><h2>2.5 线程取消</h2></a>
<ul>
<li>可以被join</li>
<li>返回值 为 PTHREAD_CANCELED ，即 -1</li>
<li>pthread_setcancelstate() 设置线程的取消状态
<ul>
<li>只能放在线程的主函数中</li>
<li>可以被取消</li>
<li>不可以被取消</li>
</ul>
</li>
<li>pthread_setcacheltype() 设置线程的取消类型
<ul>
<li>立即取消</li>
<li>执行到 取消点是进行取消（默认）
<ul>
<li>accept()</li>
<li>close()</li>
<li>pthread_testcancel()； 设置取消点</li>
</ul>
</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#26-线程与信号" id="26-线程与信号"><h2>2.6 线程与信号</h2></a>
<ul>
<li>在多线程程序中，外部向进程发送信号不会中断系统调用</li>
<li>在多线程程序中，信号的处理是所有线程共享的</li>
<li>进程中的信号可以送达单个线程，会中断系统调用
<ul>
<li>pthread_kill(tid, sig)</li>
</ul>
</li>
<li>如果某个线程因为信号被终止，则整个进程都会被终止</li>
</ul>
<a class="header" href="print.html#27-线程安全" id="27-线程安全"><h2>2.7 线程安全</h2></a>
<ul>
<li>原子性，可见行，顺序性
<ul>
<li>volatile
<ul>
<li>不从缓存中读取数据，而是从内存中读取</li>
<li>禁止代码重排序</li>
<li>不是原子的</li>
</ul>
</li>
</ul>
</li>
<li>原子操作
<ul>
<li>原子操作函数</li>
<li>CAS执行</li>
<li>原子类型 std::atomic&lt;int&gt; var;</li>
</ul>
</li>
<li>线程同步锁</li>
</ul>
<a class="header" href="print.html#28-线程同步" id="28-线程同步"><h2>2.8 线程同步</h2></a>
<a class="header" href="print.html#281-互斥锁" id="281-互斥锁"><h3>2.8.1 互斥锁</h3></a>
<ul>
<li>加锁解锁，其他等待</li>
<li>mutex</li>
</ul>
<a class="header" href="print.html#282-自旋锁" id="282-自旋锁"><h3>2.8.2 自旋锁</h3></a>
<ul>
<li>加锁解锁，其他不等待</li>
<li>spin</li>
<li>共享标志</li>
</ul>
<a class="header" href="print.html#283-读写锁" id="283-读写锁"><h3>2.8.3 读写锁</h3></a>
<ul>
<li>读模式加锁（可以多个持有读锁）</li>
<li>写模式加锁（只有不加锁的时候才能申请写锁，只能有一个持有写锁）</li>
<li>不加锁</li>
<li>rw</li>
</ul>
<a class="header" href="print.html#284-条件变量专为生产消费者设计" id="284-条件变量专为生产消费者设计"><h3>2.8.4 条件变量（专为生产消费者设计）</h3></a>
<ul>
<li>
<p>与互斥锁一起使用</p>
</li>
<li>
<p>pthread_cond_wait() 等待被唤醒</p>
<ul>
<li>把互斥锁解锁</li>
<li>阻塞，等待信号唤醒</li>
<li>条件被触发+互斥锁加锁 （原子操作）</li>
</ul>
<pre><code class="language-c">pthread_cond_timedwait();  // 等待被唤醒，带超时机制
pthread_cond_signal();  // 唤醒一个等待中的线程
pthread_cond_broadcast(); // 唤醒全部等待中的线程
</code></pre>
</li>
</ul>
<a class="header" href="print.html#285-匿名信号量" id="285-匿名信号量"><h3>2.8.5 （匿名）信号量</h3></a>
<ul>
<li>
<p>一个整数计数器，数值表示空闲的临界资源的数量</p>
</li>
<li>
<p>申请资源时，信号量减少</p>
</li>
<li>
<p>释放资源后，信号量增加</p>
<pre><code class="language-C">sem_t sem;
int sem_init();
int sem_destroy();
int sem_wait(sem_t* sem); //P操作
int sem_trywait(sem_t* sem); // P操作，不阻塞
int sem_timedwait(sem_t* sem); // P操作，超时
int sem_post(sem_t* sem); //V操作
int sem_getvalue(); // 获取信号想的值
</code></pre>
</li>
</ul>
<a class="header" href="print.html#286-生产消费者模型" id="286-生产消费者模型"><h3>2.8.6 生产消费者模型</h3></a>
<ul>
<li>基本概念</li>
<li>互斥锁 + 条件变量实现生产消费者模型
<ul>
<li>在线程清理函数中需要释放 互斥锁</li>
</ul>
</li>
<li>信号量 实现生产消费者模型
<ul>
<li>需要手动加锁解锁（或者使用信号量代替互斥锁）</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#287-多线程程序" id="287-多线程程序"><h3>2.8.7 多线程程序</h3></a>
<ul>
<li>全局变量的线程安全</li>
<li>是否有不可重入函数</li>
</ul>
<p><img src="../assets/%E5%AE%89%E5%85%A8%E5%87%BD%E6%95%B0.png" alt="安全函数" /></p>
<a class="header" href="print.html#tcp_socket" id="tcp_socket"><h1>TCP_Socket</h1></a>
<a class="header" href="print.html#程序员笔记" id="程序员笔记"><h1>程序员笔记</h1></a>
<a class="header" href="print.html#pkg-config" id="pkg-config"><h1>PKG-CONFIG</h1></a>
<a class="header" href="print.html#a-hrefhttpswwwfreedesktoporgwikisoftwarepkg-config地址a" id="a-hrefhttpswwwfreedesktoporgwikisoftwarepkg-config地址a"><h2><a href="https://www.freedesktop.org/wiki/Software/pkg-config/">地址</a></h2></a>
<a class="header" href="print.html#一般用法" id="一般用法"><h2>一般用法</h2></a>
<pre><code class="language-shell"> gcc -o test test.c `pkg-config --libs --cflags glib-2.0`
</code></pre>
<a class="header" href="print.html#环境变量" id="环境变量"><h2>环境变量</h2></a>
<pre><code class="language-shell">export PKG_CONGIG_PATH=$PKG_CONFIG_PATH
</code></pre>
<a class="header" href="print.html#常用参数" id="常用参数"><h2>常用参数</h2></a>
<pre><code>--cflags # -I/usr/include/***

--libs # -L/usr/lib/***

--list-all # 查看所有模块信息

</code></pre>
<a class="header" href="print.html#流媒体笔记" id="流媒体笔记"><h1>流媒体笔记</h1></a>
<a class="header" href="print.html#ffmpeg-命令行学习" id="ffmpeg-命令行学习"><h1>FFMPEG 命令行学习</h1></a>
<a class="header" href="print.html#a-hrefhttpffmpegorgffmpeghtml命令分类a" id="a-hrefhttpffmpegorgffmpeghtml命令分类a"><h1><a href="http://ffmpeg.org/ffmpeg.html">命令分类</a></h1></a>
<a class="header" href="print.html#0-基本格式" id="0-基本格式"><h2>0. 基本格式</h2></a>
<pre><code class="language-shell">ffmpeg [global_options] {[input_file_options] -i input_url} ... {[output_file_options] output_url} ...
</code></pre>
<a class="header" href="print.html#input_url--i" id="input_url--i"><h2>Input_url (-i)</h2></a>
<ul>
<li>regular files</li>
<li>pipes</li>
<li>network streams</li>
<li>grabbing devices</li>
<li>Based 0 numbers</li>
<li>...</li>
</ul>
<a class="header" href="print.html#input-or-output-data-types" id="input-or-output-data-types"><h2>Input or output data types</h2></a>
<ul>
<li>video</li>
<li>audios</li>
<li>subtitles</li>
<li>attachment</li>
<li>data</li>
</ul>
<a class="header" href="print.html#stream" id="stream"><h2>Stream</h2></a>
<a class="header" href="print.html#selection" id="selection"><h3>selection</h3></a>
<ul>
<li>-map (attachment streams can only use map)</li>
<li>-vn</li>
<li>-an</li>
<li>-sn</li>
<li>-dn</li>
</ul>
<a class="header" href="print.html#handling" id="handling"><h3>handling</h3></a>
<ul>
<li>-codec</li>
</ul>
<a class="header" href="print.html#example" id="example"><h3>example</h3></a>
<pre><code>input file 'A.avi'
      stream 0: video 640x360
      stream 1: audio 2 channels

input file 'B.mp4'
      stream 0: video 1920x1080
      stream 1: audio 2 channels
      stream 2: subtitles (text)
      stream 3: audio 5.1 channels
      stream 4: subtitles (text)

input file 'C.mkv'
      stream 0: video 1280x720
      stream 1: audio 2 channels
      stream 2: subtitles (image)
      
ffmpeg -i A.avi -i B.mp4 out1.mkv out2.wav -map 1:a -c:a copy out3.mov
MKV: a/v/s from B-0/B-3/B-2
WAV: a B-3
out3.mov/MAP: B-Audio
</code></pre>
<pre><code>ffmpeg -i C.mkv out1.mkv -c:s dvdsub -an out2.mkv
</code></pre>
<pre><code>ffmpeg -i A.avi -i C.mkv -i B.mp4 -filter_complex &quot;overlay&quot; out1.mp4 out2.srt
</code></pre>
<pre><code>ffmpeg -i A.avi -i B.mp4 -i C.mkv -filter_complex &quot;[1:v]hue=s=0[outv];overlay;aresample&quot; \
       -map '[outv]' -an        out1.mp4 \
                                out2.mkv \
       -map '[outv]' -map 1:a:0 out3.mkv
fail
</code></pre>
<pre><code>ffmpeg -i A.avi -i B.mp4 -i C.mkv -filter_complex &quot;[1:v]hue=s=0[outv];overlay;aresample&quot; \
       -an        out1.mp4 \
                  out2.mkv \
       -map 1:a:0 out3.mkv
       
fail
</code></pre>
<pre><code>ffmpeg -i A.avi -i B.mp4 -i C.mkv -filter_complex &quot;[1:v]hue=s=0,split=2[outv1][outv2];overlay;aresample&quot; \
        -map '[outv1]' -an        out1.mp4 \
                                  out2.mkv \
        -map '[outv2]' -map 1:a:0 out3.mkv
success
</code></pre>
<a class="header" href="print.html#基本流程" id="基本流程"><h2>基本流程</h2></a>
<pre><code> _______              ______________
|       |            |              |
| input |  demuxer   | encoded data |   decoder
| file  | ---------&gt; | packets      | -----+
|_______|            |______________|      |
                                           v
                                       _________
                                      |         |
                                      | decoded |
                                      | frames  |
                                      |_________|
 ________             ______________       |
|        |           |              |      |
| output | &lt;-------- | encoded data | &lt;----+
| file   |   muxer   | packets      |   encoder
|________|           |______________|


</code></pre>
<a class="header" href="print.html#filtering-vf-or--af" id="filtering-vf-or--af"><h2>Filtering（-vf or -af）</h2></a>
<a class="header" href="print.html#simple-filtergraphs" id="simple-filtergraphs"><h3>simple filtergraphs</h3></a>
<pre><code> _________                        ______________
|         |                      |              |
| decoded |                      | encoded data |
| frames  |\                   _ | packets      |
|_________| \                  /||______________|
             \   __________   /
  simple     _\||          | /  encoder
  filtergraph   | filtered |/
                | frames   |
                |__________|

</code></pre>
<a class="header" href="print.html#filter-for-video" id="filter-for-video"><h3>filter for video</h3></a>
<pre><code> _______        _____________        _______        ________
|       |      |             |      |       |      |        |
| input | ---&gt; | deinterlace | ---&gt; | scale | ---&gt; | output |
|_______|      |_____________|      |_______|      |________|

</code></pre>
<a class="header" href="print.html#complex-filter-graphs" id="complex-filter-graphs"><h2>Complex filter graphs</h2></a>
<pre><code> _________
|         |
| input 0 |\                    __________
|_________| \                  |          |
             \   _________    /| output 0 |
              \ |         |  / |__________|
 _________     \| complex | /
|         |     |         |/
| input 1 |----&gt;| filter  |\
|_________|     |         | \   __________
               /| graph   |  \ |          |
              / |         |   \| output 1 |
 _________   /  |_________|    |__________|
|         | /
| input 2 |/
|_________|

</code></pre>
<a class="header" href="print.html#stream-copy" id="stream-copy"><h2>Stream Copy</h2></a>
<pre><code> _______              ______________            ________
|       |            |              |          |        |
| input |  demuxer   | encoded data |  muxer   | output |
| file  | ---------&gt; | packets      | -------&gt; | file   |
|_______|            |______________|          |________|

</code></pre>
<a class="header" href="print.html#1-通用查询参数" id="1-通用查询参数"><h2>1. 通用查询参数</h2></a>
<ul>
<li>-formats</li>
</ul>
<p>​   Show available formats (including devices).</p>
<ul>
<li>-demuxers</li>
</ul>
<p>​   Show available demuxers.</p>
<ul>
<li>-muxers</li>
</ul>
<p>​   Show available muxers.</p>
<ul>
<li>-devices</li>
</ul>
<p>​   Show available devices.</p>
<ul>
<li>-codecs</li>
</ul>
<p>​   Show all codecs known to libavcodec.</p>
<ul>
<li>-decoders</li>
</ul>
<p>​   Show available decoders.</p>
<ul>
<li>-encoders</li>
</ul>
<p>​   Show all available encoders.</p>
<ul>
<li>-bsfs</li>
</ul>
<p>​   Show available bitstream filters.</p>
<ul>
<li>-protocols</li>
</ul>
<p>​   Show available protocols.</p>
<ul>
<li>-filters</li>
</ul>
<p>​   Show available libavfilter filters.</p>
<ul>
<li>-pix_fmts</li>
</ul>
<p>​   Show available pixel formats.</p>
<ul>
<li>-sample_fmts</li>
</ul>
<p>​   Show available sample formats.</p>
<ul>
<li>-layouts</li>
</ul>
<p>​   Show channel names and standard channel layouts.</p>
<a class="header" href="print.html#2-av参数" id="2-av参数"><h2>2. AV参数</h2></a>
<ul>
<li>
<p>-f fmt (<em>input/output</em>)</p>
<p>Force input or output file format. The format is normally auto detected for input files and guessed from the file extension for output files, so this option is not needed in most cases.</p>
</li>
<li>
<p>-i url (<em>input</em>)</p>
<p>input file url</p>
</li>
<li>
<p>-c[:stream_specifier] codec (<em>input/output,per-stream</em>)</p>
<p>-codec[:stream_specifier] codec (<em>input/output,per-stream</em>)</p>
<p>Select an encoder (when used before an output file) or a decoder (when used before an input file) for one or more streams. codec is the name of a decoder/encoder or a special value <code>copy</code> (output only) to indicate that the stream is not to be re-encoded.</p>
</li>
<li>
<p>-t duration (<em>input/output</em>)</p>
<p>When used as an input option (before <code>-i</code>), limit the duration of data read from the input file.</p>
<p>When used as an output option (before an output url), stop writing the output after its duration reaches duration.</p>
<p>duration must be a time duration specification, see <a href="http://ffmpeg.org/ffmpeg-utils.html#time-duration-syntax">(ffmpeg-utils)the Time duration section in the ffmpeg-utils(1) manual</a>.</p>
<p>-to and -t are mutually exclusive and -t has priority.</p>
</li>
<li>
<p>-to position (<em>input/output</em>)</p>
<p>Stop writing the output or reading the input at position. position must be a time duration specification, see <a href="http://ffmpeg.org/ffmpeg-utils.html#time-duration-syntax">(ffmpeg-utils)the Time duration section in the ffmpeg-utils(1) manual</a>.</p>
<p>-to and -t are mutually exclusive and -t has priority.</p>
</li>
<li>
<p>-ss position (<em>input/output</em>)</p>
<p>When used as an input option (before <code>-i</code>), seeks in this input file to position. Note that in most formats it is not possible to seek exactly, so <code>ffmpeg</code> will seek to the closest seek point before position. When transcoding and -accurate_seek is enabled (the default), this extra segment between the seek point and position will be decoded and discarded. When doing stream copy or when -noaccurate_seek is used, it will be preserved.</p>
<p>When used as an output option (before an output url), decodes but discards input until the timestamps reach position.</p>
</li>
<li>
<p>-filter[:stream_specifier] filtergraph (<em>output,per-stream</em>)</p>
<p>Create the filtergraph specified by filtergraph and use it to filter the stream.</p>
<p>filtergraph is a description of the filtergraph to apply to the stream, and must have a single input and a single output of the same type of the stream. In the filtergraph, the input is associated to the label <code>in</code>, and the output to the label <code>out</code>. See the ffmpeg-filters manual for more information about the filtergraph syntax.</p>
<p>See the <a href="http://ffmpeg.org/ffmpeg.html#filter_005fcomplex_005foption">-filter_complex option</a> if you want to create filtergraphs with multiple inputs and/or outputs.</p>
</li>
<li>
<p>ffmpeg -f avfoundation -list_devices true -i &quot;&quot;</p>
</li>
</ul>
<a class="header" href="print.html#3-video参数" id="3-video参数"><h2>3. Video参数</h2></a>
<ul>
<li>
<p>-r[:stream_specifier] fps (<em>input/output,per-stream</em>)</p>
<p>Set frame rate (Hz value, fraction or abbreviation).</p>
<p>As an input option, ignore any timestamps stored in the file and instead generate timestamps assuming constant frame rate fps. This is not the same as the -framerate option used for some input formats like image2 or v4l2 (it used to be the same in older versions of FFmpeg). If in doubt use -framerate instead of the input option -r.</p>
<p>As an output option, duplicate or drop input frames to achieve constant output frame rate fps.</p>
</li>
<li>
<p>-fpsmax[:stream_specifier] fps (<em>output,per-stream</em>)</p>
<p>Set maximum frame rate (Hz value, fraction or abbreviation).</p>
<p>Clamps output frame rate when output framerate is auto-set and is higher than this value. Useful in batch processing or when input framerate is wrongly detected as very high. It cannot be set together with <code>-r</code>. It is ignored during streamcopy.</p>
</li>
<li>
<p>-s[:stream_specifier] size (<em>input/output,per-stream</em>)</p>
<p>Set frame size.</p>
<p>As an input option, this is a shortcut for the video_size private option, recognized by some demuxers for which the frame size is either not stored in the file or is configurable – e.g. raw video or video grabbers.</p>
<p>As an output option, this inserts the <code>scale</code> video filter to the <em>end</em> of the corresponding filtergraph. Please use the <code>scale</code> filter directly to insert it at the beginning or some other place.</p>
<p>The format is ‘wxh’ (default - same as source).</p>
</li>
<li>
<p>-vn (<em>input/output</em>)</p>
<p>As an input option, blocks all video streams of a file from being filtered or being automatically selected or mapped for any output. See <code>-discard</code> option to disable streams individually.</p>
<p>As an output option, disables video recording i.e. automatic selection or mapping of any video stream. For full manual control see the <code>-map</code> option.</p>
</li>
<li>
<p>-vcodec codec (<em>output</em>)</p>
<p>Set the video codec. This is an alias for <code>-codec:v</code>.</p>
</li>
<li>
<p>-vf filtergraph (<em>output</em>)</p>
<p>Create the filtergraph specified by filtergraph and use it to filter the stream.</p>
<p>This is an alias for <code>-filter:v</code>, see the <a href="http://ffmpeg.org/ffmpeg.html#filter_005foption">-filter option</a>.</p>
</li>
<li>
<p>-pix_fmt[:stream_specifier] format (<em>input/output,per-stream</em>)</p>
<p>-pixel_format</p>
<p>Set pixel format. Use <code>-pix_fmts</code> to show all the supported pixel formats. If the selected pixel format can not be selected, ffmpeg will print a warning and select the best pixel format supported by the encoder. If pix_fmt is prefixed by a <code>+</code>, ffmpeg will exit with an error if the requested pixel format can not be selected, and automatic conversions inside filtergraphs are disabled. If pix_fmt is a single <code>+</code>, ffmpeg selects the same pixel format as the input (or graph output) and automatic conversions are disabled.</p>
</li>
</ul>
<a class="header" href="print.html#4-audio参数" id="4-audio参数"><h2>4. Audio参数</h2></a>
<ul>
<li>
<p>-aq q (<em>output</em>)</p>
<p>Set the audio quality (codec-specific, VBR). This is an alias for -q:a.</p>
</li>
<li>
<p>-ac[:stream_specifier] channels (<em>input/output,per-stream</em>)</p>
<p>Set the number of audio channels. For output streams it is set by default to the number of input audio channels. For input streams this option only makes sense for audio grabbing devices and raw demuxers and is mapped to the corresponding demuxer options.</p>
</li>
<li>
<p>-an (<em>input/output</em>)</p>
<p>As an input option, blocks all audio streams of a file from being filtered or being automatically selected or mapped for any output. See <code>-discard</code> option to disable streams individually.</p>
<p>As an output option, disables audio recording i.e. automatic selection or mapping of any audio stream. For full manual control see the <code>-map</code> option.</p>
</li>
<li>
<p>-acodec codec (<em>input/output</em>)</p>
<p>Set the audio codec. This is an alias for <code>-codec:a</code>.</p>
</li>
<li>
<p>-sample_fmt[:stream_specifier] sample_fmt (<em>output,per-stream</em>)</p>
<p>Set the audio sample format. Use <code>-sample_fmts</code> to get a list of supported sample formats.</p>
</li>
<li>
<p>-af filtergraph (<em>output</em>)</p>
<p>Create the filtergraph specified by filtergraph and use it to filter the stream.</p>
<p>This is an alias for <code>-filter:a</code>, see the <a href="http://ffmpeg.org/ffmpeg.html#filter_005foption">-filter option</a>.</p>
</li>
<li>
<p>-ar</p>
</li>
<li>
<p>-f sl6le</p>
</li>
</ul>
<a class="header" href="print.html#cmake-模板" id="cmake-模板"><h1>CMAKE 模板</h1></a>
<a class="header" href="print.html#a-hrefhttpscmakeorgcmakehelpv319modulefindpkgconfightmlhighlightpkgcommandpkg_check_modulescmakepkga" id="a-hrefhttpscmakeorgcmakehelpv319modulefindpkgconfightmlhighlightpkgcommandpkg_check_modulescmakepkga"><h2><a href="https://cmake.org/cmake/help/v3.19/module/FindPkgConfig.html?highlight=pkg#command:pkg_check_modules">CMake+Pkg</a></h2></a>
<ul>
<li>
<p><code>&lt;XXX&gt;_FOUND</code></p>
<p>set to 1 if module(s) exist</p>
</li>
<li>
<p><code>&lt;XXX&gt;_LIBRARIES</code></p>
<p>only the libraries (without the ‘-l’)</p>
</li>
<li>
<p><code>&lt;XXX&gt;_LINK_LIBRARIES</code></p>
<p>the libraries and their absolute paths</p>
</li>
<li>
<p><code>&lt;XXX&gt;_LIBRARY_DIRS</code></p>
<p>the paths of the libraries (without the ‘-L’)</p>
</li>
<li>
<p><code>&lt;XXX&gt;_LDFLAGS</code></p>
<p>all required linker flags</p>
</li>
<li>
<p><code>&lt;XXX&gt;_LDFLAGS_OTHER</code></p>
<p>all other linker flags</p>
</li>
<li>
<p><code>&lt;XXX&gt;_INCLUDE_DIRS</code></p>
<p>the ‘-I’ preprocessor flags (without the ‘-I’)</p>
</li>
<li>
<p><code>&lt;XXX&gt;_CFLAGS</code></p>
<p>all required cflags</p>
</li>
<li>
<p><code>&lt;XXX&gt;_CFLAGS_OTHER</code></p>
<p>the other compiler flags</p>
</li>
</ul>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.19)
project(player)

set(CMAKE_CXX_STANDARD 11)
list(APPEND SOURCE
    src/main.c)
set(ENV{PKG_CONFIG_PATH} 
    /usr/local/sdl2/lib/pkgconfig:/usr/local/ffmpeg/lib/pkgconfig
)
find_package(PkgConfig)
pkg_check_modules(FFMPEG REQUIRED IMPORTED_TARGET libavcodec libavformat libavutil)
pkg_check_modules(SDL2 REQUIRED IMPORTED_TARGET sdl2)
add_executable(${PROJECT_NAME} ${SOURCE})
target_link_libraries(${PROJECT_NAME} PRIVATE
    PkgConfig::FFMPEG
    PkgConfig::SDL2
    )
</code></pre>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.19)
project(player)

set(CMAKE_CXX_STANDARD 11)
list(APPEND SOURCE
    src/main.c)
set(ENV{PKG_CONFIG_PATH} 
    /usr/local/sdl2/lib/pkgconfig:/usr/local/ffmpeg/lib/pkgconfig
)
find_package(PkgConfig)
pkg_check_modules(FFMPEG REQUIRED IMPORTED_TARGET libavcodec libavformat libavutil)
pkg_check_modules(SDL2 REQUIRED IMPORTED_TARGET sdl2)
add_executable(player ${SOURCE})
include_directories(
    ${FFMPEG_INCLUDE_DIRS}
    ${SDL2_INCLUDE_DIRS}
    )
target_link_libraries(player PRIVATE
    ${FFMPEG_LDFLAGS}
    ${SDL2_LDFLAGS}
    )
</code></pre>
<a class="header" href="print.html#yuvplayer-demo" id="yuvplayer-demo"><h1>YUVPLayer Demo</h1></a>
<pre><code class="language-C">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;SDL.h&gt;
#include &lt;pthread.h&gt;
#define REFRESH_EVENT (SDL_USEREVENT + 1)
#define QUIT_EVENT (SDL_USEREVENT + 2)
bool thread_exit = false;
int refresh()
{
    thread_exit = false;
    while (!thread_exit) {
        SDL_Event event;
        event.type = REFRESH_EVENT;
        SDL_PushEvent(&amp;event);
        SDL_Delay(40);
    }
    thread_exit = true;

    SDL_Event event;
    event.type = QUIT_EVENT;
    SDL_PushEvent(&amp;event);
    return 0;
}
int main(int argc, char* argv[])
{
    FILE* video_fd = NULL;

    SDL_Event event = {0};
    SDL_Rect rect = {0};

    unsigned int pixformat = 0;
    
    SDL_Window* window = NULL;
    SDL_Renderer* renderer = NULL;
    SDL_Texture* texture = NULL;
    SDL_Thread* timer_thread = NULL;

    int win_w = 1920;
    int win_h = 1080;
    const int video_w = win_w;
    const int video_h = win_h;
    
    unsigned char* video_pos = NULL;
    unsigned char* video_end = NULL;

    unsigned int remain_len = 0;
    size_t video_buffer_len = 0;
    size_t blank_space_len = 0;
    unsigned char* video_buf = NULL;

    const char* path = &quot;1.yuv&quot;;
    const unsigned int yuv_frame_len = video_w * video_h * 12 / 8;
    unsigned int tmp_yuv_frame_len = yuv_frame_len;

    if (yuv_frame_len &amp; 0xF) {
        tmp_yuv_frame_len = (yuv_frame_len &amp; 0xFFF0) + 0x10;
    }

    if (SDL_Init(SDL_INIT_VIDEO)) {
        printf(&quot;SDL INIT Fail!\n&quot;);
        return -1;
    }
    window = SDL_CreateWindow(
            &quot;YUV Player&quot;,
            SDL_WINDOWPOS_UNDEFINED,
            SDL_WINDOWPOS_UNDEFINED,
            win_w, win_h,
            SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE
    );
    if (window == NULL) {
        printf(&quot;Window create Fail!\n&quot;);
        // TODO 资源释放
        return -1;
    } 
    renderer = SDL_CreateRenderer(window, -1, 0);
    // IYVU: Y + U + V (3 planes)
    // YV12: Y + V + U (3 planes)
    pixformat = SDL_PIXELFORMAT_IYUV;
    texture = SDL_CreateTexture(
                            renderer,
                            pixformat,
                            SDL_TEXTUREACCESS_STREAMING,
                            video_w, video_h
                            );

    video_buf = (unsigned char*) malloc(tmp_yuv_frame_len);
    if (video_buf == NULL) {
        // TODO 资源释放
        return -1;
    }
    video_fd = fopen(path, &quot;r&quot;);
    video_buffer_len = fread(video_buf, 1, yuv_frame_len, video_fd);
    if (video_buffer_len &lt;= 0) {
        return -1;
    }
    video_pos = video_buf;
    timer_thread = SDL_CreateThread(
        refresh,
        &quot;thread&quot;,
        NULL
    );
    do {
        SDL_WaitEvent(&amp;event);
        if (event.type == REFRESH_EVENT) {
            SDL_UpdateTexture(texture, NULL, video_pos, video_w);
            rect.x = 0;
            rect.y = 0;
            rect.w = win_w;
            rect.h = win_h;
            SDL_RenderCopy(renderer, texture, NULL, &amp;rect);
            SDL_RenderPresent(renderer);

            video_buffer_len = fread(video_buf, 1, yuv_frame_len, video_fd);
            if (video_buffer_len &lt;= 0) {
                thread_exit = true;
                continue;
            }
        } else if (event.type == SDL_WINDOWEVENT) {
            SDL_GetWindowSize(window, &amp;win_w, &amp;win_h);
        } else if (event.type == SDL_QUIT) {
            thread_exit = true;
        } else if (event.type == QUIT_EVENT) {
            break;
        }
    } while(1);
    return 0;
}
</code></pre>
<a class="header" href="print.html#pcmplayer-democ" id="pcmplayer-democ"><h1>PCMPLayer Demo(C)</h1></a>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;SDL.h&gt;
#include &lt;pthread.h&gt;
#define BLOCK_SIZE 4096000
unsigned char* audio_buf = NULL;
unsigned char* audio_pos = NULL;
size_t buffer_len = 0;
void read_audio_data(void* userdatai, Uint8* stream, int len)
{
    if (buffer_len == 0) {
        return;
    }
    SDL_memset(stream, 0, len);
    len = (len &lt; buffer_len) ? len : buffer_len;
    SDL_MixAudio(stream, audio_pos, len, SDL_MIX_MAXVOLUME);
    audio_pos += len;
    buffer_len -= len;
}
int main(int argc, char* argv[])
{
    if (SDL_Init(SDL_INIT_AUDIO) != 0) {
        SDL_Log(&quot;init fail!\n&quot;);
        return -1;
    }
    const char* path = &quot;1.pcm&quot;;
    FILE* audio_fd = fopen(path, &quot;r&quot;);
    if (audio_fd == NULL) {
        SDL_Log(&quot;open fail!\n&quot;);
        SDL_Quit();
        return -1;
    }
    audio_buf = malloc(BLOCK_SIZE);
    if (audio_buf == NULL) {
        SDL_Log(&quot;malloc fail!\n&quot;);
        fclose(audio_fd);
        SDL_Quit();
    }
    SDL_AudioSpec spec;
    spec.freq = 48000;
    spec.channels = 2;
    spec.format = AUDIO_S16SYS;
    spec.callback = read_audio_data;
    spec.userdata = NULL;
    if (SDL_OpenAudio(&amp;spec, NULL) != 0) {
        SDL_Log(&quot;open audio fail!\n&quot;);
        fclose(audio_fd);
        free(audio_buf);
        SDL_Quit();
        return -1;
    }
    SDL_PauseAudio(0);
    do {
        buffer_len = fread(audio_buf, 1, BLOCK_SIZE, audio_fd);
        audio_pos = audio_buf;
        while (audio_pos &lt; (audio_buf + buffer_len)) {
            SDL_Delay(1);
        }
    } while(buffer_len != 0);

    SDL_CloseAudio();
    fclose(audio_fd);
    free(audio_buf);
    SDL_Quit();
    return 0;
}	
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        

        

        
        <script>
            document.addEventListener('DOMContentLoaded', function() {
                window.print();
            })
        </script>
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
